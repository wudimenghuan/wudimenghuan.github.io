<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.stx8.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java 笔记数据类型和运算符   数据类型 字节数    int 4   long 8   char 2   float 4   double 8   bool 1   常量普通常量123456789public class Test1 &amp;#123;final int A &#x3D; 20;public static void main(String[] args) &amp;#123;Test1 test1">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 笔记">
<meta property="og:url" content="http://www.stx8.com/2018/03/08/java-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="时空主站">
<meta property="og:description" content="Java 笔记数据类型和运算符   数据类型 字节数    int 4   long 8   char 2   float 4   double 8   bool 1   常量普通常量123456789public class Test1 &amp;#123;final int A &#x3D; 20;public static void main(String[] args) &amp;#123;Test1 test1">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-03-08T13:21:27.000Z">
<meta property="article:modified_time" content="2018-03-08T13:21:27.000Z">
<meta property="article:author" content="时空">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.stx8.com/2018/03/08/java-%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://www.stx8.com/2018/03/08/java-%E7%AC%94%E8%AE%B0/","path":"2018/03/08/java-笔记/","title":"Java 笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java 笔记 | 时空主站</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90761248-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-90761248-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">时空主站</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">嗨，我是时空，一名来自中国的开发者。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-我的软件"><a href="/tags/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6/" rel="section"><i class="fa fa-desktop fa-fw"></i>我的软件</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-开源博客"><a href="https://my.oschina.net/wudimenghuan" rel="noopener" target="_blank"><i class="fa fa-code fa-fw"></i>开源博客</a></li><li class="menu-item menu-item-pgp"><a href="/pgp/" rel="section"><i class="fa fa-key fa-fw"></i>PGP</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">Java 笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.</span> <span class="nav-text">数据类型和运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">普通常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%B8%B8%E9%87%8F"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">类常量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-number">1.3.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%96%91%E9%9A%BE-equals-%E5%92%8C-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.1.</span> <span class="nav-text">常见疑难: equals 和 &#x3D;&#x3D; 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuffer"><span class="nav-number">1.4.</span> <span class="nav-text">StringBuffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%96%91%E9%9A%BE-%EF%BC%9AString-%E5%92%8C-StringBufffer-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.1.</span> <span class="nav-text">常见疑难 ：String 和 StringBufffer 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String-1"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer-1"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">StringBuffer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6%EF%BC%9Apublic-private-protected-default"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">访问控制符：public ,private ,protected, default</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB-%EF%BC%9AMath%EF%BC%8CDate"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">基础类 ：Math，Date</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E5%8C%85"><span class="nav-number">1.6.</span> <span class="nav-text">重载和包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-number">1.6.1.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85-package"><span class="nav-number">1.6.2.</span> <span class="nav-text">包 package</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-number">1.7.</span> <span class="nav-text">继承和多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.7.1.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%97%B6%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">设计类的继承时的建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-%E7%9A%84%E5%8D%95%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">java 的单继承性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">类之间的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.7.2.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-interface"><span class="nav-number">1.8.</span> <span class="nav-text">接口 interface</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E9%87%8D%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.1.</span> <span class="nav-text">接口的多重实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.2.</span> <span class="nav-text">接口的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">1.8.3.</span> <span class="nav-text">接口的继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.9.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">1.9.1.</span> <span class="nav-text">内部类的基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.9.2.</span> <span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.3.</span> <span class="nav-text">自定义泛型接口、泛型类和泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">1.9.4.</span> <span class="nav-text">关于泛型通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7"><span class="nav-number">1.9.5.</span> <span class="nav-text">关于泛型的一些特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">1.10.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.11.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.11.1.</span> <span class="nav-text">线程的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">通过实现Runnable接口的方式创建线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">通过继承Thread类的方式创建线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.11.2.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.11.3.</span> <span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92"><span class="nav-number">1.11.4.</span> <span class="nav-text">线程的休眠与唤醒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%AE%A9%E6%AD%A5-yield"><span class="nav-number">1.11.5.</span> <span class="nav-text">线程让步 yield()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">1.11.6.</span> <span class="nav-text">线程同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%9D%97"><span class="nav-number">1.11.7.</span> <span class="nav-text">同步块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6-FileInputStream"><span class="nav-number">1.11.8.</span> <span class="nav-text">使用文件字节输入流读取文件 FileInputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6-FileOutputStream"><span class="nav-number">1.11.9.</span> <span class="nav-text">使用文件字节输出流输出文件 FileOutputStream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">1.12.</span> <span class="nav-text">Java中对数据的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.12.1.</span> <span class="nav-text">基本数据类型和对象数据类型的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%95%B0%E6%8D%AE-Random"><span class="nav-number">1.12.2.</span> <span class="nav-text">如何处理随机性数据 Random</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%88%97%E3%80%81%E6%95%B4%E7%90%86-Arrays"><span class="nav-number">1.12.3.</span> <span class="nav-text">如何对数据进行排列、整理 Arrays</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.13.</span> <span class="nav-text">数据结构接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.13.1.</span> <span class="nav-text">Collection接口</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">时空</p>
  <div class="site-description" itemprop="description">时空主站</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/03/08/java-%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java 笔记 | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-08 21:21:27" itemprop="dateCreated datePublished" datetime="2018-03-08T21:21:27+08:00">2018-03-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/03/08/java-%E7%AC%94%E8%AE%B0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/08/java-笔记/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Java-笔记"><a href="#Java-笔记" class="headerlink" title="Java 笔记"></a>Java 笔记</h1><h2 id="数据类型和运算符"><a href="#数据类型和运算符" class="headerlink" title="数据类型和运算符"></a>数据类型和运算符</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>bool</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="普通常量"><a href="#普通常量" class="headerlink" title="普通常量"></a>普通常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">final int A = 20;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test1 test1 = new Test1();</span><br><span class="line">System.out.println(test1.A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类常量"><a href="#类常量" class="headerlink" title="类常量"></a>类常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">static final int B = 20;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(B);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量一般都定义为大写字母</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 30;</span><br><span class="line">System.out.println(a++);</span><br><span class="line">System.out.println(++a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>30<br>32</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>binarySearch()</code>, 使用二分搜索法来搜索指定数组，以获得指定对象。</p>
<p>在进行此调用之前，必须根据元素的自然顺序对数组进行升序排序（通过 sort() 方法）</p>
<p>参数：</p>
<ul>
<li>a - 要搜索的数组</li>
<li>key - 要搜索的值</li>
</ul>
<p>返回：</p>
<ul>
<li>如果它包含在数组中，则返回搜索键的索引；</li>
<li>否则返回 (-(插入点) - 1) 。</li>
<li>插入点被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为<code>a.length</code>。</li>
<li>注意，这保证了当且仅当此键被找到时，返回的值将 &gt;&#x3D; 0。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SearchArray</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">int[] array = &#123;2, 4, 6, 1, 3, 5, 9, 11, -5, 30, 100&#125;;</span><br><span class="line">Arrays.sort(array);</span><br><span class="line">int index = Arrays.binarySearch(array, 11);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line">System.out.println(&quot;The index of 11 is &quot;+index);</span><br><span class="line">index = Arrays.binarySearch(array, 10);</span><br><span class="line">System.out.println(&quot;The index of 10 is &quot;+index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>[-5, 1, 2, 3, 4, 5, 6, 9, 11, 30, 100]<br>The index of 11 is 8<br>The index of 10 is -9</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ol>
<li>串连接：<code>+</code>，<code>concat()</code></li>
<li>提取子字符串：<code>substring()</code></li>
<li>提取字符：<code>charAt()</code></li>
<li>获取字符串长度：<code>length</code></li>
<li>判断字符串是否相等：<code>equal()</code></li>
</ol>
<p>有的登陆系统密码忽略大小写。此时java语言中有个方法就是equalsIgnoreCase(String str)，这个方法忽略字符串大小写。</p>
<h3 id="常见疑难-equals-和-x3D-x3D-的区别"><a href="#常见疑难-equals-和-x3D-x3D-的区别" class="headerlink" title="常见疑难: equals 和 &#x3D;&#x3D; 的区别"></a>常见疑难: equals 和 &#x3D;&#x3D; 的区别</h3><p>java中的数据类型，可分为两类：</p>
<ol>
<li>基本数据类型，也称原始数据类型。</li>
</ol>
<p>byte,short,char,int,long,float,double,boolean</p>
<p>他们之间的比较，应用双等号（&#x3D;&#x3D;）,比较的是他们的值。</p>
<ol>
<li>复合数据类型(类)</li>
</ol>
<p>当他们用（&#x3D;&#x3D;）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。</p>
<p>对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（&#x3D;&#x3D;）进行比较的，所以比较后的结果跟双等号（&#x3D;&#x3D;）的结果相同。</p>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ol>
<li>追加：<code>append()</code></li>
<li>指定位置插入字符串：<code>insert()</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StringBufferTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">StringBuffer strbuf1 = new StringBuffer();</span><br><span class="line">System.out.println(strbuf1.capacity());</span><br><span class="line">System.out.println(strbuf1.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>16<br>0</p>
<h3 id="常见疑难-：String-和-StringBufffer-的区别"><a href="#常见疑难-：String-和-StringBufffer-的区别" class="headerlink" title="常见疑难 ：String 和 StringBufffer 的区别"></a>常见疑难 ：String 和 StringBufffer 的区别</h3><p>StringBuffer对象的内容可以修改；String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。</p>
<p>StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。</p>
<h4 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h4><p>在String类中没有用来改变已有字符串中的某个字符的方法，由于不能改变一个java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的。然而，不可改变的字符串具有一个很大的优点:编译器可以把字符串设为共享的。</p>
<h4 id="StringBuffer-1"><a href="#StringBuffer-1" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>StringBuffer类属于一种辅助类，可预先分配指定长度的内存块建立一个字符串缓冲区。这样使用StringBuffer类的append方法追加字符 比 String使用 + 操作符添加字符 到 一个已经存在的字符串后面有效率得多。因为使用 + 操作符每一次将字符添加到一个字符串中去时，字符串对象都需要寻找一个新的内存空间来容纳更大的字符串，这无凝是一个非常消耗时间的操作。添加多个字符也就意味着要一次又一次的对字符串重新分配内存。使用StringBuffer类就避免了这个问题。<br>StringBuffer是线程安全的，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="访问控制符：public-private-protected-default"><a href="#访问控制符：public-private-protected-default" class="headerlink" title="访问控制符：public ,private ,protected, default"></a>访问控制符：public ,private ,protected, default</h4><table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中可见</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>同一包中对子类可见</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>同一包中对非子类可见</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不同包中对子类可见</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不同包中对非子类可见</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="基础类-：Math，Date"><a href="#基础类-：Math，Date" class="headerlink" title="基础类 ：Math，Date"></a>基础类 ：Math，Date</h4><h2 id="重载和包"><a href="#重载和包" class="headerlink" title="重载和包"></a>重载和包</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载的实质</p>
<ul>
<li>方法名相同</li>
<li>参数个数可以不同</li>
<li>参数类型可以不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class overload &#123;</span><br><span class="line">// /一个普通的方法，不带参数</span><br><span class="line">void test() &#123;</span><br><span class="line">System.out.println(&quot;No parameters&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /重载上面的方法，并且带了一个整型参数</span><br><span class="line">void test(int a) &#123;</span><br><span class="line">System.out.println(&quot;a: &quot; + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /重载上面的方法，并且带了两个参数</span><br><span class="line">void test(int a, int b) &#123;</span><br><span class="line">System.out.println(&quot;a and b: &quot; + a + &quot; &quot; + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /重载上面的方法，并且带了一个双精度参数，与上面带一个参数的重载方法不一样</span><br><span class="line">double test(double a) &#123;</span><br><span class="line">System.out.println(&quot;double a: &quot; + a);</span><br><span class="line">return a * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">overload o = new overload(); //创建了对象o</span><br><span class="line">o.test();</span><br><span class="line">o.test(2);</span><br><span class="line">o.test(2, 3);</span><br><span class="line">o.test(2.0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>No parameters<br>a: 2<br>a and b: 2 3<br>double a: 2.0</p>
<h3 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h3><p><code>import com.stx8.test</code>，相当于C#里的<code>using</code>语句，C++里的头文件及namespace</p>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>extends</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">int a;</span><br><span class="line"></span><br><span class="line">People() &#123;</span><br><span class="line">a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People(int a) &#123;</span><br><span class="line">this.a = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class men extends People &#123;</span><br><span class="line">int b;</span><br><span class="line"></span><br><span class="line">men(int a, int b) &#123;</span><br><span class="line">super(a);</span><br><span class="line">this.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">men m = new men(10, 20); //通过带参构造函数创建men类对象</span><br><span class="line">System.out.println(m.a + &quot; &quot; + m.b); //调用对象的成员变量a和b</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设计类的继承时的建议"><a href="#设计类的继承时的建议" class="headerlink" title="设计类的继承时的建议"></a>设计类的继承时的建议</h4><p>不要使用受保护字段，即<code>protected</code>字段</p>
<p>如果不希望自己的类再被扩展，可以在类的声明之前加上<code>final</code>关键字。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>构造函数名字与类名相同(包括大小写)</li>
<li>一个类可以有多个构造函数</li>
<li>构造函数没有返回值，也不用写<code>void</code>关键字</li>
<li>构造函数总和new运算符一起被调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Test3_super&#123;</span><br><span class="line">public Test3_super() &#123;</span><br><span class="line">// TODO 自动生成的构造函数存根</span><br><span class="line">System.out.println(&quot;父类构造函数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void fun1()&#123;</span><br><span class="line">System.out.println(&quot;父类F1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">protected void fun2() &#123;</span><br><span class="line">System.out.println(&quot;父类F2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">private void fun3() &#123;</span><br><span class="line">System.out.println(&quot;父类F3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test3 extends Test3_super&#123;</span><br><span class="line"></span><br><span class="line">Test3()&#123;</span><br><span class="line">super();</span><br><span class="line">System.out.println(&quot;子类构造函数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void fun2() &#123;</span><br><span class="line">System.out.println(&quot;子类F2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Test3 test3 = new Test3();</span><br><span class="line">test3.fun1();</span><br><span class="line">test3.fun2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>父类构造函数<br>子类构造函数<br>父类F1<br>子类F2</p>
<h4 id="java-的单继承性"><a href="#java-的单继承性" class="headerlink" title="java 的单继承性"></a>java 的单继承性</h4><p>针对同一方法，子类的访问控制权限只能等于或大于父类。</p>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态一定要遵守两个规则：</p>
<ul>
<li>方法名称一定要一样</li>
<li>传入参数的类型一定要不一样</li>
</ul>
<p>多态的两种表现形势</p>
<ul>
<li>重载</li>
<li>覆盖</li>
</ul>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 <code>interface</code></h2><p>接口中只有方法名，没有具体实现的方法体。</p>
<p>接口的声明默认是 <code>public</code>，有时候也可以省略。</p>
<p>类实现接口是要使用 <code>implements</code>关键字</p>
<p>在类实现接口时要注意：</p>
<ul>
<li>声明类需要实现指定接口</li>
<li>提供接口中所有方法的定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.interfacetest;</span><br><span class="line"></span><br><span class="line">interface Alarm &#123;</span><br><span class="line">void alarm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AlarmDoor implements Alarm &#123;</span><br><span class="line"></span><br><span class="line">void open() &#123;</span><br><span class="line">System.out.println(&quot;door open&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void close() &#123;</span><br><span class="line">System.out.println(&quot;door close&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void alarm() &#123;</span><br><span class="line">System.out.println(&quot;a door with alarm&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">AlarmDoor alarmDoor = new AlarmDoor();</span><br><span class="line">alarmDoor.alarm();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的多重实现"><a href="#接口的多重实现" class="headerlink" title="接口的多重实现"></a>接口的多重实现</h3><p>为解决java类中的单继承，一个类可以实现一个接口，也可以实现其他接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.interfacetest;</span><br><span class="line"></span><br><span class="line">interface Alarm &#123;</span><br><span class="line">void alarm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Window &#123;</span><br><span class="line">void window();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AlarmDoor implements Alarm, Window &#123;</span><br><span class="line"></span><br><span class="line">public void window() &#123;</span><br><span class="line">System.out.println(&quot;a door with window&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void alarm() &#123;</span><br><span class="line">System.out.println(&quot;a door with alarm&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceTest2 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">AlarmDoor alarmDoor = new AlarmDoor();</span><br><span class="line">alarmDoor.alarm();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h3><p>接口不是一个类，不可以使用关键字<code>new</code>来生成一个接口的实例。但是可以声明一个接口变量 “school sc”.</p>
<p>如果要生成一个接口的实例，可以让接口变量指向一个已经实现该接口的类的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">school sc = new student();</span><br></pre></td></tr></table></figure>

<p>在接口中，不能声明实例字段及静态方法，但可以声明常量。接口不一定要有方法，可以全是常量。</p>
<h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>和类一样，使用<code>extends</code>关键字实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.interfacetest;</span><br><span class="line"></span><br><span class="line">interface Lock &#123;</span><br><span class="line">void lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface HighLock extends Lock&#123;</span><br><span class="line">void hignlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Door implements HighLock &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void hignlock() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">System.out.println(&quot;WOW high lock&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void lock() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">System.out.println(&quot;just lock&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceTest3 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Door door = new Door();</span><br><span class="line">door.lock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类就是在类的内部再创建一个类。</p>
<h3 id="内部类的基本结构"><a href="#内部类的基本结构" class="headerlink" title="内部类的基本结构"></a>内部类的基本结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.interclass;</span><br><span class="line"></span><br><span class="line">//外部类</span><br><span class="line">class Out &#123;</span><br><span class="line">private int age = 12;</span><br><span class="line"></span><br><span class="line">//内部类</span><br><span class="line">class In &#123;</span><br><span class="line">public void print() &#123;</span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterclassTest1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Out.In in = new Out().new In();</span><br><span class="line">in.print();</span><br><span class="line"></span><br><span class="line">Out out = new Out();</span><br><span class="line">Out.In in2 = out.new In();</span><br><span class="line">in2.print();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类也就是没有名字的内部类，正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</p>
<p>不使用匿名内部类来实现抽象方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.interclass;</span><br><span class="line"></span><br><span class="line">abstract class Person &#123;</span><br><span class="line">public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Person &#123;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;eat something&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterclassTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person p = new Child();</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>eat something</p>
<p>可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用，但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p>
<p>这个时候就引入了匿名内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.interclass;</span><br><span class="line"></span><br><span class="line">abstract class Person1 &#123;</span><br><span class="line">public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterclassTest3 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person p = new Person() &#123;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;eat something&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>eat something</p>
<p>由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p>
<p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承<code>Thread</code>类或是继承<code>Runnable</code>接口</p>
<p><code>Thread</code>类的匿名内部类实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Thread t = new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">System.out.print(i + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Runnable</code>接口的匿名内部类实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Runnable r = new Runnable() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt;= 5; i++) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; &#125;; Thread t = new Thread(r); t.start(); &#125; &#125; ``` 内部类的好处： - 内部类的对象能够访问创建他的对象的所有方法和属性，包括私有数据 - 对于同一个包中的其他类来说，内部类是隐形的 。 - 匿名内部类可以很方便的定义回调 - 使用内部类可以方便的编写时间驱动的程序。 作为一个单独的类，只能有 `default` 和 `public` 两种访问控制符，但是作为内部类，可以使用 `private` 控制符。当内部类设置为 `private` 时，包含此内部类的外部类的方法才可以访问它。 ### 使用内部类来访问对象 内部类这个机制之所以出现，是因为存在如下两个目的： - 可以让程序中逻辑上相关的类结合在一起 - 内部类可以直接访问外部类的成员。 ## 常见疑难 接口与继承的区别： - 属性：接口中的所有属性都是公开静态常量，继承则无所谓 - 方法：接口中所有方法都是公开抽象方法，继承中所有方法不一定是抽象的 - 接口方法：接口没有构造器，继承有构造器 ## 抽象和封装 抽象就是讲拥有共同方法和属性的对象提取出来，提取后，重新设计一个更加通用、更加大众的类，这个类成为抽象类。 ### 抽象类 `abstract` 具有一个或多个抽象方法的类，本身就要被定义为抽象类。含有抽象方法的类一定是抽象类。 抽象类不仅可以有抽象方法，也可以又具体的方法，一个类中只要有一个抽象方法，就是抽象类。 抽象类中不一定含有抽象的方法，也可以全部都是具体的方法。 抽象类是可以继承的，如果子类没有实现抽象类的全部抽象方法，那么子类也是抽象类。如果实现了抽象类的全部抽象方法，那么子类就不是抽象类。 抽象类不可以被实例化。但是可以声明一个抽象类的变量指向具体子类的对象。 抽象类的好处在于，有的方法在父类中不想实现时，可以不用实现。 ```java package com.abstracttest; abstract class Door&#123; abstract void open(); abstract void close(); &#125; class MyDoor extends Door&#123; @Override void open() &#123; // TODO 自动生成的方法存根 System.out.println(&quot;i can open&quot;); &#125; @Override void close() &#123; // TODO 自动生成的方法存根 System.out.println(&quot;i can close&quot;); &#125; &#125; public class AbstractTest1 &#123; public static void main(String[] args) &#123; MyDoor myDoor = new MyDoor(); myDoor.close(); &#125; &#125; ``` ## 常见疑难 抽象与接口的区别： 共同点 - 都不能创建实例对象 - 可以声明变量，通过指向子类或实现类的对象类，来创建对象实例。 不同点 - Java 不支持多重继承，即一个子类只能有一个父类，但一个子类可以实现多个接口。 - 接口内不能有实例字段，只能有静态变量，抽象类可以拥有实例字段 - 接口内方法自动设置为 `public`的，抽象类中的方法必须手动声明访问控制符。 ## 枚举 `enum` ## 反射 程序自己能够检查自身信息。反射使得java语言具有了“动态性”，即程序首先会检查某个类中的方法、属性等信息，然后再动态的调用或动态的创建该类或该类的对象。 ### 反射类的基石 ――`Class`类 任何事物都可以用类表示，那么java中的类可以用一个什么类表示呢？ 从JDK1.2开始，就出现了Class类，该类描述Java中的一切事物，该类描述了关于类事务的类名字、类的访问属性、类所属的包名等。 ### 反射的基本应用 所谓反射就是把java类中的各种成分映射成相应的java类。 不仅java类，可以用`Class`类的对象表示，而java类的各种成员：成员变量、方法、构造方法、包等也可以用相应的类表示。 Java反射机制主要提供了以下功能： - 在运行时判断任意一个对象所属的类； - 在运行时构造任意一个类的对象； - 在运行时判断任意一个类所具有的成员变量和方法； - 在运行时调用任意一个对象的方法。 反射一般会设计如下类 ： - `Class` : 表示一个类的类 - `Filed` : 表示属性的类 - `Method` ： 表示方法的类 - `Constructor` : 表示类的构造方法的类 &amp;gt; `Class`类位于java.lang包中，而后面3个的类都位于java.lang.reflect包中</span><br><span class="line"></span><br><span class="line">编写Java反射程序的步骤：</span><br><span class="line"></span><br><span class="line">- 必须首先获取一个类的Class对象</span><br><span class="line">- 然后分别调用Class对象中的方法来获取一个类的属性/方法/构造方法的结构</span><br><span class="line"></span><br><span class="line">现有一个类：</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">package com.reflection;</span><br><span class="line">public class TestReflection &#123;</span><br><span class="line"></span><br><span class="line">private String username;</span><br><span class="line">private String password;</span><br><span class="line">private int[] age;</span><br><span class="line"></span><br><span class="line">public void setUserName(String username) &#123;</span><br><span class="line">this.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setPassWord(String password) &#123;</span><br><span class="line">this.password = password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取一个类的Class对象：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;TestReflection tfReflection = new TestReflection();</span><br><span class="line">Class c1 = TestReflection.class;</span><br><span class="line">Class c2 = Class.forName(&quot;com.reflection.TestReflection&quot;);</span><br><span class="line">Class c3 = tfReflection.getClass();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定的包名：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;String package01 = c1.getPackage().getName();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取类的修饰符:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int mod = c1.getModifiers();</span><br><span class="line">String modifier = Modifier.toString(mod);</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定类的完全限定名：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;String className = c1.getName();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定类的父类:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Class superClazz = c1.getSuperclass();</span><br><span class="line">String superClazzName = superClazz.getName();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取实现的接口:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Class[] interfaces = c1.getInterfaces();</span><br><span class="line">for (Class t : interfaces) &#123;</span><br><span class="line">System.out.println(&quot;interfacesName = &quot; + t.getName());</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定类的成员变量:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Field[] fields = c1.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">modifier = Modifier.toString(field.getModifiers()); // 获取每个字段的访问修饰符</span><br><span class="line">Class type = field.getType(); // 获取字段的数据类型所对应的Class对象</span><br><span class="line">String name = field.getName(); // 获取字段名</span><br><span class="line">if (type.isArray()) &#123; // 如果是数组类型则需要特别处理</span><br><span class="line">String arrType = type.getComponentType().getName() + &quot;[]&quot;;</span><br><span class="line">System.out.println(&quot;&quot; + modifier + &quot; &quot; + arrType + &quot; &quot; + name + &quot;;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">System.out.println(&quot;&quot; + modifier + &quot; &quot; + type + &quot; &quot; + name + &quot;;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取类的构造方法:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Constructor[] constructors = c1.getDeclaredConstructors();</span><br><span class="line">for (Constructor constructor : constructors) &#123;</span><br><span class="line">String name = constructor.getName(); // 构造方法名</span><br><span class="line">modifier = Modifier.toString(constructor.getModifiers()); // 获取访问修饰符</span><br><span class="line">System.out.println(&quot;&quot; + modifier + &quot; &quot; + name + &quot;(&quot;);</span><br><span class="line">Class[] paramTypes = constructor.getParameterTypes(); // 获取构造方法中的参数</span><br><span class="line">for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123;</span><br><span class="line">System.out.print(&quot;,&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (paramTypes[i].isArray()) &#123;</span><br><span class="line">System.out.println(paramTypes[i].getComponentType().getName() + &quot;[]&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(paramTypes[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;);&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取成员方法:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Method[] methods = c1.getDeclaredMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">modifier = Modifier.toString(method.getModifiers());</span><br><span class="line">Class returnType = method.getReturnType(); // 获取方法的返回类型</span><br><span class="line">if (returnType.isArray()) &#123;</span><br><span class="line">String arrType = returnType.getComponentType().getName() + &quot;[]&quot;;</span><br><span class="line">System.out.print(&quot;&quot; + modifier + &quot; &quot; + arrType + &quot; &quot; + method.getName() + &quot;(&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(&quot;&quot; + modifier + &quot; &quot; + returnType.getName() + &quot; &quot; + method.getName() + &quot;(&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Class[] paramTypes = method.getParameterTypes();</span><br><span class="line">for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123;</span><br><span class="line">System.out.print(&quot;,&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (paramTypes[i].isArray()) &#123;</span><br><span class="line">System.out.println(paramTypes[i].getComponentType().getName() + &quot;[]&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(paramTypes[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;);&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">反射调用方法，可以通过Method类的invoke方法实现动态方法的调用:</span><br><span class="line"></span><br><span class="line">&lt;code&gt;public Object invoke(Object obj, Object... args)&lt;/code&gt;</span><br><span class="line">第一个参数代表对象</span><br><span class="line">第二个参数代表执行方法上的参数</span><br><span class="line"></span><br><span class="line">若反射要调用类的某个私有方法，可以在这个私有方法对应的Mehtod对象上先调用&lt;code&gt;setAccessible(true)&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static void test02() throws InstantiationException, IllegalAccessException, SecurityException,</span><br><span class="line">NoSuchMethodException, IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">Class c1 = TestReflection.class;</span><br><span class="line">TestReflection t1 = (TestReflection) c1.newInstance(); // 利用反射来创建类的对象</span><br><span class="line"></span><br><span class="line">Method method = c1.getDeclaredMethod(&quot;setUserName&quot;, String.class);</span><br><span class="line">method.invoke(t1, &quot;Java反射的学习&quot;);</span><br><span class="line">method = c1.getDeclaredMethod(&quot;setPassWord&quot;, String.class);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line">method.invoke(t1, &quot;反射执行某个Private修饰的方法&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;反射的一些应用&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">既然String是不可变字符串对象，如何才能改变让其可变?[反射的一些应用][1]</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static void stringReflection() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">String s = &quot;Hello World&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;s = &quot; + s); //Hello World</span><br><span class="line"></span><br><span class="line">//获取String类中的value字段</span><br><span class="line">Field valueField = String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line"></span><br><span class="line">//改变value属性的访问权限</span><br><span class="line">valueField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">char[] value = (char[]) valueField.get(s);</span><br><span class="line"></span><br><span class="line">//改变value所引用的数组中的第5个字符</span><br><span class="line">value[5] = &#x27;_&#x27;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;s = &quot; + s); //Hello_World</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">既然String对象中没有对外提供可用的public setters等方法，因此只能通过Java中的反射机制实现。因此，前文中说到的String是不可变字符串对象只是针对“正常情况下”。而非必然。</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  Java的反射机制的概念：</span><br><span class="line">  在Java运行时环境中，对于任意一个类，能否知道这个类的哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java语言的反射（Reflection）机制。</span><br><span class="line">  </span><br><span class="line">  Reflection是Java被视为动态（准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括modifiers（诸如static、public等等）、superclass（例如Object）、实现interfaces（例如Serializable），也包括fields和methods的所有信息，并可于运行时改变fields内容或调用methods。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;标注 Annotation&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">在实际的应用中期可以部分或全部的取代传统的XML等部署描述文件。之所以要出现标注特性，是因为部署描述文件很复杂，在具体编写时很容易出错。</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;标注的简单使用&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@SuppressWarning&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class SimpleAnnotation &#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.runFinalizersOnExit(true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;几个简单的内置标注&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@Override&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.Annotation;</span><br><span class="line"></span><br><span class="line">class People&#123;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;people name&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends People&#123;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;student name&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Annotation_Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Student student = new Student();</span><br><span class="line">System.out.println(student.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  &lt;code&gt;@Override&lt;/code&gt; 是方法标注，只能作用于方法，在覆盖父类方法却又写错了方法名的时候发挥作用。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@Deprecated&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">很多时候，设计了一个包含&lt;code&gt;sayHello()&lt;/code&gt;方法的类&lt;code&gt;Hello.java&lt;/code&gt;，但是经过一段时间发现，&lt;code&gt;sayHello1()&lt;/code&gt;可以更好更快的实现相同的功能。但是这个时候如果去掉方法&lt;code&gt;sayHello()&lt;/code&gt;，那么调用该方法的类就会出现错误。为了兼容之前的类，而又不建议新设计的类使用方法&lt;code&gt;sayHello()&lt;/code&gt;，就需要把&lt;code&gt;Hello.java&lt;/code&gt;中的方法&lt;code&gt;sayHello()&lt;/code&gt;做&lt;code&gt;@Deprecated&lt;/code&gt;标注。</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.Annotation;</span><br><span class="line"></span><br><span class="line">class Hello&#123;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;已经过时的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void sayHello1() &#123;</span><br><span class="line">System.out.println(&quot;现在的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Deprecated_Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Hello hello = new Hello();</span><br><span class="line">hello.sayHello();</span><br><span class="line">hello.sayHello1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">当一个类或者类成员使用&lt;code&gt;@Deprecated&lt;/code&gt;修饰的话，编译器将不鼓励使用这个被标注的程序元素，而且这种修饰具有一定的“延续性”，即在代码中通过继承或者覆盖使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型并不是被声明为&lt;code&gt;@Deprecated&lt;/code&gt;，但是编译器仍要报警。</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  &lt;code&gt;@Deprecated&lt;/code&gt;标注不仅可以用在方法前面，而且可以用在参数或类的前面。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@SuppressWarning&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">可以用作标注类，属性、方法等成员，主要用于屏蔽警告。该标注于前面两个标注最大不同点在于其带有参数，并且参数可以是一个，可以是多个。参数的值为警告的类型。如：</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;已过时的警告 ： deprecation&lt;/li&gt;</span><br><span class="line">&lt;li&gt;没有使用警告 ： unused&lt;/li&gt;</span><br><span class="line">&lt;li&gt;类型不安全警告 ： unchecked&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  当&lt;code&gt;@SuppressWarning&lt;/code&gt; 接收的参数为多个值得时候，必须使用数组的方式为参数赋值。例如@SuppressWarning(&#123;&quot;deprecation&quot;,&quot;unused&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;泛型 &lt;code&gt;&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">所谓泛型，其本质就是实现参数化类型，也就是说所操作的数据类型被指定为一个参数。</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;泛型概念的提出:&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;qqyumidi&quot;);</span><br><span class="line">list.add(&quot;corn&quot;);</span><br><span class="line">list.add(100);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123; String name = (String) list.get(i); // 1 System.out.println(&quot;name:&quot; + name); &#125; &#125; &#125; ``` 运行结果 name:qqyumidi name:corn Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at com.fan.GenericTest.main(GenericTest.java:15) &amp;gt; Java2的集合框架，抽其核心，主要有三种：List、Set和Map。</span><br><span class="line">需要注意的是，这里的 Collection、List、Set和Map都是接口（Interface），不是具体的类实现。 List lst = new ArrayList(); 这是我们平常经常使用的创建一个新的List的语句，在这里， List是接口，ArrayList才是具体的类。</span><br><span class="line">常用集合类的继承结构如下：</span><br><span class="line">Collection&amp;lt;--List&amp;lt;--Vector</span><br><span class="line">Collection&amp;lt;--List&amp;lt;--ArrayList</span><br><span class="line">Collection&amp;lt;--List&amp;lt;--LinkedList</span><br><span class="line">Collection&amp;lt;--Set&amp;lt;--HashSet</span><br><span class="line">Collection&amp;lt;--Set&amp;lt;--HashSet&amp;lt;--LinkedHashSet</span><br><span class="line">Collection&amp;lt;--Set&amp;lt;--SortedSet&amp;lt;--TreeSet</span><br><span class="line">Map&amp;lt;--SortedMap&amp;lt;--TreeMap</span><br><span class="line">Map&amp;lt;--HashMap</span><br><span class="line"></span><br><span class="line">定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。</span><br><span class="line"></span><br><span class="line">在如上的编码过程中，我们发现主要存在两个问题：</span><br><span class="line"></span><br><span class="line">1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。</span><br><span class="line"></span><br><span class="line">2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。</span><br><span class="line"></span><br><span class="line">那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。</span><br><span class="line"></span><br><span class="line">### 什么是泛型？</span><br><span class="line"></span><br><span class="line">泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*</span><br><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;qqyumidi&quot;);</span><br><span class="line">list.add(&quot;corn&quot;);</span><br><span class="line">list.add(100);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">List&lt;string&gt; list = new ArrayList&lt;string&gt;();</span><br><span class="line">list.add(&quot;qqyumidi&quot;);</span><br><span class="line">list.add(&quot;corn&quot;);</span><br><span class="line">//list.add(100); // 1 提示编译错误&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">String name = list.get(i); // 2</span><br><span class="line">System.out.println(&quot;name:&quot; + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义泛型接口、泛型类和泛型方法"><a href="#自定义泛型接口、泛型类和泛型方法" class="headerlink" title="自定义泛型接口、泛型类和泛型方法"></a>自定义泛型接口、泛型类和泛型方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest1 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; num = new Box&lt;integer&gt;(4);</span><br><span class="line">System.out.println(&quot;name:&quot; + name.getData());</span><br><span class="line">System.out.println(&quot;num:&quot; + num.getData());</span><br><span class="line">&#125;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Box&lt;t&gt; &#123;&lt;/t&gt;</span><br><span class="line"></span><br><span class="line">private T data;</span><br><span class="line"></span><br><span class="line">public Box() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Box(T data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>name:corn<br>num:4</p>
<p>在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;name class:&quot; + name.getClass()); // com.qqyumidi.Box</span><br><span class="line">System.out.println(&quot;age class:&quot; + age.getClass()); // com.qqyumidi.Box</span><br><span class="line">System.out.println(name.getClass() == age.getClass()); // true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>name class:class com.fan.Box<br>num class:class com.fan.Box<br>true</p>
<p>由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。</p>
<p>究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
<h3 id="关于泛型通配符"><a href="#关于泛型通配符" class="headerlink" title="关于泛型通配符"></a>关于泛型通配符</h3><p>接着上面的结论，我们知道，Box<Number>和Box<Integer>实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于<code>Box&lt;Number&gt;</code>和<code>Box&lt;Integer&gt;</code>是否可以看成具有父子关系的泛型类型呢？</p>
<blockquote>
<p>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类Number的子类。</p>
</blockquote>
<h3 id="关于泛型的一些特性"><a href="#关于泛型的一些特性" class="headerlink" title="关于泛型的一些特性"></a>关于泛型的一些特性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;number&gt; name = new Box&lt;number&gt;(99);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);&lt;/integer&gt;&lt;/integer&gt;&lt;/number&gt;&lt;/number&gt;</span><br><span class="line"></span><br><span class="line">getData(name);</span><br><span class="line">getData(age); // 1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getData(Box&lt;number&gt; data)&#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;&lt;/number&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过提示信息，我们知道<code>Box&lt;Number&gt;</code>在逻辑上不能视为<code>Box&lt;Integer&gt;</code>的父类.</p>
<p>我们需要一个在逻辑上可以用来表示同时是<code>Box&lt;Integer&gt;</code>和<code>Box&lt;Number&gt;</code>的父类的一个引用类型，由此，类型通配符应运而生。</p>
<p>类型通配符一般是使用 <code>?</code>代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且<code>Box&lt;?&gt;</code>在逻辑上是<code>Box&lt;Integer&gt;</code>、<code>Box&lt;Number&gt;</code>…等所有<code>Box&lt;具体类型实参&gt;</code>的父类。由此，我们依然可以定义泛型方法，来完成此类需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);</span><br><span class="line">Box&lt;number&gt; number = new Box&lt;number&gt;(314);&lt;/number&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">getData(name);</span><br><span class="line">getData(age);</span><br><span class="line">getData(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getData(Box&lt;?&gt; data) &#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？</p>
<p>在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);</span><br><span class="line">Box&lt;number&gt; number = new Box&lt;number&gt;(314);&lt;/number&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">getData(name);</span><br><span class="line">getData(age);</span><br><span class="line">getData(number);</span><br><span class="line"></span><br><span class="line">//getUpperNumberData(name); // 1</span><br><span class="line">getUpperNumberData(age); // 2</span><br><span class="line">getUpperNumberData(number); // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getData(Box&lt;?&gt; data) &#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getUpperNumberData(Box&lt;? extends Number&gt; data)&#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，显然，在代码&#x2F;&#x2F;1处调用将出现错误提示，而&#x2F;&#x2F;2 &#x2F;&#x2F;3处调用正常。</p>
<p>类型通配符上限通过形如Box&lt;? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt;? super Number&gt;形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>程序是计算机指令集合，它以文件形式存储在磁盘上</p>
<p>进程就是一个执行中的程序，每一个进程都有一个独立的内存空间和资源系统。</p>
<p>线程是CPU调度和分配的基本单位，一个进程可以由多个线程组成，而这多个线程共享同一个存储空间，这使得线程间的通信比较容易。</p>
<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>创建线程的方法有两种 ：</p>
<ul>
<li>通过实现<code>Runnable</code>接口的方式创建线程</li>
<li>通过集成<code>Threa</code>类来创建线程</li>
</ul>
<h4 id="通过实现Runnable接口的方式创建线程"><a href="#通过实现Runnable接口的方式创建线程" class="headerlink" title="通过实现Runnable接口的方式创建线程"></a>通过实现<code>Runnable</code>接口的方式创建线程</h4><p>在java中，线程是一种对象，而不是所有的对象都可以被称为线程，只有实现了<code>Runnable</code>接口的对象才可以被称为线程。</p>
<p><code>Runnable</code>接口的定义：</p>
<p>public interface new Runnable() {<br>public abstract void run() ;<br>}</p>
<p>只有实现了该接口的类才有资格被称为线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.threadtest;</span><br><span class="line"></span><br><span class="line">class ThreadTest implements Runnable &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest2 implements Runnable&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadTest1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ThreadTest test = new ThreadTest();</span><br><span class="line">ThreadTest2 test2 = new ThreadTest2();</span><br><span class="line">Thread thread = new Thread(test);</span><br><span class="line">Thread thread2 = new Thread(test2);</span><br><span class="line">thread.start();</span><br><span class="line">thread2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java技术中，线程通常是通过调度模块来执行的。所谓抢占式调度模式是指：许多线程处于可以运行状态，即等待状态，但实际只有一个线程在运行。该线程一直运行直到他终止或是另一个优先级更高的线程变成可运行状态。</p>
<h4 id="通过继承Thread类的方式创建线程"><a href="#通过继承Thread类的方式创建线程" class="headerlink" title="通过继承Thread类的方式创建线程"></a>通过继承<code>Thread</code>类的方式创建线程</h4><p>其实<code>Thread</code>本身也实现了<code>Runnable</code>接口，所以只要让一个类继承<code>Thread</code>类，并覆盖<code>run()</code>方法，也会创建进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.threadtest;</span><br><span class="line"></span><br><span class="line">class Threadtest_3 extends Thread &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 1&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest_4 extends Thread&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Threadtest_3 threadtest_3 =new Threadtest_3();</span><br><span class="line">ThreadTest_4 threadTest_4 = new ThreadTest_4();</span><br><span class="line"></span><br><span class="line">Thread thread3 = new Thread(threadtest_3);</span><br><span class="line">Thread thread4 = new Thread(threadTest_4);</span><br><span class="line"></span><br><span class="line">thread3.start();</span><br><span class="line">thread4.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程包括5种状态：新建状态、就绪状态、运行状态、阻塞状态和死亡状态。</p>
<p>新建状态</p>
<p>线程对象通过<code>new</code>关键字已经建立，在内存中有一个活跃的对象，但是没有启动该线程，所以它仍不能做任何事情，此时线程处于新建状态，程序中没有运行线程中的代码，如果线程要运行需要处于就绪状态。</p>
<p>就绪状态</p>
<p>一个线程一旦调用了<code>start()</code>方法，该线程就处于就绪状态。此时线程等待CPU时间片，一旦获得CPU时间周期，一旦获得CPU周期，线程就可以执行。这种状态下的任何时刻，线程是否执行完全取决于系统的调度程序。</p>
<p>运行状态</p>
<p>一旦处于就绪状态的线程获得CPU执行周期，就处于运行状态，执行多线程代码部分的运算。线程一旦运行，只是在CPU周期内获得执行权利，而一旦CPU的时间片用完，操作系统会给其他的线程运行的机会，而剥夺当前线程的执行。在选择哪个线程可以执行时，操作系统的调度程序会考虑现成的优先级，该内容后续讲解。</p>
<p>阻塞状态</p>
<p>该状态下线程无法运行，必须满足一定条件条件后才可以执行。如果线程处于阻塞状态，JVM调度机不会为其分配CPU周期。而线程满足一定条件就被解除阻塞，线程处于就绪状态，此时就获得了被执行的机会。当发生以下情况的时候线程会进入阻塞状态：</p>
<ul>
<li>线程正在等待一个输入输出操作，该操作完成前不会返回其调用者。</li>
<li>线程调用了<code>wait()</code>方法或是<code>sleep()</code>方法。</li>
<li>线程需要满足某种条件之后可以继续执行。</li>
</ul>
<p>死亡状态</p>
<p>线程一旦退出<code>run()</code>方法就处于死亡状态。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>线程的执行顺序是一种抢占方式，优先级高的比优先级低的要获得更多的执行时间，如果想让一个线程比其他线程有更多的运行时间，可以通过设置线程的优先级解决。</p>
<p>具体方法如下：</p>
<p>public final void setPriority(int newPriority);</p>
<p>其中，<code>newPriority</code>是一个1~10的正整数，数值越大，优先级别越高。系统定义了一些常用的数值如下：</p>
<ul>
<li>public final static int MIN_PRIORITY &#x3D; 1 ：表示最低优先级</li>
<li>public final static int MAX_PRIORITY &#x3D; 10 ：表示最高优先级</li>
<li>public final static int NORM_PRIORITY &#x3D; 5 ：表示默认优先级</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.threadtest;</span><br><span class="line"></span><br><span class="line">import org.omg.CORBA.PUBLIC_MEMBER;</span><br><span class="line"></span><br><span class="line">class Threadtest_3 extends Thread &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest_4 extends Thread&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">System.out.println(&quot;hello&quot;+ i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Threadtest_3 threadtest_3 =new Threadtest_3();</span><br><span class="line">ThreadTest_4 threadTest_4 = new ThreadTest_4();</span><br><span class="line"></span><br><span class="line">Thread thread3 = new Thread(threadtest_3);</span><br><span class="line">Thread thread4 = new Thread(threadTest_4);</span><br><span class="line"></span><br><span class="line">thread3.setPriority(3);</span><br><span class="line">thread4.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">thread3.start();</span><br><span class="line">thread4.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的休眠与唤醒"><a href="#线程的休眠与唤醒" class="headerlink" title="线程的休眠与唤醒"></a>线程的休眠与唤醒</h3><p>线程的休眠 <code>sleep()</code></p>
<p>线程处于等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">///这是一个主运行类</span><br><span class="line">///创建一个线程对象，让其运行</span><br><span class="line">public class thread5</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute27 t=new compute27();</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类，在这个类中，通过休眠来输出不同结果</span><br><span class="line">class compute27 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;在工作中，不要打扰&quot;);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">sleep(1000000);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;哦，电话来了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程唤醒 <code>interrup()</code></p>
<p>当一个线程处于休眠状态，如果开始设置了休眠时间是1000ms，但是想在休眠了500ms的时候，让它继续执行，这时候就可以使用线程唤醒功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">public class thread6</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute28 t=new compute28();</span><br><span class="line">t.start();</span><br><span class="line">t.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类，在这个类中，通过休眠，让线程运行输出不同的结果</span><br><span class="line">class compute28 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;在工作中，不要打扰&quot;);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">sleep(1000000);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;哦，电话来了&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程让步-yield"><a href="#线程让步-yield" class="headerlink" title="线程让步 yield()"></a>线程让步 <code>yield()</code></h3><p>所谓线程让步，就是使当前正在运行的线程对象退出运行状态，让其他线程运行。</p>
<p>这个方法不能讲运行权让给指定的线程，只是允许这个线程把运行权让出来，至于给谁，就看谁能抢到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">///这是一个主运行类</span><br><span class="line">///在主运行方法中，通过创建两个线程对象，让其交替执行</span><br><span class="line">public class thread7</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute29 t=new compute29();</span><br><span class="line">compute30 t1=new compute30();</span><br><span class="line">t.start();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///通过循环语句来输出十个整型数据</span><br><span class="line">///通过让步程序让此线程停止运行</span><br><span class="line">class compute29 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///通过循环语句来输出说明语句</span><br><span class="line">class compute30 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;这个数字是:&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">//这是一个主运行类</span><br><span class="line">///在主运行方法中，通过创建两个线程对象，让其交替执行</span><br><span class="line">public class thread8</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute31 t=new compute31(&#x27;a&#x27;);</span><br><span class="line">compute31 t1=new compute31(&#x27;b&#x27;);</span><br><span class="line">t.start();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///在这线程类中，使用循环语句输出字符</span><br><span class="line">class compute31 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">compute31(char ch)</span><br><span class="line">&#123;</span><br><span class="line">this.ch=ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程循环输出，就会出现抢占现象。解决这个问题的办法是可以使用线程同步，解决同步的两个方法：</p>
<ul>
<li>同步块</li>
<li>同步化方法</li>
</ul>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><p>同步块是使具有某个对象监视点的线程，获得运行权限的一种方法，每个对象只能在拥有这个监视点的情况下，才能获得运行权限。</p>
<p>同步块的结构如下：</p>
<p>synchronized (bObject) {<br>程序段<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">//这是一个主运行类</span><br><span class="line">///在主运行方法中，通过创建两个线程对象，让其交替执行</span><br><span class="line">public class thread8</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute31 t=new compute31(&#x27;a&#x27;);</span><br><span class="line">compute31 t1=new compute31(&#x27;b&#x27;);</span><br><span class="line">t.start();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///在这线程类中，使用循环语句输出字符</span><br><span class="line">class compute31 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">static Object bObject = new Object();</span><br><span class="line">compute31(char ch)</span><br><span class="line">&#123;</span><br><span class="line">this.ch=ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">synchronized (bObject) &#123;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;10;i++) &#123; System.out.print(ch); &#125; &#125; &#125; &#125; ``` ### 同步化方法 同步化方法就是对整个方法进行同步： 结构如下： synchronized void f() &#123; 代码 &#125; ```java //这是一个主运行类 ///在主运行方法中，通过创建三个线程对象，让其交替执行 public class thread11 &#123; public static void main(String[] args) &#123; compute34 t=new compute34(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); &#125; &#125; ///创建一个线程类 ///在这线程类中，使用循环语句输出字符 ///在run方法中，使用同步块来给线程加一把锁 class compute34 extends Thread &#123; int i=10; static Object obj=new Object(); public void print() &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); i--; &#125; public void run() &#123; while(i&amp;gt;0) &#123; synchronized(obj) &#123; print(); &#125; try &#123; sleep(1000); &#125; catch(Exception e)&#123;&#125; &#125; &#125; &#125; ``` ## 异常的处理和内存管理 ## Java 输入和输出 Java程序类库中包含大量的输入输出类，提供不同情况的不同功能。其中包括： - 关于文件操作的类 `File` - 关于以字节方式访问文件的类 `InputStream`和类`OutStream` - 关于以字符方式访问文件的类`Reader`和类`Writer` &amp;gt; 在编写程序的过程中，若是要使用输入输出类的方法和属性值，就需要引入`java.io`类</span><br><span class="line"></span><br><span class="line">## Java 的I/O操作</span><br><span class="line"></span><br><span class="line">Java中I/O操作主要是指使用Java进行输入，输出操作.</span><br><span class="line"></span><br><span class="line">Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。Java的I/O流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供以数据流的方式读写它的数据的方法。</span><br><span class="line"></span><br><span class="line">总结的基本概念如下：</span><br><span class="line"></span><br><span class="line">数据流：</span><br><span class="line"></span><br><span class="line">一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。</span><br><span class="line"></span><br><span class="line">输入流：</span><br><span class="line"></span><br><span class="line">程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</span><br><span class="line"></span><br><span class="line">输出流：</span><br><span class="line"></span><br><span class="line">程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</span><br><span class="line"></span><br><span class="line">采用数据流的目的就是使得输出输入独立于设备。</span><br><span class="line"></span><br><span class="line">数据流分类：</span><br><span class="line"></span><br><span class="line">流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</span><br><span class="line">1) 字节流：数据流中最小的数据单元是字节</span><br><span class="line">2) 字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</span><br><span class="line"></span><br><span class="line">### 标准I/O</span><br><span class="line"></span><br><span class="line">### java.IO层次体系结构</span><br><span class="line"></span><br><span class="line">在整个Java.io包中最重要的就是5个类和一个接口。</span><br><span class="line"></span><br><span class="line">5个类指的是`File`、`OutputStream`、`InputStream`、`Writer`、`Reader`；</span><br><span class="line"></span><br><span class="line">1个接口指的是`Serializable`.</span><br><span class="line"></span><br><span class="line">掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了。</span><br><span class="line"></span><br><span class="line">主要的类如下：</span><br><span class="line"></span><br><span class="line">File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</span><br><span class="line">InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</span><br><span class="line">OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</span><br><span class="line"></span><br><span class="line">Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。</span><br><span class="line"></span><br><span class="line">Reader（文件格式操作）：抽象类，基于字符的输入操作。</span><br><span class="line">Writer（文件格式操作）：抽象类，基于字符的输出操作。</span><br><span class="line">RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</span><br><span class="line"></span><br><span class="line">### 文件或目录信息的处理 `File`</span><br><span class="line"></span><br><span class="line">`File` 类提供了与文件或目录相关的信息</span><br><span class="line"></span><br><span class="line">文件处理方法：</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">package com.filetest;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">public class FileTest1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">File file = new File(&quot;d:\\&quot;,&quot;file.txt&quot;);</span><br><span class="line">System.out.println(file.getName());</span><br><span class="line">System.out.println(file.getParent());</span><br><span class="line">System.out.println(file.getPath());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>file.txt<br>d:<br>d:\file.txt</p>
<p>文件和目录的操作：</p>
<p>在Java中，目录被当做一种特殊的文件使用。类<code>File</code>是唯一代表磁盘文件对象的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.chaozuo;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">///通过print方法来判断这个文件类对象的性质</span><br><span class="line">///通过print1方法来获取文件对象的信息</span><br><span class="line">///通过print2方法来获取文件对象的信息</span><br><span class="line">public class file1 &#123;</span><br><span class="line">public void print(File f) &#123;</span><br><span class="line">//通过print方法来判断这个文件类对象的性质</span><br><span class="line">if (f.isDirectory()) &#123;</span><br><span class="line">//判断f对象是否为目录</span><br><span class="line">System.out.println(&quot;这是一个目录！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;这不是一个目录！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (f.exists()) &#123;</span><br><span class="line">//判断f对象是否存在</span><br><span class="line">System.out.println(&quot;这个文件存在的！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;抱歉，这个文件不存在的！&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">f.createNewFile();</span><br><span class="line">//当文件不存在时，创建一个文件</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void print1(File f) &#123;</span><br><span class="line">//通过print1方法来获取文件目录对象的信息</span><br><span class="line">System.out.println(f.getName());</span><br><span class="line">System.out.println(f.getParent());</span><br><span class="line">System.out.println(f.getPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void print2(File f) &#123;</span><br><span class="line">//通过print2方法来获取文件对象的信息</span><br><span class="line">if (f.isFile()) &#123;</span><br><span class="line">System.out.println(f.lastModified());</span><br><span class="line">System.out.println(f.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">file1 f1 = new file1(); //创建一个f1对象</span><br><span class="line">File f = new File(&quot;d:\\filetest&quot;);</span><br><span class="line">//调用相应的方法</span><br><span class="line">f1.print(f);</span><br><span class="line">f1.print1(f);</span><br><span class="line">f1.print2(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>这不是一个目录！<br>抱歉，这个文件不存在的！<br>filetest<br>d:<br>d:\filetest<br>1452923459623<br>0</p>
<h3 id="使用文件字节输入流读取文件-FileInputStream"><a href="#使用文件字节输入流读取文件-FileInputStream" class="headerlink" title="使用文件字节输入流读取文件 FileInputStream"></a>使用文件字节输入流读取文件 <code>FileInputStream</code></h3><p><code>FileInputStream</code>类是是<code>InputStream</code>的子类，并且不是抽象类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">///创建一个文件类f</span><br><span class="line">///创建一个输入流对象fis，并且以f作为参数</span><br><span class="line">///使用循环语句将文本文件中的字符读出</span><br><span class="line">public class file3 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File f = new File(&quot;d:\\filetest\\file.txt&quot;);</span><br><span class="line">//创建一个文件类f</span><br><span class="line">FileInputStream fis = new FileInputStream(f);</span><br><span class="line">//创建对象f的文件输入流</span><br><span class="line">char ch;</span><br><span class="line">//声明一个字符串对象ch</span><br><span class="line">for (int i = 0; i &lt; f.length(); i++) &#123;</span><br><span class="line">//通过循环读取文件类f所对应的文件</span><br><span class="line">ch = (char) fis.read();</span><br><span class="line">System.out.print(ch);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用文件字节输出流输出文件-FileOutputStream"><a href="#使用文件字节输出流输出文件-FileOutputStream" class="headerlink" title="使用文件字节输出流输出文件 FileOutputStream"></a>使用文件字节输出流输出文件 <code>FileOutputStream</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">///创建一个文件类f</span><br><span class="line">///创建一个输入流对象fis，并且以f作为参数</span><br><span class="line">///将所有的字节都保存到一个字节数组b中。</span><br><span class="line">///使用循环语句将b中的字符读出</span><br><span class="line">public class file4 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File f = new File(&quot;d:\\filetest\\file.txt&quot;);</span><br><span class="line">//创建一个文件类f</span><br><span class="line">FileInputStream fis = new FileInputStream(f);</span><br><span class="line">//创建一个输入流对象fis，并且以f作为参数</span><br><span class="line">byte[] b = new byte[(int) f.length()];</span><br><span class="line">//创建一个字节数组对象b</span><br><span class="line">fis.read(b);</span><br><span class="line">//读取到的内容存储到字节数组对象b</span><br><span class="line">for (int i = 0; i &lt; f.length(); i++) &#123;</span><br><span class="line">//通过循环输出相应内容</span><br><span class="line">System.out.print((char) b[i]);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java中对数据的处理"><a href="#Java中对数据的处理" class="headerlink" title="Java中对数据的处理"></a>Java中对数据的处理</h2><h3 id="基本数据类型和对象数据类型的转换"><a href="#基本数据类型和对象数据类型的转换" class="headerlink" title="基本数据类型和对象数据类型的转换"></a>基本数据类型和对象数据类型的转换</h3><p>为什么要将基本类型转换成对象数据类型：</p>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(<code>Wrapper Class</code>)</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>由于所有的包装类具有比较相似的成员，这里以<code>Integer</code>类为例：</p>
<p><code>Integer</code>类的构造方法：</p>
<p>public integer(int value):将整型值value包装成持有此值的<code>Integer</code>类对象。<br>public integer(string s)：将由数字字符组成的串s包装成持有此值的<code>Integer</code>类对象，若s不是数字构成的话，则会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class file1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int x = 12; //创建一个整形类型变量x</span><br><span class="line">String str = &quot;13579&quot;; //创建一个字符串类型变量str</span><br><span class="line">//把变量x，str转换成对象类型t1和t2</span><br><span class="line">Integer t1 = new Integer(x);</span><br><span class="line">Integer t2 = new Integer(str);</span><br><span class="line">//通过tostring()把对象转换成字符串。</span><br><span class="line">System.out.println(t1);</span><br><span class="line">System.out.println(t2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何处理随机性数据-Random"><a href="#如何处理随机性数据-Random" class="headerlink" title="如何处理随机性数据 Random"></a>如何处理随机性数据 <code>Random</code></h3><h3 id="如何对数据进行排列、整理-Arrays"><a href="#如何对数据进行排列、整理-Arrays" class="headerlink" title="如何对数据进行排列、整理 Arrays"></a>如何对数据进行排列、整理 <code>Arrays</code></h3><h2 id="数据结构接口"><a href="#数据结构接口" class="headerlink" title="数据结构接口"></a>数据结构接口</h2><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><code>Collection</code>接口</h3><p><code>Collection</code>接口是数据集合接口，它位于数据结构API的最上部，构成<code>Collection</code>的单位被称为元素。可将<code>Collection</code>接口分为三个部分，分别是<code>Map</code>接口、<code>Set</code>接口和<code>List</code>接口。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy Me A Coffee / 请喝一杯咖啡吧</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="时空 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="时空 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"># 编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/03/08/python%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" rel="prev" title="Python基础入门">
                  <i class="fa fa-chevron-left"></i> Python基础入门
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/03/08/qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="Qt学习笔记">
                  Qt学习笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2012 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">时空</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"stx8","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>

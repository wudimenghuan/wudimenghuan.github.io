<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.stx8.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"vs2015","dark":"vs2015"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="时空主站">
<meta property="og:type" content="website">
<meta property="og:title" content="时空主站">
<meta property="og:url" content="http://www.stx8.com/page/3/index.html">
<meta property="og:site_name" content="时空主站">
<meta property="og:description" content="时空主站">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="时空">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.stx8.com/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>时空主站</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90761248-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-90761248-1","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">时空主站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">嗨，我是时空，一名来自中国的开发者。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-我的软件"><a href="/tags/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6/" rel="section"><i class="fa fa-desktop fa-fw"></i>我的软件</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-开源博客"><a href="https://my.oschina.net/wudimenghuan" rel="section" target="_blank"><i class="fa fa-code fa-fw"></i>开源博客</a></li><li class="menu-item menu-item-pgp"><a href="/pgp/" rel="section"><i class="fa fa-key fa-fw"></i>PGP</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">时空</p>
  <div class="site-description" itemprop="description">时空主站</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">88</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/03/08/java-%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/08/java-%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Java 笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-08 21:21:27" itemprop="dateCreated datePublished" datetime="2018-03-08T21:21:27+08:00">2018-03-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/03/08/java-%E7%AC%94%E8%AE%B0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/08/java-笔记/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-笔记"><a href="#Java-笔记" class="headerlink" title="Java 笔记"></a>Java 笔记</h1><h2 id="数据类型和运算符"><a href="#数据类型和运算符" class="headerlink" title="数据类型和运算符"></a>数据类型和运算符</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>bool</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="普通常量"><a href="#普通常量" class="headerlink" title="普通常量"></a>普通常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">final int A = 20;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test1 test1 = new Test1();</span><br><span class="line">System.out.println(test1.A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类常量"><a href="#类常量" class="headerlink" title="类常量"></a>类常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">static final int B = 20;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(B);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量一般都定义为大写字母</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 30;</span><br><span class="line">System.out.println(a++);</span><br><span class="line">System.out.println(++a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>30<br>32</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>binarySearch()</code>, 使用二分搜索法来搜索指定数组，以获得指定对象。</p>
<p>在进行此调用之前，必须根据元素的自然顺序对数组进行升序排序（通过 sort() 方法）</p>
<p>参数：</p>
<ul>
<li>a - 要搜索的数组</li>
<li>key - 要搜索的值</li>
</ul>
<p>返回：</p>
<ul>
<li>如果它包含在数组中，则返回搜索键的索引；</li>
<li>否则返回 (-(插入点) - 1) 。</li>
<li>插入点被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为<code>a.length</code>。</li>
<li>注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SearchArray</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">int[] array = &#123;2, 4, 6, 1, 3, 5, 9, 11, -5, 30, 100&#125;;</span><br><span class="line">Arrays.sort(array);</span><br><span class="line">int index = Arrays.binarySearch(array, 11);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line">System.out.println(&quot;The index of 11 is &quot;+index);</span><br><span class="line">index = Arrays.binarySearch(array, 10);</span><br><span class="line">System.out.println(&quot;The index of 10 is &quot;+index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>[-5, 1, 2, 3, 4, 5, 6, 9, 11, 30, 100]<br>The index of 11 is 8<br>The index of 10 is -9</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ol>
<li>串连接：<code>+</code>，<code>concat()</code></li>
<li>提取子字符串：<code>substring()</code></li>
<li>提取字符：<code>charAt()</code></li>
<li>获取字符串长度：<code>length</code></li>
<li>判断字符串是否相等：<code>equal()</code></li>
</ol>
<p>有的登陆系统密码忽略大小写。此时java语言中有个方法就是equalsIgnoreCase(String str)，这个方法忽略字符串大小写。</p>
<h3 id="常见疑难-equals-和-的区别"><a href="#常见疑难-equals-和-的区别" class="headerlink" title="常见疑难: equals 和 == 的区别"></a>常见疑难: equals 和 == 的区别</h3><p>java中的数据类型，可分为两类：</p>
<ol>
<li>基本数据类型，也称原始数据类型。</li>
</ol>
<p>byte,short,char,int,long,float,double,boolean</p>
<p>他们之间的比较，应用双等号（==）,比较的是他们的值。</p>
<ol>
<li>复合数据类型(类)</li>
</ol>
<p>当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。</p>
<p>对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。</p>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ol>
<li>追加：<code>append()</code></li>
<li>指定位置插入字符串：<code>insert()</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StringBufferTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">StringBuffer strbuf1 = new StringBuffer();</span><br><span class="line">System.out.println(strbuf1.capacity());</span><br><span class="line">System.out.println(strbuf1.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>16<br>0</p>
<h3 id="常见疑难-：String-和-StringBufffer-的区别"><a href="#常见疑难-：String-和-StringBufffer-的区别" class="headerlink" title="常见疑难 ：String 和 StringBufffer 的区别"></a>常见疑难 ：String 和 StringBufffer 的区别</h3><p>StringBuffer对象的内容可以修改；String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。</p>
<p>StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。</p>
<h4 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h4><p>在String类中没有用来改变已有字符串中的某个字符的方法，由于不能改变一个java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的。然而，不可改变的字符串具有一个很大的优点:编译器可以把字符串设为共享的。</p>
<h4 id="StringBuffer-1"><a href="#StringBuffer-1" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>StringBuffer类属于一种辅助类，可预先分配指定长度的内存块建立一个字符串缓冲区。这样使用StringBuffer类的append方法追加字符 比 String使用 + 操作符添加字符 到 一个已经存在的字符串后面有效率得多。因为使用 + 操作符每一次将字符添加到一个字符串中去时，字符串对象都需要寻找一个新的内存空间来容纳更大的字符串，这无凝是一个非常消耗时间的操作。添加多个字符也就意味着要一次又一次的对字符串重新分配内存。使用StringBuffer类就避免了这个问题。<br>StringBuffer是线程安全的，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="访问控制符：public-private-protected-default"><a href="#访问控制符：public-private-protected-default" class="headerlink" title="访问控制符：public ,private ,protected, default"></a>访问控制符：public ,private ,protected, default</h4><table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中可见</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>同一包中对子类可见</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>同一包中对非子类可见</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不同包中对子类可见</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不同包中对非子类可见</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="基础类-：Math，Date"><a href="#基础类-：Math，Date" class="headerlink" title="基础类 ：Math，Date"></a>基础类 ：Math，Date</h4><h2 id="重载和包"><a href="#重载和包" class="headerlink" title="重载和包"></a>重载和包</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载的实质</p>
<ul>
<li>方法名相同</li>
<li>参数个数可以不同</li>
<li>参数类型可以不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class overload &#123;</span><br><span class="line">// /一个普通的方法，不带参数</span><br><span class="line">void test() &#123;</span><br><span class="line">System.out.println(&quot;No parameters&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /重载上面的方法，并且带了一个整型参数</span><br><span class="line">void test(int a) &#123;</span><br><span class="line">System.out.println(&quot;a: &quot; + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /重载上面的方法，并且带了两个参数</span><br><span class="line">void test(int a, int b) &#123;</span><br><span class="line">System.out.println(&quot;a and b: &quot; + a + &quot; &quot; + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /重载上面的方法，并且带了一个双精度参数，与上面带一个参数的重载方法不一样</span><br><span class="line">double test(double a) &#123;</span><br><span class="line">System.out.println(&quot;double a: &quot; + a);</span><br><span class="line">return a * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">overload o = new overload(); //创建了对象o</span><br><span class="line">o.test();</span><br><span class="line">o.test(2);</span><br><span class="line">o.test(2, 3);</span><br><span class="line">o.test(2.0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>No parameters<br>a: 2<br>a and b: 2 3<br>double a: 2.0</p>
<h3 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h3><p><code>import com.stx8.test</code>，相当于C#里的<code>using</code>语句，C++里的头文件及namespace</p>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>extends</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">int a;</span><br><span class="line"></span><br><span class="line">People() &#123;</span><br><span class="line">a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People(int a) &#123;</span><br><span class="line">this.a = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class men extends People &#123;</span><br><span class="line">int b;</span><br><span class="line"></span><br><span class="line">men(int a, int b) &#123;</span><br><span class="line">super(a);</span><br><span class="line">this.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">men m = new men(10, 20); //通过带参构造函数创建men类对象</span><br><span class="line">System.out.println(m.a + &quot; &quot; + m.b); //调用对象的成员变量a和b</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设计类的继承时的建议"><a href="#设计类的继承时的建议" class="headerlink" title="设计类的继承时的建议"></a>设计类的继承时的建议</h4><p>不要使用受保护字段，即<code>protected</code>字段</p>
<p>如果不希望自己的类再被扩展，可以在类的声明之前加上<code>final</code>关键字。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>构造函数名字与类名相同(包括大小写)</li>
<li>一个类可以有多个构造函数</li>
<li>构造函数没有返回值，也不用写<code>void</code>关键字</li>
<li>构造函数总和new运算符一起被调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Test3_super&#123;</span><br><span class="line">public Test3_super() &#123;</span><br><span class="line">// TODO 自动生成的构造函数存根</span><br><span class="line">System.out.println(&quot;父类构造函数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void fun1()&#123;</span><br><span class="line">System.out.println(&quot;父类F1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">protected void fun2() &#123;</span><br><span class="line">System.out.println(&quot;父类F2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">private void fun3() &#123;</span><br><span class="line">System.out.println(&quot;父类F3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test3 extends Test3_super&#123;</span><br><span class="line"></span><br><span class="line">Test3()&#123;</span><br><span class="line">super();</span><br><span class="line">System.out.println(&quot;子类构造函数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void fun2() &#123;</span><br><span class="line">System.out.println(&quot;子类F2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Test3 test3 = new Test3();</span><br><span class="line">test3.fun1();</span><br><span class="line">test3.fun2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>父类构造函数<br>子类构造函数<br>父类F1<br>子类F2</p>
<h4 id="java-的单继承性"><a href="#java-的单继承性" class="headerlink" title="java 的单继承性"></a>java 的单继承性</h4><p>针对同一方法，子类的访问控制权限只能等于或大于父类。</p>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态一定要遵守两个规则：</p>
<ul>
<li>方法名称一定要一样</li>
<li>传入参数的类型一定要不一样</li>
</ul>
<p>多态的两种表现形势</p>
<ul>
<li>重载</li>
<li>覆盖</li>
</ul>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 <code>interface</code></h2><p>接口中只有方法名，没有具体实现的方法体。</p>
<p>接口的声明默认是 <code>public</code>，有时候也可以省略。</p>
<p>类实现接口是要使用 <code>implements</code>关键字</p>
<p>在类实现接口时要注意：</p>
<ul>
<li>声明类需要实现指定接口</li>
<li>提供接口中所有方法的定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.interfacetest;</span><br><span class="line"></span><br><span class="line">interface Alarm &#123;</span><br><span class="line">void alarm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AlarmDoor implements Alarm &#123;</span><br><span class="line"></span><br><span class="line">void open() &#123;</span><br><span class="line">System.out.println(&quot;door open&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void close() &#123;</span><br><span class="line">System.out.println(&quot;door close&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void alarm() &#123;</span><br><span class="line">System.out.println(&quot;a door with alarm&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">AlarmDoor alarmDoor = new AlarmDoor();</span><br><span class="line">alarmDoor.alarm();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的多重实现"><a href="#接口的多重实现" class="headerlink" title="接口的多重实现"></a>接口的多重实现</h3><p>为解决java类中的单继承，一个类可以实现一个接口，也可以实现其他接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.interfacetest;</span><br><span class="line"></span><br><span class="line">interface Alarm &#123;</span><br><span class="line">void alarm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Window &#123;</span><br><span class="line">void window();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AlarmDoor implements Alarm, Window &#123;</span><br><span class="line"></span><br><span class="line">public void window() &#123;</span><br><span class="line">System.out.println(&quot;a door with window&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void alarm() &#123;</span><br><span class="line">System.out.println(&quot;a door with alarm&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceTest2 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">AlarmDoor alarmDoor = new AlarmDoor();</span><br><span class="line">alarmDoor.alarm();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h3><p>接口不是一个类，不可以使用关键字<code>new</code>来生成一个接口的实例。但是可以声明一个接口变量 “school sc”.</p>
<p>如果要生成一个接口的实例，可以让接口变量指向一个已经实现该接口的类的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">school sc = new student();</span><br></pre></td></tr></table></figure>

<p>在接口中，不能声明实例字段及静态方法，但可以声明常量。接口不一定要有方法，可以全是常量。</p>
<h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>和类一样，使用<code>extends</code>关键字实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.interfacetest;</span><br><span class="line"></span><br><span class="line">interface Lock &#123;</span><br><span class="line">void lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface HighLock extends Lock&#123;</span><br><span class="line">void hignlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Door implements HighLock &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void hignlock() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">System.out.println(&quot;WOW high lock&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void lock() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">System.out.println(&quot;just lock&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceTest3 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Door door = new Door();</span><br><span class="line">door.lock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类就是在类的内部再创建一个类。</p>
<h3 id="内部类的基本结构"><a href="#内部类的基本结构" class="headerlink" title="内部类的基本结构"></a>内部类的基本结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.interclass;</span><br><span class="line"></span><br><span class="line">//外部类</span><br><span class="line">class Out &#123;</span><br><span class="line">private int age = 12;</span><br><span class="line"></span><br><span class="line">//内部类</span><br><span class="line">class In &#123;</span><br><span class="line">public void print() &#123;</span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterclassTest1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Out.In in = new Out().new In();</span><br><span class="line">in.print();</span><br><span class="line"></span><br><span class="line">Out out = new Out();</span><br><span class="line">Out.In in2 = out.new In();</span><br><span class="line">in2.print();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类也就是没有名字的内部类，正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</p>
<p>不使用匿名内部类来实现抽象方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.interclass;</span><br><span class="line"></span><br><span class="line">abstract class Person &#123;</span><br><span class="line">public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Person &#123;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;eat something&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterclassTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person p = new Child();</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>eat something</p>
<p>可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用，但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p>
<p>这个时候就引入了匿名内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.interclass;</span><br><span class="line"></span><br><span class="line">abstract class Person1 &#123;</span><br><span class="line">public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterclassTest3 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person p = new Person() &#123;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;eat something&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>eat something</p>
<p>由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p>
<p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承<code>Thread</code>类或是继承<code>Runnable</code>接口</p>
<p><code>Thread</code>类的匿名内部类实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Thread t = new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">System.out.print(i + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Runnable</code>接口的匿名内部类实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Runnable r = new Runnable() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt;= 5; i++) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; &#125;; Thread t = new Thread(r); t.start(); &#125; &#125; ``` 内部类的好处： - 内部类的对象能够访问创建他的对象的所有方法和属性，包括私有数据 - 对于同一个包中的其他类来说，内部类是隐形的 。 - 匿名内部类可以很方便的定义回调 - 使用内部类可以方便的编写时间驱动的程序。 作为一个单独的类，只能有 `default` 和 `public` 两种访问控制符，但是作为内部类，可以使用 `private` 控制符。当内部类设置为 `private` 时，包含此内部类的外部类的方法才可以访问它。 ### 使用内部类来访问对象 内部类这个机制之所以出现，是因为存在如下两个目的： - 可以让程序中逻辑上相关的类结合在一起 - 内部类可以直接访问外部类的成员。 ## 常见疑难 接口与继承的区别： - 属性：接口中的所有属性都是公开静态常量，继承则无所谓 - 方法：接口中所有方法都是公开抽象方法，继承中所有方法不一定是抽象的 - 接口方法：接口没有构造器，继承有构造器 ## 抽象和封装 抽象就是讲拥有共同方法和属性的对象提取出来，提取后，重新设计一个更加通用、更加大众的类，这个类成为抽象类。 ### 抽象类 `abstract` 具有一个或多个抽象方法的类，本身就要被定义为抽象类。含有抽象方法的类一定是抽象类。 抽象类不仅可以有抽象方法，也可以又具体的方法，一个类中只要有一个抽象方法，就是抽象类。 抽象类中不一定含有抽象的方法，也可以全部都是具体的方法。 抽象类是可以继承的，如果子类没有实现抽象类的全部抽象方法，那么子类也是抽象类。如果实现了抽象类的全部抽象方法，那么子类就不是抽象类。 抽象类不可以被实例化。但是可以声明一个抽象类的变量指向具体子类的对象。 抽象类的好处在于，有的方法在父类中不想实现时，可以不用实现。 ```java package com.abstracttest; abstract class Door&#123; abstract void open(); abstract void close(); &#125; class MyDoor extends Door&#123; @Override void open() &#123; // TODO 自动生成的方法存根 System.out.println(&quot;i can open&quot;); &#125; @Override void close() &#123; // TODO 自动生成的方法存根 System.out.println(&quot;i can close&quot;); &#125; &#125; public class AbstractTest1 &#123; public static void main(String[] args) &#123; MyDoor myDoor = new MyDoor(); myDoor.close(); &#125; &#125; ``` ## 常见疑难 抽象与接口的区别： 共同点 - 都不能创建实例对象 - 可以声明变量，通过指向子类或实现类的对象类，来创建对象实例。 不同点 - Java 不支持多重继承，即一个子类只能有一个父类，但一个子类可以实现多个接口。 - 接口内不能有实例字段，只能有静态变量，抽象类可以拥有实例字段 - 接口内方法自动设置为 `public`的，抽象类中的方法必须手动声明访问控制符。 ## 枚举 `enum` ## 反射 程序自己能够检查自身信息。反射使得java语言具有了“动态性”，即程序首先会检查某个类中的方法、属性等信息，然后再动态的调用或动态的创建该类或该类的对象。 ### 反射类的基石 ――`Class`类 任何事物都可以用类表示，那么java中的类可以用一个什么类表示呢？ 从JDK1.2开始，就出现了Class类，该类描述Java中的一切事物，该类描述了关于类事务的类名字、类的访问属性、类所属的包名等。 ### 反射的基本应用 所谓反射就是把java类中的各种成分映射成相应的java类。 不仅java类，可以用`Class`类的对象表示，而java类的各种成员：成员变量、方法、构造方法、包等也可以用相应的类表示。 Java反射机制主要提供了以下功能： - 在运行时判断任意一个对象所属的类； - 在运行时构造任意一个类的对象； - 在运行时判断任意一个类所具有的成员变量和方法； - 在运行时调用任意一个对象的方法。 反射一般会设计如下类 ： - `Class` : 表示一个类的类 - `Filed` : 表示属性的类 - `Method` ： 表示方法的类 - `Constructor` : 表示类的构造方法的类 &amp;gt; `Class`类位于java.lang包中，而后面3个的类都位于java.lang.reflect包中</span><br><span class="line"></span><br><span class="line">编写Java反射程序的步骤：</span><br><span class="line"></span><br><span class="line">- 必须首先获取一个类的Class对象</span><br><span class="line">- 然后分别调用Class对象中的方法来获取一个类的属性/方法/构造方法的结构</span><br><span class="line"></span><br><span class="line">现有一个类：</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">package com.reflection;</span><br><span class="line">public class TestReflection &#123;</span><br><span class="line"></span><br><span class="line">private String username;</span><br><span class="line">private String password;</span><br><span class="line">private int[] age;</span><br><span class="line"></span><br><span class="line">public void setUserName(String username) &#123;</span><br><span class="line">this.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setPassWord(String password) &#123;</span><br><span class="line">this.password = password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取一个类的Class对象：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;TestReflection tfReflection = new TestReflection();</span><br><span class="line">Class c1 = TestReflection.class;</span><br><span class="line">Class c2 = Class.forName(&quot;com.reflection.TestReflection&quot;);</span><br><span class="line">Class c3 = tfReflection.getClass();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定的包名：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;String package01 = c1.getPackage().getName();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取类的修饰符:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int mod = c1.getModifiers();</span><br><span class="line">String modifier = Modifier.toString(mod);</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定类的完全限定名：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;String className = c1.getName();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定类的父类:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Class superClazz = c1.getSuperclass();</span><br><span class="line">String superClazzName = superClazz.getName();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取实现的接口:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Class[] interfaces = c1.getInterfaces();</span><br><span class="line">for (Class t : interfaces) &#123;</span><br><span class="line">System.out.println(&quot;interfacesName = &quot; + t.getName());</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定类的成员变量:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Field[] fields = c1.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">modifier = Modifier.toString(field.getModifiers()); // 获取每个字段的访问修饰符</span><br><span class="line">Class type = field.getType(); // 获取字段的数据类型所对应的Class对象</span><br><span class="line">String name = field.getName(); // 获取字段名</span><br><span class="line">if (type.isArray()) &#123; // 如果是数组类型则需要特别处理</span><br><span class="line">String arrType = type.getComponentType().getName() + &quot;[]&quot;;</span><br><span class="line">System.out.println(&quot;&quot; + modifier + &quot; &quot; + arrType + &quot; &quot; + name + &quot;;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">System.out.println(&quot;&quot; + modifier + &quot; &quot; + type + &quot; &quot; + name + &quot;;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取类的构造方法:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Constructor[] constructors = c1.getDeclaredConstructors();</span><br><span class="line">for (Constructor constructor : constructors) &#123;</span><br><span class="line">String name = constructor.getName(); // 构造方法名</span><br><span class="line">modifier = Modifier.toString(constructor.getModifiers()); // 获取访问修饰符</span><br><span class="line">System.out.println(&quot;&quot; + modifier + &quot; &quot; + name + &quot;(&quot;);</span><br><span class="line">Class[] paramTypes = constructor.getParameterTypes(); // 获取构造方法中的参数</span><br><span class="line">for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123;</span><br><span class="line">System.out.print(&quot;,&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (paramTypes[i].isArray()) &#123;</span><br><span class="line">System.out.println(paramTypes[i].getComponentType().getName() + &quot;[]&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(paramTypes[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;);&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取成员方法:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Method[] methods = c1.getDeclaredMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">modifier = Modifier.toString(method.getModifiers());</span><br><span class="line">Class returnType = method.getReturnType(); // 获取方法的返回类型</span><br><span class="line">if (returnType.isArray()) &#123;</span><br><span class="line">String arrType = returnType.getComponentType().getName() + &quot;[]&quot;;</span><br><span class="line">System.out.print(&quot;&quot; + modifier + &quot; &quot; + arrType + &quot; &quot; + method.getName() + &quot;(&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(&quot;&quot; + modifier + &quot; &quot; + returnType.getName() + &quot; &quot; + method.getName() + &quot;(&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Class[] paramTypes = method.getParameterTypes();</span><br><span class="line">for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123;</span><br><span class="line">System.out.print(&quot;,&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (paramTypes[i].isArray()) &#123;</span><br><span class="line">System.out.println(paramTypes[i].getComponentType().getName() + &quot;[]&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(paramTypes[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;);&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">反射调用方法，可以通过Method类的invoke方法实现动态方法的调用:</span><br><span class="line"></span><br><span class="line">&lt;code&gt;public Object invoke(Object obj, Object... args)&lt;/code&gt;</span><br><span class="line">第一个参数代表对象</span><br><span class="line">第二个参数代表执行方法上的参数</span><br><span class="line"></span><br><span class="line">若反射要调用类的某个私有方法，可以在这个私有方法对应的Mehtod对象上先调用&lt;code&gt;setAccessible(true)&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static void test02() throws InstantiationException, IllegalAccessException, SecurityException,</span><br><span class="line">NoSuchMethodException, IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">Class c1 = TestReflection.class;</span><br><span class="line">TestReflection t1 = (TestReflection) c1.newInstance(); // 利用反射来创建类的对象</span><br><span class="line"></span><br><span class="line">Method method = c1.getDeclaredMethod(&quot;setUserName&quot;, String.class);</span><br><span class="line">method.invoke(t1, &quot;Java反射的学习&quot;);</span><br><span class="line">method = c1.getDeclaredMethod(&quot;setPassWord&quot;, String.class);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line">method.invoke(t1, &quot;反射执行某个Private修饰的方法&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;反射的一些应用&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">既然String是不可变字符串对象，如何才能改变让其可变?[反射的一些应用][1]</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static void stringReflection() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">String s = &quot;Hello World&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;s = &quot; + s); //Hello World</span><br><span class="line"></span><br><span class="line">//获取String类中的value字段</span><br><span class="line">Field valueField = String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line"></span><br><span class="line">//改变value属性的访问权限</span><br><span class="line">valueField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">char[] value = (char[]) valueField.get(s);</span><br><span class="line"></span><br><span class="line">//改变value所引用的数组中的第5个字符</span><br><span class="line">value[5] = &#x27;_&#x27;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;s = &quot; + s); //Hello_World</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">既然String对象中没有对外提供可用的public setters等方法，因此只能通过Java中的反射机制实现。因此，前文中说到的String是不可变字符串对象只是针对“正常情况下”。而非必然。</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  Java的反射机制的概念：</span><br><span class="line">  在Java运行时环境中，对于任意一个类，能否知道这个类的哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java语言的反射（Reflection）机制。</span><br><span class="line">  </span><br><span class="line">  Reflection是Java被视为动态（准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括modifiers（诸如static、public等等）、superclass（例如Object）、实现interfaces（例如Serializable），也包括fields和methods的所有信息，并可于运行时改变fields内容或调用methods。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;标注 Annotation&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">在实际的应用中期可以部分或全部的取代传统的XML等部署描述文件。之所以要出现标注特性，是因为部署描述文件很复杂，在具体编写时很容易出错。</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;标注的简单使用&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@SuppressWarning&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class SimpleAnnotation &#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.runFinalizersOnExit(true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;几个简单的内置标注&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@Override&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.Annotation;</span><br><span class="line"></span><br><span class="line">class People&#123;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;people name&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends People&#123;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;student name&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Annotation_Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Student student = new Student();</span><br><span class="line">System.out.println(student.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  &lt;code&gt;@Override&lt;/code&gt; 是方法标注，只能作用于方法，在覆盖父类方法却又写错了方法名的时候发挥作用。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@Deprecated&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">很多时候，设计了一个包含&lt;code&gt;sayHello()&lt;/code&gt;方法的类&lt;code&gt;Hello.java&lt;/code&gt;，但是经过一段时间发现，&lt;code&gt;sayHello1()&lt;/code&gt;可以更好更快的实现相同的功能。但是这个时候如果去掉方法&lt;code&gt;sayHello()&lt;/code&gt;，那么调用该方法的类就会出现错误。为了兼容之前的类，而又不建议新设计的类使用方法&lt;code&gt;sayHello()&lt;/code&gt;，就需要把&lt;code&gt;Hello.java&lt;/code&gt;中的方法&lt;code&gt;sayHello()&lt;/code&gt;做&lt;code&gt;@Deprecated&lt;/code&gt;标注。</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.Annotation;</span><br><span class="line"></span><br><span class="line">class Hello&#123;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;已经过时的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void sayHello1() &#123;</span><br><span class="line">System.out.println(&quot;现在的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Deprecated_Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Hello hello = new Hello();</span><br><span class="line">hello.sayHello();</span><br><span class="line">hello.sayHello1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">当一个类或者类成员使用&lt;code&gt;@Deprecated&lt;/code&gt;修饰的话，编译器将不鼓励使用这个被标注的程序元素，而且这种修饰具有一定的“延续性”，即在代码中通过继承或者覆盖使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型并不是被声明为&lt;code&gt;@Deprecated&lt;/code&gt;，但是编译器仍要报警。</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  &lt;code&gt;@Deprecated&lt;/code&gt;标注不仅可以用在方法前面，而且可以用在参数或类的前面。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@SuppressWarning&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">可以用作标注类，属性、方法等成员，主要用于屏蔽警告。该标注于前面两个标注最大不同点在于其带有参数，并且参数可以是一个，可以是多个。参数的值为警告的类型。如：</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;已过时的警告 ： deprecation&lt;/li&gt;</span><br><span class="line">&lt;li&gt;没有使用警告 ： unused&lt;/li&gt;</span><br><span class="line">&lt;li&gt;类型不安全警告 ： unchecked&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  当&lt;code&gt;@SuppressWarning&lt;/code&gt; 接收的参数为多个值得时候，必须使用数组的方式为参数赋值。例如@SuppressWarning(&#123;&quot;deprecation&quot;,&quot;unused&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;泛型 &lt;code&gt;&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">所谓泛型，其本质就是实现参数化类型，也就是说所操作的数据类型被指定为一个参数。</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;泛型概念的提出:&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;qqyumidi&quot;);</span><br><span class="line">list.add(&quot;corn&quot;);</span><br><span class="line">list.add(100);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123; String name = (String) list.get(i); // 1 System.out.println(&quot;name:&quot; + name); &#125; &#125; &#125; ``` 运行结果 name:qqyumidi name:corn Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at com.fan.GenericTest.main(GenericTest.java:15) &amp;gt; Java2的集合框架，抽其核心，主要有三种：List、Set和Map。</span><br><span class="line">需要注意的是，这里的 Collection、List、Set和Map都是接口（Interface），不是具体的类实现。 List lst = new ArrayList(); 这是我们平常经常使用的创建一个新的List的语句，在这里， List是接口，ArrayList才是具体的类。</span><br><span class="line">常用集合类的继承结构如下：</span><br><span class="line">Collection&amp;lt;--List&amp;lt;--Vector</span><br><span class="line">Collection&amp;lt;--List&amp;lt;--ArrayList</span><br><span class="line">Collection&amp;lt;--List&amp;lt;--LinkedList</span><br><span class="line">Collection&amp;lt;--Set&amp;lt;--HashSet</span><br><span class="line">Collection&amp;lt;--Set&amp;lt;--HashSet&amp;lt;--LinkedHashSet</span><br><span class="line">Collection&amp;lt;--Set&amp;lt;--SortedSet&amp;lt;--TreeSet</span><br><span class="line">Map&amp;lt;--SortedMap&amp;lt;--TreeMap</span><br><span class="line">Map&amp;lt;--HashMap</span><br><span class="line"></span><br><span class="line">定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。</span><br><span class="line"></span><br><span class="line">在如上的编码过程中，我们发现主要存在两个问题：</span><br><span class="line"></span><br><span class="line">1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。</span><br><span class="line"></span><br><span class="line">2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。</span><br><span class="line"></span><br><span class="line">那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。</span><br><span class="line"></span><br><span class="line">### 什么是泛型？</span><br><span class="line"></span><br><span class="line">泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*</span><br><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;qqyumidi&quot;);</span><br><span class="line">list.add(&quot;corn&quot;);</span><br><span class="line">list.add(100);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">List&lt;string&gt; list = new ArrayList&lt;string&gt;();</span><br><span class="line">list.add(&quot;qqyumidi&quot;);</span><br><span class="line">list.add(&quot;corn&quot;);</span><br><span class="line">//list.add(100); // 1 提示编译错误&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">String name = list.get(i); // 2</span><br><span class="line">System.out.println(&quot;name:&quot; + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义泛型接口、泛型类和泛型方法"><a href="#自定义泛型接口、泛型类和泛型方法" class="headerlink" title="自定义泛型接口、泛型类和泛型方法"></a>自定义泛型接口、泛型类和泛型方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest1 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; num = new Box&lt;integer&gt;(4);</span><br><span class="line">System.out.println(&quot;name:&quot; + name.getData());</span><br><span class="line">System.out.println(&quot;num:&quot; + num.getData());</span><br><span class="line">&#125;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Box&lt;t&gt; &#123;&lt;/t&gt;</span><br><span class="line"></span><br><span class="line">private T data;</span><br><span class="line"></span><br><span class="line">public Box() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Box(T data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>name:corn<br>num:4</p>
<p>在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;name class:&quot; + name.getClass()); // com.qqyumidi.Box</span><br><span class="line">System.out.println(&quot;age class:&quot; + age.getClass()); // com.qqyumidi.Box</span><br><span class="line">System.out.println(name.getClass() == age.getClass()); // true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>name class:class com.fan.Box<br>num class:class com.fan.Box<br>true</p>
<p>由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。</p>
<p>究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
<h3 id="关于泛型通配符"><a href="#关于泛型通配符" class="headerlink" title="关于泛型通配符"></a>关于泛型通配符</h3><p>接着上面的结论，我们知道，Box<Number>和Box<Integer>实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于<code>Box&lt;Number&gt;</code>和<code>Box&lt;Integer&gt;</code>是否可以看成具有父子关系的泛型类型呢？</p>
<blockquote>
<p>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类Number的子类。</p>
</blockquote>
<h3 id="关于泛型的一些特性"><a href="#关于泛型的一些特性" class="headerlink" title="关于泛型的一些特性"></a>关于泛型的一些特性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;number&gt; name = new Box&lt;number&gt;(99);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);&lt;/integer&gt;&lt;/integer&gt;&lt;/number&gt;&lt;/number&gt;</span><br><span class="line"></span><br><span class="line">getData(name);</span><br><span class="line">getData(age); // 1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getData(Box&lt;number&gt; data)&#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;&lt;/number&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过提示信息，我们知道<code>Box&lt;Number&gt;</code>在逻辑上不能视为<code>Box&lt;Integer&gt;</code>的父类.</p>
<p>我们需要一个在逻辑上可以用来表示同时是<code>Box&lt;Integer&gt;</code>和<code>Box&lt;Number&gt;</code>的父类的一个引用类型，由此，类型通配符应运而生。</p>
<p>类型通配符一般是使用 <code>?</code>代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且<code>Box&lt;?&gt;</code>在逻辑上是<code>Box&lt;Integer&gt;</code>、<code>Box&lt;Number&gt;</code>…等所有<code>Box&lt;具体类型实参&gt;</code>的父类。由此，我们依然可以定义泛型方法，来完成此类需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);</span><br><span class="line">Box&lt;number&gt; number = new Box&lt;number&gt;(314);&lt;/number&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">getData(name);</span><br><span class="line">getData(age);</span><br><span class="line">getData(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getData(Box&lt;?&gt; data) &#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？</p>
<p>在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);</span><br><span class="line">Box&lt;number&gt; number = new Box&lt;number&gt;(314);&lt;/number&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">getData(name);</span><br><span class="line">getData(age);</span><br><span class="line">getData(number);</span><br><span class="line"></span><br><span class="line">//getUpperNumberData(name); // 1</span><br><span class="line">getUpperNumberData(age); // 2</span><br><span class="line">getUpperNumberData(number); // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getData(Box&lt;?&gt; data) &#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getUpperNumberData(Box&lt;? extends Number&gt; data)&#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。</p>
<p>类型通配符上限通过形如Box&lt;? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt;? super Number&gt;形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>程序是计算机指令集合，它以文件形式存储在磁盘上</p>
<p>进程就是一个执行中的程序，每一个进程都有一个独立的内存空间和资源系统。</p>
<p>线程是CPU调度和分配的基本单位，一个进程可以由多个线程组成，而这多个线程共享同一个存储空间，这使得线程间的通信比较容易。</p>
<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>创建线程的方法有两种 ：</p>
<ul>
<li>通过实现<code>Runnable</code>接口的方式创建线程</li>
<li>通过集成<code>Threa</code>类来创建线程</li>
</ul>
<h4 id="通过实现Runnable接口的方式创建线程"><a href="#通过实现Runnable接口的方式创建线程" class="headerlink" title="通过实现Runnable接口的方式创建线程"></a>通过实现<code>Runnable</code>接口的方式创建线程</h4><p>在java中，线程是一种对象，而不是所有的对象都可以被称为线程，只有实现了<code>Runnable</code>接口的对象才可以被称为线程。</p>
<p><code>Runnable</code>接口的定义：</p>
<p>public interface new Runnable() {<br>public abstract void run() ;<br>}</p>
<p>只有实现了该接口的类才有资格被称为线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.threadtest;</span><br><span class="line"></span><br><span class="line">class ThreadTest implements Runnable &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest2 implements Runnable&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadTest1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ThreadTest test = new ThreadTest();</span><br><span class="line">ThreadTest2 test2 = new ThreadTest2();</span><br><span class="line">Thread thread = new Thread(test);</span><br><span class="line">Thread thread2 = new Thread(test2);</span><br><span class="line">thread.start();</span><br><span class="line">thread2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java技术中，线程通常是通过调度模块来执行的。所谓抢占式调度模式是指：许多线程处于可以运行状态，即等待状态，但实际只有一个线程在运行。该线程一直运行直到他终止或是另一个优先级更高的线程变成可运行状态。</p>
<h4 id="通过继承Thread类的方式创建线程"><a href="#通过继承Thread类的方式创建线程" class="headerlink" title="通过继承Thread类的方式创建线程"></a>通过继承<code>Thread</code>类的方式创建线程</h4><p>其实<code>Thread</code>本身也实现了<code>Runnable</code>接口，所以只要让一个类继承<code>Thread</code>类，并覆盖<code>run()</code>方法，也会创建进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.threadtest;</span><br><span class="line"></span><br><span class="line">class Threadtest_3 extends Thread &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 1&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest_4 extends Thread&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Threadtest_3 threadtest_3 =new Threadtest_3();</span><br><span class="line">ThreadTest_4 threadTest_4 = new ThreadTest_4();</span><br><span class="line"></span><br><span class="line">Thread thread3 = new Thread(threadtest_3);</span><br><span class="line">Thread thread4 = new Thread(threadTest_4);</span><br><span class="line"></span><br><span class="line">thread3.start();</span><br><span class="line">thread4.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程包括5种状态：新建状态、就绪状态、运行状态、阻塞状态和死亡状态。</p>
<p>新建状态</p>
<p>线程对象通过<code>new</code>关键字已经建立，在内存中有一个活跃的对象，但是没有启动该线程，所以它仍不能做任何事情，此时线程处于新建状态，程序中没有运行线程中的代码，如果线程要运行需要处于就绪状态。</p>
<p>就绪状态</p>
<p>一个线程一旦调用了<code>start()</code>方法，该线程就处于就绪状态。此时线程等待CPU时间片，一旦获得CPU时间周期，一旦获得CPU周期，线程就可以执行。这种状态下的任何时刻，线程是否执行完全取决于系统的调度程序。</p>
<p>运行状态</p>
<p>一旦处于就绪状态的线程获得CPU执行周期，就处于运行状态，执行多线程代码部分的运算。线程一旦运行，只是在CPU周期内获得执行权利，而一旦CPU的时间片用完，操作系统会给其他的线程运行的机会，而剥夺当前线程的执行。在选择哪个线程可以执行时，操作系统的调度程序会考虑现成的优先级，该内容后续讲解。</p>
<p>阻塞状态</p>
<p>该状态下线程无法运行，必须满足一定条件条件后才可以执行。如果线程处于阻塞状态，JVM调度机不会为其分配CPU周期。而线程满足一定条件就被解除阻塞，线程处于就绪状态，此时就获得了被执行的机会。当发生以下情况的时候线程会进入阻塞状态：</p>
<ul>
<li>线程正在等待一个输入输出操作，该操作完成前不会返回其调用者。</li>
<li>线程调用了<code>wait()</code>方法或是<code>sleep()</code>方法。</li>
<li>线程需要满足某种条件之后可以继续执行。</li>
</ul>
<p>死亡状态</p>
<p>线程一旦退出<code>run()</code>方法就处于死亡状态。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>线程的执行顺序是一种抢占方式，优先级高的比优先级低的要获得更多的执行时间，如果想让一个线程比其他线程有更多的运行时间，可以通过设置线程的优先级解决。</p>
<p>具体方法如下：</p>
<p>public final void setPriority(int newPriority);</p>
<p>其中，<code>newPriority</code>是一个1~10的正整数，数值越大，优先级别越高。系统定义了一些常用的数值如下：</p>
<ul>
<li>public final static int MIN_PRIORITY = 1 ：表示最低优先级</li>
<li>public final static int MAX_PRIORITY = 10 ：表示最高优先级</li>
<li>public final static int NORM_PRIORITY = 5 ：表示默认优先级</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.threadtest;</span><br><span class="line"></span><br><span class="line">import org.omg.CORBA.PUBLIC_MEMBER;</span><br><span class="line"></span><br><span class="line">class Threadtest_3 extends Thread &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest_4 extends Thread&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">System.out.println(&quot;hello&quot;+ i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Threadtest_3 threadtest_3 =new Threadtest_3();</span><br><span class="line">ThreadTest_4 threadTest_4 = new ThreadTest_4();</span><br><span class="line"></span><br><span class="line">Thread thread3 = new Thread(threadtest_3);</span><br><span class="line">Thread thread4 = new Thread(threadTest_4);</span><br><span class="line"></span><br><span class="line">thread3.setPriority(3);</span><br><span class="line">thread4.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">thread3.start();</span><br><span class="line">thread4.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的休眠与唤醒"><a href="#线程的休眠与唤醒" class="headerlink" title="线程的休眠与唤醒"></a>线程的休眠与唤醒</h3><p>线程的休眠 <code>sleep()</code></p>
<p>线程处于等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">///这是一个主运行类</span><br><span class="line">///创建一个线程对象，让其运行</span><br><span class="line">public class thread5</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute27 t=new compute27();</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类，在这个类中，通过休眠来输出不同结果</span><br><span class="line">class compute27 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;在工作中，不要打扰&quot;);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">sleep(1000000);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;哦，电话来了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程唤醒 <code>interrup()</code></p>
<p>当一个线程处于休眠状态，如果开始设置了休眠时间是1000ms，但是想在休眠了500ms的时候，让它继续执行，这时候就可以使用线程唤醒功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">public class thread6</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute28 t=new compute28();</span><br><span class="line">t.start();</span><br><span class="line">t.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类，在这个类中，通过休眠，让线程运行输出不同的结果</span><br><span class="line">class compute28 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;在工作中，不要打扰&quot;);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">sleep(1000000);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;哦，电话来了&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程让步-yield"><a href="#线程让步-yield" class="headerlink" title="线程让步 yield()"></a>线程让步 <code>yield()</code></h3><p>所谓线程让步，就是使当前正在运行的线程对象退出运行状态，让其他线程运行。</p>
<p>这个方法不能讲运行权让给指定的线程，只是允许这个线程把运行权让出来，至于给谁，就看谁能抢到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">///这是一个主运行类</span><br><span class="line">///在主运行方法中，通过创建两个线程对象，让其交替执行</span><br><span class="line">public class thread7</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute29 t=new compute29();</span><br><span class="line">compute30 t1=new compute30();</span><br><span class="line">t.start();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///通过循环语句来输出十个整型数据</span><br><span class="line">///通过让步程序让此线程停止运行</span><br><span class="line">class compute29 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///通过循环语句来输出说明语句</span><br><span class="line">class compute30 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;这个数字是:&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">//这是一个主运行类</span><br><span class="line">///在主运行方法中，通过创建两个线程对象，让其交替执行</span><br><span class="line">public class thread8</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute31 t=new compute31(&#x27;a&#x27;);</span><br><span class="line">compute31 t1=new compute31(&#x27;b&#x27;);</span><br><span class="line">t.start();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///在这线程类中，使用循环语句输出字符</span><br><span class="line">class compute31 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">compute31(char ch)</span><br><span class="line">&#123;</span><br><span class="line">this.ch=ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程循环输出，就会出现抢占现象。解决这个问题的办法是可以使用线程同步，解决同步的两个方法：</p>
<ul>
<li>同步块</li>
<li>同步化方法</li>
</ul>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><p>同步块是使具有某个对象监视点的线程，获得运行权限的一种方法，每个对象只能在拥有这个监视点的情况下，才能获得运行权限。</p>
<p>同步块的结构如下：</p>
<p>synchronized (bObject) {<br>程序段<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">//这是一个主运行类</span><br><span class="line">///在主运行方法中，通过创建两个线程对象，让其交替执行</span><br><span class="line">public class thread8</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute31 t=new compute31(&#x27;a&#x27;);</span><br><span class="line">compute31 t1=new compute31(&#x27;b&#x27;);</span><br><span class="line">t.start();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///在这线程类中，使用循环语句输出字符</span><br><span class="line">class compute31 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">static Object bObject = new Object();</span><br><span class="line">compute31(char ch)</span><br><span class="line">&#123;</span><br><span class="line">this.ch=ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">synchronized (bObject) &#123;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;10;i++) &#123; System.out.print(ch); &#125; &#125; &#125; &#125; ``` ### 同步化方法 同步化方法就是对整个方法进行同步： 结构如下： synchronized void f() &#123; 代码 &#125; ```java //这是一个主运行类 ///在主运行方法中，通过创建三个线程对象，让其交替执行 public class thread11 &#123; public static void main(String[] args) &#123; compute34 t=new compute34(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); &#125; &#125; ///创建一个线程类 ///在这线程类中，使用循环语句输出字符 ///在run方法中，使用同步块来给线程加一把锁 class compute34 extends Thread &#123; int i=10; static Object obj=new Object(); public void print() &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); i--; &#125; public void run() &#123; while(i&amp;gt;0) &#123; synchronized(obj) &#123; print(); &#125; try &#123; sleep(1000); &#125; catch(Exception e)&#123;&#125; &#125; &#125; &#125; ``` ## 异常的处理和内存管理 ## Java 输入和输出 Java程序类库中包含大量的输入输出类，提供不同情况的不同功能。其中包括： - 关于文件操作的类 `File` - 关于以字节方式访问文件的类 `InputStream`和类`OutStream` - 关于以字符方式访问文件的类`Reader`和类`Writer` &amp;gt; 在编写程序的过程中，若是要使用输入输出类的方法和属性值，就需要引入`java.io`类</span><br><span class="line"></span><br><span class="line">## Java 的I/O操作</span><br><span class="line"></span><br><span class="line">Java中I/O操作主要是指使用Java进行输入，输出操作.</span><br><span class="line"></span><br><span class="line">Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。Java的I/O流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供以数据流的方式读写它的数据的方法。</span><br><span class="line"></span><br><span class="line">总结的基本概念如下：</span><br><span class="line"></span><br><span class="line">数据流：</span><br><span class="line"></span><br><span class="line">一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。</span><br><span class="line"></span><br><span class="line">输入流：</span><br><span class="line"></span><br><span class="line">程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</span><br><span class="line"></span><br><span class="line">输出流：</span><br><span class="line"></span><br><span class="line">程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</span><br><span class="line"></span><br><span class="line">采用数据流的目的就是使得输出输入独立于设备。</span><br><span class="line"></span><br><span class="line">数据流分类：</span><br><span class="line"></span><br><span class="line">流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</span><br><span class="line">1) 字节流：数据流中最小的数据单元是字节</span><br><span class="line">2) 字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</span><br><span class="line"></span><br><span class="line">### 标准I/O</span><br><span class="line"></span><br><span class="line">### java.IO层次体系结构</span><br><span class="line"></span><br><span class="line">在整个Java.io包中最重要的就是5个类和一个接口。</span><br><span class="line"></span><br><span class="line">5个类指的是`File`、`OutputStream`、`InputStream`、`Writer`、`Reader`；</span><br><span class="line"></span><br><span class="line">1个接口指的是`Serializable`.</span><br><span class="line"></span><br><span class="line">掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了。</span><br><span class="line"></span><br><span class="line">主要的类如下：</span><br><span class="line"></span><br><span class="line">File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</span><br><span class="line">InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</span><br><span class="line">OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</span><br><span class="line"></span><br><span class="line">Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。</span><br><span class="line"></span><br><span class="line">Reader（文件格式操作）：抽象类，基于字符的输入操作。</span><br><span class="line">Writer（文件格式操作）：抽象类，基于字符的输出操作。</span><br><span class="line">RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</span><br><span class="line"></span><br><span class="line">### 文件或目录信息的处理 `File`</span><br><span class="line"></span><br><span class="line">`File` 类提供了与文件或目录相关的信息</span><br><span class="line"></span><br><span class="line">文件处理方法：</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">package com.filetest;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">public class FileTest1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">File file = new File(&quot;d:\\&quot;,&quot;file.txt&quot;);</span><br><span class="line">System.out.println(file.getName());</span><br><span class="line">System.out.println(file.getParent());</span><br><span class="line">System.out.println(file.getPath());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>file.txt<br>d:<br>d:\file.txt</p>
<p>文件和目录的操作：</p>
<p>在Java中，目录被当做一种特殊的文件使用。类<code>File</code>是唯一代表磁盘文件对象的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.chaozuo;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">///通过print方法来判断这个文件类对象的性质</span><br><span class="line">///通过print1方法来获取文件对象的信息</span><br><span class="line">///通过print2方法来获取文件对象的信息</span><br><span class="line">public class file1 &#123;</span><br><span class="line">public void print(File f) &#123;</span><br><span class="line">//通过print方法来判断这个文件类对象的性质</span><br><span class="line">if (f.isDirectory()) &#123;</span><br><span class="line">//判断f对象是否为目录</span><br><span class="line">System.out.println(&quot;这是一个目录！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;这不是一个目录！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (f.exists()) &#123;</span><br><span class="line">//判断f对象是否存在</span><br><span class="line">System.out.println(&quot;这个文件存在的！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;抱歉，这个文件不存在的！&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">f.createNewFile();</span><br><span class="line">//当文件不存在时，创建一个文件</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void print1(File f) &#123;</span><br><span class="line">//通过print1方法来获取文件目录对象的信息</span><br><span class="line">System.out.println(f.getName());</span><br><span class="line">System.out.println(f.getParent());</span><br><span class="line">System.out.println(f.getPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void print2(File f) &#123;</span><br><span class="line">//通过print2方法来获取文件对象的信息</span><br><span class="line">if (f.isFile()) &#123;</span><br><span class="line">System.out.println(f.lastModified());</span><br><span class="line">System.out.println(f.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">file1 f1 = new file1(); //创建一个f1对象</span><br><span class="line">File f = new File(&quot;d:\\filetest&quot;);</span><br><span class="line">//调用相应的方法</span><br><span class="line">f1.print(f);</span><br><span class="line">f1.print1(f);</span><br><span class="line">f1.print2(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>这不是一个目录！<br>抱歉，这个文件不存在的！<br>filetest<br>d:<br>d:\filetest<br>1452923459623<br>0</p>
<h3 id="使用文件字节输入流读取文件-FileInputStream"><a href="#使用文件字节输入流读取文件-FileInputStream" class="headerlink" title="使用文件字节输入流读取文件 FileInputStream"></a>使用文件字节输入流读取文件 <code>FileInputStream</code></h3><p><code>FileInputStream</code>类是是<code>InputStream</code>的子类，并且不是抽象类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">///创建一个文件类f</span><br><span class="line">///创建一个输入流对象fis，并且以f作为参数</span><br><span class="line">///使用循环语句将文本文件中的字符读出</span><br><span class="line">public class file3 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File f = new File(&quot;d:\\filetest\\file.txt&quot;);</span><br><span class="line">//创建一个文件类f</span><br><span class="line">FileInputStream fis = new FileInputStream(f);</span><br><span class="line">//创建对象f的文件输入流</span><br><span class="line">char ch;</span><br><span class="line">//声明一个字符串对象ch</span><br><span class="line">for (int i = 0; i &lt; f.length(); i++) &#123;</span><br><span class="line">//通过循环读取文件类f所对应的文件</span><br><span class="line">ch = (char) fis.read();</span><br><span class="line">System.out.print(ch);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用文件字节输出流输出文件-FileOutputStream"><a href="#使用文件字节输出流输出文件-FileOutputStream" class="headerlink" title="使用文件字节输出流输出文件 FileOutputStream"></a>使用文件字节输出流输出文件 <code>FileOutputStream</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">///创建一个文件类f</span><br><span class="line">///创建一个输入流对象fis，并且以f作为参数</span><br><span class="line">///将所有的字节都保存到一个字节数组b中。</span><br><span class="line">///使用循环语句将b中的字符读出</span><br><span class="line">public class file4 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File f = new File(&quot;d:\\filetest\\file.txt&quot;);</span><br><span class="line">//创建一个文件类f</span><br><span class="line">FileInputStream fis = new FileInputStream(f);</span><br><span class="line">//创建一个输入流对象fis，并且以f作为参数</span><br><span class="line">byte[] b = new byte[(int) f.length()];</span><br><span class="line">//创建一个字节数组对象b</span><br><span class="line">fis.read(b);</span><br><span class="line">//读取到的内容存储到字节数组对象b</span><br><span class="line">for (int i = 0; i &lt; f.length(); i++) &#123;</span><br><span class="line">//通过循环输出相应内容</span><br><span class="line">System.out.print((char) b[i]);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java中对数据的处理"><a href="#Java中对数据的处理" class="headerlink" title="Java中对数据的处理"></a>Java中对数据的处理</h2><h3 id="基本数据类型和对象数据类型的转换"><a href="#基本数据类型和对象数据类型的转换" class="headerlink" title="基本数据类型和对象数据类型的转换"></a>基本数据类型和对象数据类型的转换</h3><p>为什么要将基本类型转换成对象数据类型：</p>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(<code>Wrapper Class</code>)</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>由于所有的包装类具有比较相似的成员，这里以<code>Integer</code>类为例：</p>
<p><code>Integer</code>类的构造方法：</p>
<p>public integer(int value):将整型值value包装成持有此值的<code>Integer</code>类对象。<br>public integer(string s)：将由数字字符组成的串s包装成持有此值的<code>Integer</code>类对象，若s不是数字构成的话，则会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class file1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int x = 12; //创建一个整形类型变量x</span><br><span class="line">String str = &quot;13579&quot;; //创建一个字符串类型变量str</span><br><span class="line">//把变量x，str转换成对象类型t1和t2</span><br><span class="line">Integer t1 = new Integer(x);</span><br><span class="line">Integer t2 = new Integer(str);</span><br><span class="line">//通过tostring()把对象转换成字符串。</span><br><span class="line">System.out.println(t1);</span><br><span class="line">System.out.println(t2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何处理随机性数据-Random"><a href="#如何处理随机性数据-Random" class="headerlink" title="如何处理随机性数据 Random"></a>如何处理随机性数据 <code>Random</code></h3><h3 id="如何对数据进行排列、整理-Arrays"><a href="#如何对数据进行排列、整理-Arrays" class="headerlink" title="如何对数据进行排列、整理 Arrays"></a>如何对数据进行排列、整理 <code>Arrays</code></h3><h2 id="数据结构接口"><a href="#数据结构接口" class="headerlink" title="数据结构接口"></a>数据结构接口</h2><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><code>Collection</code>接口</h3><p><code>Collection</code>接口是数据集合接口，它位于数据结构API的最上部，构成<code>Collection</code>的单位被称为元素。可将<code>Collection</code>接口分为三个部分，分别是<code>Map</code>接口、<code>Set</code>接口和<code>List</code>接口。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/03/08/python%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/08/python%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Python基础入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-08 21:21:06" itemprop="dateCreated datePublished" datetime="2018-03-08T21:21:06+08:00">2018-03-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/03/08/python%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/08/python基础入门/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h1><h2 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 100+200</span><br><span class="line">300</span><br></pre></td></tr></table></figure>

<p>如果要让Python打印出指定的文字，可以用print()函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号：<br>第一个hello world!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;hello, world&#x27;)</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>

<p>这种用单引号或者双引号括起来的文本在程序中叫字符串，今后我们还会经常遇到。</p>
<p>最后，用exit()退出Python，我们的第一个Python程序完成！唯一的缺憾是没有保存下来，下次运行时还要再输入一遍代码。</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;hello, world&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;The quick brown fox&#x27;, &#x27;jumps over&#x27;, &#x27;the lazy dog&#x27;)</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure>

<p>print()也可以打印整数，或者计算结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(300)</span><br><span class="line">300</span><br><span class="line">&gt;&gt;&gt; print(100 + 200)</span><br><span class="line">300</span><br></pre></td></tr></table></figure>

<p>因此，我们可以把计算100 + 200的结果打印得更漂亮一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;100 + 200 =&#x27;, 100 + 200)</span><br><span class="line">100 + 200 = 300</span><br></pre></td></tr></table></figure>

<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>现在，你已经可以用print()输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; name = input()</span><br><span class="line">Michael</span><br><span class="line">name = input()</span><br><span class="line">print(&#x27;hello,&#x27;, name)</span><br></pre></td></tr></table></figure>

<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>整数 浮点数 字符串</p>
<p>字符串：’I&#39;m &quot;OK&quot;!’表示的字符串内容是：I’m “OK”!</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 2</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 3 &gt; 5</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>布尔值可以用and、or和not运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; True and True</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True and False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; False and False</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>not运算是非运算，它是一个单目运算符，把True变成False，False变成True：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; not True</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; not False</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; not 1 &gt; 2</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>布尔值经常用在条件判断中，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">print(&#x27;adult&#x27;)</span><br><span class="line">else:</span><br><span class="line">print(&#x27;teenager&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p>
<p>PI = 3.14159265359</p>
<p>最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 / 3</span><br><span class="line">3.3333333333333335</span><br></pre></td></tr></table></figure>

<p>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 9 / 3</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure>

<p>还有一种除法是//，称为地板除，两个整数的除法仍然是整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;包含中文的str&#x27;)</span><br><span class="line">包含中文的str</span><br></pre></td></tr></table></figure>

<p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&#x27;A&#x27;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&#x27;中&#x27;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&#x27;B&#x27;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&#x27;文&#x27;</span><br></pre></td></tr></table></figure>

<p>要计算str包含多少个字符，可以用len()函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&#x27;ABC&#x27;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&#x27;中文&#x27;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(b&#x27;ABC&#x27;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; len(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Hello, %s&#x27; % &#x27;world&#x27;</span><br><span class="line">&#x27;Hello, world&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;Hi, %s, you have $%d.&#x27; % (&#x27;Michael&#x27;, 1000000)</span><br><span class="line">&#x27;Hi, Michael, you have $1000000.&#x27;</span><br></pre></td></tr></table></figure>

<p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Age: %s. Gender: %s&#x27; % (25, True)</span><br><span class="line">&#x27;Age: 25. Gender: True&#x27;</span><br></pre></td></tr></table></figure>

<p>有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;growth rate: %d %%&#x27; % 7</span><br><span class="line">&#x27;growth rate: 7 %&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>
<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>

<p>变量classmates就是一个list。用len()函数可以获得list元素的个数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(classmates)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>用索引来访问list中每一个位置的元素，记得索引是从0开始的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[0]</span><br><span class="line">&#x27;Michael&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[1]</span><br><span class="line">&#x27;Bob&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[2]</span><br><span class="line">&#x27;Tracy&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[3]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br><span class="line">​```&lt;/module&gt;&lt;/stdin&gt;</span><br><span class="line"></span><br><span class="line">如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：</span><br><span class="line"></span><br><span class="line">​```python</span><br><span class="line">&gt;&gt;&gt; classmates[-1]</span><br><span class="line">&#x27;Tracy&#x27;</span><br></pre></td></tr></table></figure>

<p>以此类推，可以获取倒数第2个、倒数第3个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates[-2]</span><br><span class="line">&#x27;Bob&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[-3]</span><br><span class="line">&#x27;Michael&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates[-4]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br><span class="line">​```&lt;/module&gt;&lt;/stdin&gt;</span><br><span class="line"></span><br><span class="line">list是一个可变的有序表，所以，可以往list中追加元素到末尾：</span><br><span class="line">​```python</span><br><span class="line">&gt;&gt;&gt; classmates.append(&#x27;Adam&#x27;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span><br></pre></td></tr></table></figure>

<p>要删除list末尾的元素，用pop()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&#x27;Adam&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>

<p>也可以把元素插入到指定的位置，比如索引号为1的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.insert(1, &#x27;Jack&#x27;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span><br></pre></td></tr></table></figure>

<p>list元素也可以是另一个list，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [&#x27;python&#x27;, &#x27;java&#x27;, [&#x27;asp&#x27;, &#x27;php&#x27;], &#x27;scheme&#x27;]</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;)</span><br></pre></td></tr></table></figure>

<p>现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2)</span><br></pre></td></tr></table></figure>

<p>如果要定义一个空的tuple，可以写成()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = ()</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">()</span><br></pre></td></tr></table></figure>

<p>但是，要定义一个只有1个元素的tuple，如果你这么定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure>

<p>Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<p>最后来看一个“可变的”tuple：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])</span><br><span class="line">&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;</span><br><span class="line">&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;])</span><br></pre></td></tr></table></figure>

<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">print(&#x27;your age is&#x27;, age)</span><br><span class="line">print(&#x27;adult&#x27;)</span><br></pre></td></tr></table></figure>

<p>当然上面的判断是很粗略的，完全可以用elif做更细致的判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = 3</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">print(&#x27;adult&#x27;)</span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">print(&#x27;teenager&#x27;)</span><br><span class="line">else:</span><br><span class="line">print(&#x27;kid&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">for name in names:</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>

<p>再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</span><br><span class="line">sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<p>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">for x in range(101):</span><br><span class="line">sum = sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<h2 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h2><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">scores = [95, 75, 85]</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line">如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：</span><br><span class="line">​```python</span><br><span class="line">&gt;&gt;&gt; d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Michael&#x27;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure>

<p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Adam&#x27;] = 67</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Adam&#x27;]</span><br><span class="line">67</span><br></pre></td></tr></table></figure>

<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;] = 90</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;]</span><br><span class="line">90</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;] = 88</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Jack&#x27;]</span><br><span class="line">88</span><br></pre></td></tr></table></figure>

<p>要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Thomas&#x27; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>要删除一个key，用pop(key)方法，对应的value也会从dict中删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#x27;Bob&#x27;)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85&#125;</span><br></pre></td></tr></table></figure>

<p>和list比较，dict有以下几个特点：</p>
<p>1.查找和插入的速度极快，不会随着key的增加而增加；<br>2.需要占用大量的内存，内存浪费多。<br>而list相反：</p>
<p>1.查找和插入的时间随着元素的增加而增加；<br>2.占用空间小，浪费内存很少。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>

<p>注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。</p>
<p>重复元素在set中自动被过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>

<p>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>

<p>通过remove(key)方法可以删除元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>

<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h2><p>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span><br><span class="line">&gt;&gt;&gt; a.sort()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<p>而对于不可变对象，比如str，对str进行操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#x27;abc&#x27;</span><br><span class="line">&gt;&gt;&gt; a.replace(&#x27;a&#x27;, &#x27;A&#x27;)</span><br><span class="line">&#x27;Abc&#x27;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#x27;abc&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>调用abs函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(100)</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; abs(-20)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; abs(12.34)</span><br><span class="line">12.34</span><br></pre></td></tr></table></figure>

<p>而max函数max()可以接收任意多个参数，并返回最大的那个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; max(1, 2)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; max(2, 3, 1, -5)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&#x27;123&#x27;)</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; int(12.34)</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; float(&#x27;12.34&#x27;)</span><br><span class="line">12.34</span><br><span class="line">&gt;&gt;&gt; str(1.23)</span><br><span class="line">&#x27;1.23&#x27;</span><br><span class="line">&gt;&gt;&gt; str(100)</span><br><span class="line">&#x27;100&#x27;</span><br><span class="line">&gt;&gt;&gt; bool(1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bool(&#x27;&#x27;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = abs # 变量a指向abs函数</span><br><span class="line">&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>我们以自定义一个求绝对值的my_abs函数为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">if x &gt;= 0:</span><br><span class="line">return x</span><br><span class="line">else:</span><br><span class="line">return -x</span><br></pre></td></tr></table></figure>

<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">def move(x, y, step, angle=0):</span><br><span class="line">nx = x + step * math.cos(angle)</span><br><span class="line">ny = y - step * math.sin(angle)</span><br><span class="line">return nx, ny</span><br></pre></td></tr></table></figure>

<p>然后，我们就可以同时获得返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print(x, y)</span><br><span class="line">151.96152422706632 70.0</span><br></pre></td></tr></table></figure>

<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>我们先写一个计算x*x的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def power(x):</span><br><span class="line">return x * x</span><br></pre></td></tr></table></figure>

<p>当我们调用power函数时，必须传入有且仅有的一个参数x：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(15)</span><br><span class="line">225</span><br></pre></td></tr></table></figure>

<p>现在，如果我们要计算x3怎么办？可以再定义一个power3函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。</p>
<p>你也许想到了，可以把power(x)修改为power(x, n)，用来计算xn，说干就干：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n):</span><br><span class="line">s = 1</span><br><span class="line">while n &gt; 0:</span><br><span class="line">n = n - 1</span><br><span class="line">s = s * x</span><br><span class="line">return s</span><br></pre></td></tr></table></figure>

<p>对于这个修改后的power(x, n)函数，可以计算任意n次方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 3)</span><br><span class="line">125</span><br></pre></td></tr></table></figure>

<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：</p>
<p>fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n</p>
<p>于是，fact(n)用递归的方式写出来就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">if n==1:</span><br><span class="line">return 1</span><br><span class="line">return n * fact(n - 1)</span><br></pre></td></tr></table></figure>

<p>上面就是一个递归函数。可以试试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fact(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; fact(100)</span><br><span class="line">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">return fact_iter(n, 1)</span><br><span class="line"></span><br><span class="line">def fact_iter(num, product):</span><br><span class="line">if num == 1:</span><br><span class="line">return product</span><br><span class="line">return fact_iter(num - 1, num * product)</span><br></pre></td></tr></table></figure>

<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/02/07/change-git-remote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/07/change-git-remote/" class="post-title-link" itemprop="url">批量替换和修改Git远端地址</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-07 16:40:19" itemprop="dateCreated datePublished" datetime="2018-02-07T16:40:19+08:00">2018-02-07</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/02/07/change-git-remote/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/02/07/change-git-remote/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在git bash中执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;.git&quot;</span> -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/旧地址/新地址/g&#x27;</span> &#123;&#125;/config \;</span><br></pre></td></tr></table></figure>

<p>将替换所有子目录的git远端地址</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/02/07/git-gpg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/07/git-gpg/" class="post-title-link" itemprop="url">Git添加PGP签名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-02-07 16:40:19" itemprop="dateCreated datePublished" datetime="2018-02-07T16:40:19+08:00">2018-02-07</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/02/07/git-gpg/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/02/07/git-gpg/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>环境变量GNUPGHOME：C:\Program Files (x86)\GnuPG\bin\gpg.exe</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global gpg.program <span class="string">&quot;C:\Program Files (x86)\GnuPG\bin\gpg.exe&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.signingkey 你的公钥</span><br><span class="line"></span><br><span class="line">git config --global commit.gpgsign <span class="literal">true</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/01/09/minjiebaihua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/09/minjiebaihua/" class="post-title-link" itemprop="url">敏捷开发白话篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-09 10:05:14" itemprop="dateCreated datePublished" datetime="2018-01-09T10:05:14+08:00">2018-01-09</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/01/09/minjiebaihua/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/09/minjiebaihua/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>敏捷的意思就是反应迅速，为什么要反应迅速？ 看看那么多996公司就知道了，</p>
<p>市场变化越来越快，客户要求越来越高，为了满足用户的需求，  人家一个星期发一个版本， 我们仨月才能憋出一个来 ，那还不被打的满地找牙？</p>
<p>问题是如何才能反应迅速？  先来看一个场景：</p>
<p><strong>1、残酷的现实</strong></p>
<p>软件开发有一大难题就是<strong>客户脑子中的需求难于描述出来</strong>， 我们通常的应对方法是这样：</p>
<p>先花上几个月整理需求， 天天和客户座谈， 画出几百页的流程图， 写出上千页的文档， 最后把客户都快搞晕了。</p>
<p><img src="/images/minjiebaihua/manong-minjie-1.jpg" alt="img"></p>
<p>然后是详细设计， 开发， 测试，  我们强悍的技术团队开始发动， 一切都严格按照计划进行， 一切看起来都很完美， 看来项目马上成功结束了！</p>
<p>但是客户的验收测试给了我们当头一棒： 这个界面怎么少了一个选项 ？   那个界面怎么不能跳转 ， 那个功能需要给领导一个后门， 还有， 我的业务规则怎么不能改？  什么？ 在代码中写死了？  唉，你们做的系统啊， 根本就不能用 ！</p>
<p>每个人都很郁闷， 几个月的辛苦开发看来要付诸东流了。</p>
<p>从这个场景中能看出的是， <strong>我们从客户那里得到的需求描述和需求文档， 其实离客户真正想要的软件还差的很远。</strong></p>
<p>在瀑布式的开发模式下，验收测试发现的问题，要想改正代价是非常高昂的。</p>
<p><strong>2、改进</strong></p>
<p>一个想法自然而然就浮现出来： <strong>为了避免到最后习惯性崩盘，能不能让客户经常性的做验收测试？</strong></p>
<p>让他们经常性的去使用一个可以工作的软件， 从而告诉我们那些地方还有欠缺 ？ 那些地方做错了？  这样我们可以迅速的修改， 这样我们就会轻松多了 ！</p>
<p>我们可以把软件开发划分成一个个小的开发周期， 例如每个周期就两三周时间， 在这两周之内我们完成一个或几个功能， 然后就让用户去试用， 有问题立刻反馈，在下一个开发周期马上改掉。 这样就可以逐步逼近客户的最终目标。</p>
<p>这还带来了一个额外的好处， 不用花费巨长的时间来分析，整理冗长的需求文档了。</p>
<p>听起来很美是不是？  但是仔细想想这里边的问题很多。</p>
<p><strong>1.  抛弃了冗长的需求文档， 但还是得描述需求啊</strong></p>
<p>需要发明一个简单的、主要用来促进客户和开发团队沟通的描述形式，  这个新的形式叫做用户故事， 这里有个用户故事的例子：</p>
<p><img src="/images/minjiebaihua/manong-minjie-2.jpg" alt="img"></p>
<p>这是一个卡片， 背面还会记录下针对需求的讨论和验收标准。</p>
<p>用户故事主要彰显的是： 谁做了什么事， 带来什么商业价值。</p>
<p><strong>2.  怎么决定每个小开发周期（我们称之为迭代吧）要开发的东西？</strong></p>
<p>用户故事得有估算， 得有大小， 太大了一个迭代开发不完 ， 还得拆分一下。</p>
<p>我们需要对需求按照优先级进行排序， 按照优先级从高到低的原则来开发。</p>
<p><strong>3. 不要架构设计了吗？</strong></p>
<p>一上来就按优先级选择需求， 直接进入迭代开发， 把架构师撂在一边，合适吗？</p>
<p>架构工作肯定还是需要的，在正式的迭代周期开始之前需要架构设计， 但是和设计出面面俱到的架构设计不同， 我们更需要演进式的架构， 随着迭代的推进而进化。</p>
<p><strong>4. 那详细设计怎么办？</strong></p>
<p>在每个迭代开始的时候，团队在一起把这些用户故事给拆分成一个个小的任务， 这个拆分的过程就相当于详细设计了。  对于一些特别复杂的，例如算法， 当然可以写文档，帮助大家理解。</p>
<p><strong>5. 由于是迭代式开发， 这个迭代周期修改上一个迭代周期的代码在所难免， 怎么保证不破坏原有的功能？ 总不能每次都手工重测一遍吧？</strong></p>
<p>这个绝对是一大难点， 答案就是自动化的回归测试， 包括单元测试和功能测试。</p>
<p>开发人员写代码的同时，也要写下自动化的单元测试，  测试人员需要开发自动化的功能测试， 这样一旦有了代码的修改，就可以运行它们， 检查现有功能有没有被破坏。</p>
<p>像持续集成这样的基础设施是必不可少的，  每天，每小时，甚至每次代码提交都会触发编译，打包、部署、测试这样的过程。</p>
<p><strong>6.  这么短的开发周期， 测试人员怎么测试啊？</strong></p>
<p>开发和测试需要同步进行， 当开发在澄清需求的时候， 测试需要参与， 当开发在编码的时候， 测试人员在编写测试用例，等到一个用户故事开发完，马上就可以投入测试。</p>
<p><strong>7. 看来开发、测试之间需要紧密的协作， 它们之间怎么沟通？</strong></p>
<p>肯定是面对面的沟通， 有问题就跑到对方的座位那里去问，大家的座位最好在一起， 扭头就可以讨论，  尽可能减少效率不高的电话、QQ/微信等工具的使用。</p>
<p>开发团队每天都开一个15分钟左右的站会， 展示自己的进展和计划， 让进度保持透明，  及时暴露问题，解决问题。</p>
<p><strong>8. 客户什么时候可以做验收测试？</strong></p>
<p>随时欢迎， 但是我们更倾向于迭代结束以后， 这时候功能会稳定下来， 我们会给客户做一个演示， 告诉他这个迭代完成的工作， 邀请他也测试一下软件， 给我们反馈。</p>
<p>当然客户可能会发现问题， 甚至提出新的需求， 我们表示欢迎， 我们要和客户合作，而不是对抗。</p>
<p>除了给客户演示之外，我们自己还会反思一下，看看有那些地方做的好，要继续保持；  那些地方做的不好， 要持续改进。</p>
<p>估计你也明白了，这种看起来很美的迭代化开发方法实施起来挺不容易的， 如果我们给它起个名字的话， 可以叫做：敏捷软件开发。</p>
<blockquote>
<p>原作者：码农翻身</p>
<p>原文链接：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s/tJzEQ87eaUdx7F2nR23oyw">http://mp.weixin.qq.com/s/tJzEQ87eaUdx7F2nR23oyw</a></p>
<p>码农翻身公众号由工作15年的前IBM架构师创建，分享编程和职场的经验教训。</p>
<p>码农翻身二维码：</p>
<p><img src="http://www.jizhuomi.com/upload/manongfanshen.jpg" alt="img"></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/01/07/super-powers-and-programmers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/07/super-powers-and-programmers/" class="post-title-link" itemprop="url">超能力与程序员</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-01-07 23:42:03" itemprop="dateCreated datePublished" datetime="2018-01-07T23:42:03+08:00">2018-01-07</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/01/07/super-powers-and-programmers/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/07/super-powers-and-programmers/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>原文：有没有已经被证实存在的超能力？有能够后天习得的超能力吗？</p>
<p>作者：张天一<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32235004/answer/57412334">https://www.zhihu.com/question/32235004/answer/57412334</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>there is no spoon.<br>我回来补充了！！<br>———————————乱七八糟的分割线—————————</p>
<p>知乎上一位信基督的程序员朋友说，“就好比你玩游戏，不能因为在游戏里找不到职业为程序员的 NPC，又无法用游戏中的规则造一个程序员角色出来，就说程序员是假的，因为他有可能在游戏之外的某个维度 debug 。换个说法是，游戏是虚拟的，程序员的存在才是真实。”（侵删致歉）私以为说的非常好。<br>如果代入这个理论来看的话，世界就有意思了。<br>一神教和多神教的区别就是这个世界的程序是一位程序员写的还是多位程序员写的，不同教派的区别就是因为自己所处的数据片段不一样所以脑补的神的形象也不一样。<br>还记得Neo去见先知的那个片段吗？看见那几个孩子，他们每个人都做了违反物理规律的事情，那个意念弯曲勺子的小僧侣对着他说，不要掰它，要看透它。<br>他说，“There is no spoon.”<br>很巧的是魔兽争霸3有一个作弊码，There is no spoon，输入后你的英雄魔法是无限的。<br>如果他们有自己的意识的话他们会意识到世界的规律变化了，而对你而言，你也不过是在利用代码而已。再举一个例子如Minecraft这种沙盒游戏，你可以通过合理的资源配置来完成一些科技，组成与门或门非门来完成牌子电路或者红石电路，甚至做出CPU，而有些你作弊也可以。科学就像是你在摸索mc的世界规律来完成科技，开作弊码就像是直接利用了代码的后门，“看透”了数据的本质（其实并没有真正看透，譬如你使用作弊码只是知其然不知其所以然，只能算作“使用”而非“破解”）。<br>这就是科学力量和超自然力量的关系。更直接的说，一个是掰勺子，一个是看穿勺子。两者实际上都是在“使用”它，而所谓的唯物世界不过是按照规律运行的一组数据，你可以像在mc里做电路一样发展科技，完成很厉害的事，也可以理解程序破解程序直接的为自己谋福利，两者有区别吗？有。基础一样吗？基础都是这一组数据，问题的关键是，你要怎么去理解它，使用它。你没有玩过mc做不出电路，只知道作弊码也算不得破解程序，你要发展你要趋利避害你要往好的地方走你要活着，你就要学习规律。<br>你把世界当做一个沙盒游戏，很多的哲学问题都可以迎刃而解。<br>你面前的勺子，There is no spoon.</p>
<p>（你们再说地球OL我就要报警了！！！）<br>接下来要给大家介绍一位始祖级程序员，老子。<br>以及在宗教界独树一帜的宗教，道教。<br>把上面的话替换几个字比如把规律和程序换成“道”，就基本是道门的要旨了。<br>下面的话我的评论只涉及纯粹标准的各宗教徒，个人评价无攻击意图。第一，道教确实非常奇特，第二，我对道教了解较深，所以将以道教尤其是早期道教作为一种特异的哲学和宗教现象来讨论，并非由于我是道教徒。道门独树一帜的地方就在于，别的宗教学习世界系统的程序员，我们学习这个程序的运行原理。当然，所有的宗教都引人向善给人以内心的平静，仅仅从利益角度的狭义功利主义而言，撇开信仰不提，其他的宗教大多目的都是希望通过遵从使得程序员对他们有所偏好来获得特殊的权限，而道教敬天地人神，最尊敬的就是道。理解道，参悟道，学习道，使用道，道如同涛涛江河，他们学习水流的方向和规律顺着水流游的游刃有余左右逢源，这是道教徒的本意。亚伯拉罕一神系的三大宗教犹太教伊斯兰教基督教都是一神教，即使有主神和他们的小伙伴们的故事说到底拜的还是一个神，掌管万物；佛教在入中国之前也基本算是释迦牟尼一神主万世法；希腊、美洲、北欧、玛雅那是各自神系下的神话体系，不算宗教。<br>再回头看看道教就耐人寻味起来。道教没有统领一切的神，而诸神各有职司。耐人寻味之处就在于，绝大多数的神，都是由人而化神，很少有比如火气水气之精或天地交感化而为神。现在，我们回到那个有趣的理论基础上去，即是：<br>道教徒跪拜的不是设立世界程序的程序员，而是在这个程序里生出来的AI极高高到足以看透数据世界的本质并突破了数据限制的人，并且希望学习他们。<br>这种人被称为什么呢？神？仙？<br>都不是。道教徒叫他们为，【真人】。<br>interesting.<br>非常非常有趣啊。这些人被叫做真人，那么普通人是什么？<br>脑补一下Neo突破自己然后在最后飞起来的时候，普通人的表情。于此处黑客帝国全剧终，导演给他们的表情留了白。<br>当你突破这个世界的时候，不管你能在这个世界有多么厉害，摇山撼海夸神通，目上无尘目下空，你都不会再去珍视了，因为那于你而言不过是…盒子里的世界。<br>There is no spoon.</p>
<blockquote>
<p>来源：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32235004/answer/57402579">知乎</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2017/11/26/yirenyinjiuzui/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/11/26/yirenyinjiuzui/" class="post-title-link" itemprop="url">一人饮酒醉完整歌词</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-11-26 15:45:25" itemprop="dateCreated datePublished" datetime="2017-11-26T15:45:25+08:00">2017-11-26</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/11/26/yirenyinjiuzui/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/11/26/yirenyinjiuzui/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一人我饮酒醉 醉把佳人成双对 两眼 是独相随只求他日能双归</p>
<p>娇女轻扶琴 燕嬉紫竹林 痴情红颜心甘情愿 千里把君寻.</p>
<p>说红颜我痴情笑 曲动琴声妙 我轻狂高傲懵懂无知只怪太年少</p>
<p>弃 江山 忘天下 斩断情丝无牵挂 千古留名传佳话 两年征战以白发</p>
<p>一生征战何人陪 谁是谁非谁相随 戎马一生为了谁 能爱几回恨几回 </p>
<p>败 帝王 斗苍天 夺得皇位以成仙 豪情万丈天地间 续写另类帝王篇</p>
<p>红尘事我以斩断 久经战场人心乱 当年扬名又力万 是这一战我无遗憾</p>
<p>相思 我愁断肠 眼中我泪两行 我多年为君一统天下 戎马把名扬</p>
<p>烟雨 我平凡事 此生 我怀大志 我为了家人回眸一笑立下这毒誓 </p>
<p>百花 我出芬芳 回首 我曲流觞 我回眸沧海一首忧歌感触梨花香</p>
<p>将军出征人在外 归来之日谁还在 兄弟把酒论豪迈 驰骋疆场求一败</p>
<p>这次走我何时归 寒 风起 心似灰 冷风吹起樱花飞 触景生情心伤悲</p>
<p>琴声悠悠在回荡 一首幽歌为你唱 沧海桑田难遗忘 酒醒燕归来无恙</p>
<p>百花绽放出芬芳 再次回首曲流伤 回眸感触昙花香 一首忧歌笑沧桑</p>
<p>仰望窗外烟雨朦胧 想你当初那笑容 佳人一别月下逢 牡丹花开百花丛</p>
<p>情 已过 义难断 提笔写下江山乱 孤枕难眠梦相伴 花飞花舞花飘散</p>
<p>紫金楼 风起玄 挥舞霸刀几万年 悠悠岁月心缠绵 如何忘记你容颜</p>
<p>恍然如梦烟雨间 雨碎落叶舞翩翩 烟雨飘渺断崖边 待我转世化成仙</p>
<p>为何你要说离别 留我一人寻彩蝶 浮生若梦三字决 留下三字这心结</p>
<p>这 情花 为你摘 一颗心门为你开 平凡事我了尘埃 寂寥之心谁能猜</p>
<p>一别红颜多年后 多年情 在守候 断情之曲谁人奏 思念红颜人消瘦</p>
<p>海誓山盟烟雨楼 苦苦相思两处愁 三声誓言的缘由 只因一生无所求</p>
<p>梦里梦外千百年 可曾记得那誓言 今生情 来世缘 难忘二字为红颜</p>
<p>千 百里 相思雨 相 思雨 落谷底 红尘往事梦一曲 期盼三字风云起</p>
<p>脑中浮现一幕幕 一幕幕 江湖路 谁懂我心痛苦处 三声誓言以颠覆</p>
<p>梦里 谁独相思 为何要寻一相知 梦外 我望明月 只为一人情难却</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2017/05/14/vs2017/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/14/vs2017/" class="post-title-link" itemprop="url">VS2017安装</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-05-14 15:57:12" itemprop="dateCreated datePublished" datetime="2017-05-14T15:57:12+08:00">2017-05-14</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/05/14/vs2017/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/14/vs2017/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>企业版</strong>：</p>
<p>vs_enterprise.exe –layout c:\vs2017offline</p>
<p><strong>专业版</strong>：</p>
<p>vs_professional.exe –layout c:\vs2017offline</p>
<p><strong>社区版</strong>：</p>
<p>vs_community.exe –layout c:\vs2017offline</p>
<p>企业版 Enterprise：NJVYC-BMHX2-G77MM-4XJMR-6Q8QF</p>
<p>专业版 Professional：KBJFW-NXHK6-W4WJM-CRMQB-G3CDH</p>
<blockquote>
<p>来自 <a target="_blank" rel="noopener" href="https://www.oschina.net/news/82731/vs-2017-all-version-offline-download-and-install">OSCHINA</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2017/04/10/%E4%BB%8Egitlab%E8%AF%AF%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%83%B3%E5%88%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/04/10/%E4%BB%8Egitlab%E8%AF%AF%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%83%B3%E5%88%B0%E7%9A%84/" class="post-title-link" itemprop="url">从GITLAB误删除数据库想到的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-10 13:13:00" itemprop="dateCreated datePublished" datetime="2017-04-10T13:13:00+08:00">2017-04-10</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/04/10/%E4%BB%8Egitlab%E8%AF%AF%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%83%B3%E5%88%B0%E7%9A%84/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/04/10/从gitlab误删除数据库想到的/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>昨天，Gitlab.com发生了一个大事，某同学误删了数据库，这个事看似是个低级错误，不过，因为Gitlab把整个过程的细节都全部暴露出来了，所以，可以看到很多东西，而对于类似这样的事情，我自己以前也干过，而在最近的两公司中我也见过（Amazon中见过一次，阿里中见过至少四次），正好通过这个事来说说一下自己的一些感想和观点吧。<strong>我先放个观点：你觉得有备份系统就不会丢数据了吗？</strong></p>
<h4 id="事件回顾"><a href="#事件回顾" class="headerlink" title="事件回顾"></a>事件回顾</h4><p>整个事件的回顾Gitlab.com在第一时间就放到了<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1GCK53YDcBWQveod9kfzW-VCxIABGiryG7_z_6jHdVik/pub">Google Doc上</a>，事后，又发了<a target="_blank" rel="noopener" href="https://about.gitlab.com/2017/02/01/gitlab-dot-com-database-incident/">一篇Blog</a>来说明这个事，在这里，我简单的回顾一下这个事件的过程。 首先，一个叫YP的同学在给gitlab的线上数据库做一些负载均衡的工作，在做这个工作时的时候突发了一个情况，Gitlab被DDoS攻击，数据库的使用飙高，在block完攻击者的IP后，发现有个staging的数据库(db2.staging)已经落后生产库4GB的数据，于是YP同学在Fix这个staging库的同步问题的时候，发现db2.staging有各种问题都和主库无法同步，在这个时候，YP同学已经工作的很晚了，在尝试过多个方法后，发现db2.staging都hang在那里，无法同步，于是他想把db2.staging的数据库删除了，这样全新启动一个新的复制，结果呢，删除数据库的命令错误的敲在了生产环境上（db1.cluster），结果导致整个生产数据库被误删除。（<strong>陈皓注：这个失败基本上就是 “工作时间过长” + “在多数终端窗口中切换中迷失掉了”</strong>） 在恢复的过程中，他们发现只有db1.staging的数据库可以用于恢复，而其它的5种备份机制都不可用，第一个是数据库的同步，没有同步webhook，第二个是对硬盘的快照，没有对数据库做，第三个是用pg_dump的备份，发现版本不对（用9.2的版本去dump 9.6的数据）导致没有dump出数据，第四个S3的备份，完全没有备份上，第五个是相关的备份流程是问题百出的，只有几个粗糙的人肉的脚本和糟糕的文档，也就是说，不但是是人肉的，而且还是完全不可执行的。（<strong>陈皓注：就算是这些备份机制都work，其实也有问题，因为这些备份大多数基本上都是24小时干一次，所以，要从这些备份恢复也一定是是要丢数据的了，只有第一个数据库同步才会实时一些</strong>） 最终，gitlab从db1.staging上把6个小时前的数据copy回来，结果发现速度非常的慢，备份结点只有60Mbits/S，拷了很长时间（<strong>陈皓注：为什么不把db1.staging给直接变成生产机？因为那台机器的性能很差</strong>）。数据现在的恢复了，不过，因为恢复的数据是6小时前的，所以，有如下的数据丢失掉了：</p>
<ul>
<li>  粗略估计，有4613 的项目， 74 forks,  和 350 imports 丢失了；但是，因为Git仓库还在，所以，可以从Git仓库反向推导数据库中的数据，但是，项目中的issues等就完全丢失了。</li>
<li>  大约有±4979 提交记录丢失了（陈皓注：估计也可以用git仓库中反向恢复）。</li>
<li>  可能有 707  用户丢失了，这个数据来自Kibana的日志。</li>
<li>  在1月31日17:20 后的Webhooks 丢失了。</li>
</ul>
<p>因为Gitlab把整个事件的细节公开了出来，所以，也得到了很多外部的帮助，2nd Quadrant的CTO – <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/simonat2ndquadrantdotcom">Simon Riggs</a> 在他的blog上也发布文章 <a target="_blank" rel="noopener" href="http://blog.2ndquadrant.com/dataloss-at-gitlab/">Dataloss at Gitlab</a> 给了一些非常不错的建议：</p>
<ul>
<li>  关于PostgreSQL 9.6的数据同步hang住的问题，可能有一些Bug，正在fix中。</li>
<li>  PostgreSQL有4GB的同步滞后是正常的，这不是什么问题。</li>
<li>  正常的停止从结点，会让主结点自动释放WALSender的链接数，所以，不应该重新配置主结点的 max_wal_senders 参数。但是，停止从结点时，主结点的复数连接数不会很快的被释放，而新启动的从结点又会消耗更多的链接数。他认为，Gitlab配置的32个链接数太高了，通常来说，2到4个就足够了。</li>
<li>  另外，之前gitlab配置的max_connections=8000太高了，现在降到2000个是合理的。</li>
<li>  pg_basebackup 会先在主结点上建一个checkpoint，然后再开始同步，这个过程大约需要4分钟。</li>
<li>  手动的删除数据库目录是非常危险的操作，这个事应该交给程序来做。推荐使用刚release 的 <a target="_blank" rel="noopener" href="https://www.2ndquadrant.com/en/resources/repmgr/">repmgr</a></li>
<li>  恢复备份也是非常重要的，所以，也应该用相应的程序来做。推荐使用 <a target="_blank" rel="noopener" href="https://www.2ndquadrant.com/en/resources/barman/">barman</a> （其支持S3）</li>
<li>  测试备份和恢复是一个很重要的过程。</li>
</ul>
<p>看这个样子，估计也有一定的原因是——Gitlab的同学对PostgreSQL不是很熟悉。 随后，Gitlab在其网站上也开了一系列的issues，其issues列表在这里 <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/www-gitlab-com/issues/1108">Write post-mortem</a> (这个列表可能还会在不断更新中)</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1094">infrastructure#1094</a> – Update PS1 across all hosts to more clearly differentiate between hosts and environments</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1095">infrastructure#1095</a> – Prometheus monitoring for backups</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1096">infrastructure#1096</a> – Set PostgreSQL’s max_connections to a sane value</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1097">infrastructure#1097</a> – Investigate Point in time recovery &amp; continuous archiving for PostgreSQL</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1098">infrastructure#1098</a> – Hourly LVM snapshots of the production databases</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1099">infrastructure#1099</a> – Azure disk snapshots of production databases</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1100">infrastructure#1100</a> – Move staging to the ARM environment</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1101">infrastructure#1101</a> – Recover production replica(s)</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1102">infrastructure#1102</a> – Automated testing of recovering PostgreSQL database backups</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1103">infrastructure#1103</a> – Improve PostgreSQL replication documentation/runbooks</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1104">infrastructure#1104</a> – Kick out SSH users inactive for N minutes</li>
<li>  <a target="_blank" rel="noopener" href="https://gitlab.com/gitlab-com/infrastructure/issues/1105">infrastructure#1105</a> – Investigate pgbarman for creating PostgreSQL backups</li>
</ul>
<p>从上面的这个列表中，我们可以看到一些改进措施了。挺好的，不过我觉得还不是很够。</p>
<h4 id="相关的思考"><a href="#相关的思考" class="headerlink" title="相关的思考"></a>相关的思考</h4><p>因为类似这样的事，我以前也干过（误删除过数据库，在多个终端窗口中迷失掉了自己所操作的机器……），而且我在amazon里也见过一次，在阿里内至少见过四次以上（在阿里人肉运维的误操作的事故是我见过最多的），但是我无法在这里公开分享，私下可以分享。在这里，我只想从非技术和技术两个方面分享一下我的经验和认识。</p>
<h5 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h5><p><strong>人肉运维</strong> 一直以来，我都觉得直接到生产线上敲命令是一种非常不好的习惯。我认为，<strong>一个公司的运维能力的强弱和你上线上环境敲命令是有关的，你越是喜欢上线敲命令你的运维能力就越弱，越是通过自动化来处理问题，你的运维能力就越强</strong>。理由如下： 其一，如果说对代码的改动都是一次发布的话，那么，对生产环境的任何改动（包括硬件、操作系统、网络、软件配置……），也都算是一次发布。那么这样的发布就应该走发布系统和发布流程，要被很好的测试、上线和回滚计划。关键是，走发布过程是可以被记录、追踪和回溯的，而在线上敲命令是完全无法追踪的。没人知道你敲了什么命令。 其二，真正良性的运维能力是——人管代码，代码管机器，而不是人管机器。你敲了什么命令没人知道，但是你写个工具做变更线上系统，这个工具干了什么事，看看工具的源码就知道了。 另外、有人说，以后不要用rm了，要用mv，还有人说，以后干这样的事时，一个人干，另一个人在旁边看，还有人说，要有一个checklist的强制流程做线上的变更，还有人说要增加一个权限系统。我觉得，这些虽然可以work，但是依然不好，再由如下： 其一、如果要解决一个事情需要加更多的人来做的事，那这事就做成劳动密集型了。今天我们的科技就是在努力消除人力成本，而不是在增加人力成本。而做为一个技术人员，解决问题的最好方式是努力使用技术手段，而不是使用更多的人肉手段。<strong>人类区别于动物的差别就是会发明和使用现代化的工具，而不是使用更多的人力</strong>。另外，<strong>这不仅仅因为是，人都是会有这样或那样的问题（疲惫、情绪化、急燥、冲动……），而机器是单一无脑不知疲惫的，更是因为，机器干活的效率和速度是比人肉高出N多倍的</strong>。 其二、增加一个权限系统或是别的一个watch dog的系统完全是在开倒车，权限系统中的权限谁来维护和审批？不仅仅是因为多出来的系统需要多出来的维护，关键是这个事就没有把问题解决在root上。除了为社会解决就业问题，别无好处，故障依然会发生，有权限的人一样会误操作。对于Gitlab这个问题，正如2nd Quadrant的CTO建议的那样，你需要的是一个自动化的备份和恢复的工具，而不是一个权限系统。 其三、像使用mv而不rm，搞一个checklist和一个更重的流程，更糟糕。这里的逻辑很简单，因为，1）这些规则需要人去学习和记忆，本质上来说，你本来就不相信人，所以你搞出了一些规则和流程，而这些规则和流程的执行，又依赖于人，换汤不换药，2）另外，<strong>写在纸面上的东西都是不可执行的，可以执行的就是只有程序，所以，为什么不把checklist和流程写成代码呢</strong>？（你可能会说程序也会犯错，是的，程序的错误是consistent，而人的错误是inconsistent） 最关键的是，<strong>数据丢失有各种各样的情况，不单单只是人员的误操作，比如，掉电、磁盘损坏、中病毒等等，在这些情况下，你设计的那些想流程、规则、人肉检查、权限系统、checklist等等统统都不管用了，这个时候，你觉得应该怎么做呢？是的，你会发现，你不得不用更好的技术去设计出一个高可用的系统！别无它法。</strong></p>
<h4 id="关于备份"><a href="#关于备份" class="headerlink" title="关于备份"></a>关于备份</h4><p>一个系统是需要做数据备份的，但是，你会发现，<strong>Gitlab这个事中，就算所有的备份都可用，也不可避免地会有数据的丢失，或是也会有很多问题</strong>。理由如下： 1）备份通常来说都是周期性的，所以，如果你的数据丢失了，从你最近的备份恢复数据里，从备份时间到故障时间的数据都丢失了。 2）备份的数据会有版本不兼容的问题。比如，在你上次备份数据到故障期间，你对数据的scheme做了一次改动，或是你对数据做了一些调整，那么，你备份的数据就会和你线上的程序出现不兼容的情况。 3）有一些公司或是银行有灾备的数据中心，但是灾备的数据中心没有一天live过。等真正灾难来临需要live的时候，你就会发现，各种问题让你live不起来。你可以读一读几年前的这篇报道好好感受一下《<a target="_blank" rel="noopener" href="http://finance.sina.com.cn/money/bank/20140804/091219903553.shtml">以史为鉴 宁夏银行7月系统瘫痪最新解析</a>》 所以，在灾难来临的时候，你会发现你所设计精良的“备份系统”或是“灾备系统”就算是平时可以工作，但也会导致数据丢失，而且可能长期不用的备份系统很难恢复（比如应用、工具、数据的版本不兼容等问题）。 我之前写过一篇《<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/10910.html">分布式系统的事务处理</a>》，你还记得下面这张图吗？看看 Data Loss 那一行的，在Backups, Master/Slave 和 Master/Master的架构下，都是会丢的。 所以说，<strong>如果你要让你的备份系统随时都可以用，那么你就要让它随时都Live着</strong>，而随时都Live着的多结点系统，基本上就是一个分布式的高可用的系统。因为<strong>，数据丢失的原因有很多种，比如掉电、磁盘损坏、中病毒等等，而那些流程、规则、人肉检查、权限系统、checklist等等都只是让人不要误操作，都不管用，这个时候，你不得不用更好的技术去设计出一个高可用的系统！别无它法。（重要的事，得再说一篇）</strong> 另外，你可以参看我的另一篇《<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/17459.html">关于高可用系统</a>》，这篇文章中以MySQL为例，数据库的replication也只能达到 两个9。 <strong>AWS 的 S3 的的高可用是4个加11个9的持久性（</strong>所谓11个9的持久性durability，AWS是这样定义的，如果你存了1万个对象，那么丢一个的时间是1000万年<strong>），这意味着，不仅仅只是硬盘坏，机器掉电，整个机房挂了，其保证可以承受有两个设施的数据丢失，数据还是可用的。试想，如果你把数据的可用性通过技术做到了这个份上，那么，你还怕被人误删一个结点上的数据吗？</strong></p>
<h5 id="非技术方面"><a href="#非技术方面" class="headerlink" title="非技术方面"></a>非技术方面</h5><p><strong>故障反思</strong> 一般说来，故障都需要反思，在Amazon，S2以上的故障都需要写COE（Correction of Errors），其中一节就是需要Ask 5 Whys，我发现在Gitlab的故障回顾的blog中第一段中也有说要在今天写个Ask 5 Whys。关于Ask 5 Whys，其实并不是亚马逊的玩法，这还是算一个业内常用的玩法，也就是说不断的为自己为为什么，直到找到问题的概本原因，这会逼着所有的当事人去学习和深究很多东西。在Wikipedia上有相关的词条 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/5_Whys">5 Whys</a>，其中罗列了14条规则：</p>
<ol>
<li> 你需要找到正确的团队来完成这个故障反思。</li>
<li> 使用纸或白板而不是电脑。</li>
<li> 写下整个问题的过程，确保每个人都能看懂。</li>
<li> 区别原因和症状。</li>
<li> 特别注意因果关系。</li>
<li> 说明Root Cause以及相关的证据。</li>
<li> 5个为什么的答案需要是精确的。</li>
<li> 寻找问题根源的步骤，而不是直接跳到结论。</li>
<li> 要基础客观的事实、数据和知识。</li>
<li> 评估过程而不是人。</li>
<li> 千万不要把“人为失误”或是“工作不注意”当成问题的根源。</li>
<li> 培养信任和真诚的气氛和文化。</li>
<li> 不断的问“为什么”直到问题的根源被找到。这样可以保证同一个坑不会掉进去两次。</li>
<li> 当你给出“为什么”的答案时，你应该从用户的角度来回答。</li>
</ol>
<p><strong>工程师文化</strong> 上述的这些观点，其实，我在我的以住的博客中都讲过很多遍了，你可以参看《<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/17497.html">什么是工程师文化？</a>》以及《<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/11656.html">开发团队的效率</a>》。其实，说白了就是这么一个事——<strong>如果你是一个技术公司，你就会更多的相信技术而不是管理。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题</strong>。 这个道理很简单，<strong>数据丢失有各种各样的情况，不单单只是人员的误操作，比如，掉电、磁盘损坏、中病毒等等，在这些情况下，你设计的那些流程、规则、人肉检查、权限系统、checklist等等统统都不管用，这个时候，你觉得应该怎么做呢？是的，你会发现，你不得不用更好的技术去设计出一个高可用的系统！别无它法。（重要的事得说三遍）</strong> <strong>事件公开</strong> 很多公司基本上都是这样的套路，首先是极力掩盖，如果掩盖不了了就开始撒谎，撒不了谎了，就“文过饰非”、“避重就轻”、“转移视线”。然而，面对危机的最佳方法就是——“多一些真诚，少一些套路”，<strong>所谓的“多一些真诚”的最佳实践就是——“透明公开所有的信息”</strong>，Gitlab此次的这个事给大家树立了非常好的榜样。AWS也会把自己所有的故障和细节都批露出来。 <strong>事情本来就做错了，而公开所有的细节，会让大众少很多猜测的空间，有利于抵制流言和黑公关，同时，还会赢得大众的理解和支持</strong>。看看Gitlab这次还去YouTube上直播整个修复过程，是件很了不起的事，大家可以到他们的blog上看看，对于这样的透明和公开，一片好评。 （全文完）</p>
<blockquote>
<p>来源：<a target="_blank" rel="noopener" href="http://coolshell.cn/articles/17680.html">酷壳</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2017/01/13/%E9%9B%85%E8%99%8E%E5%87%BA%E5%94%AE%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E5%90%8E%E5%B0%86%E6%9B%B4%E5%90%8D%E4%B8%BAaltaba/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/01/13/%E9%9B%85%E8%99%8E%E5%87%BA%E5%94%AE%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E5%90%8E%E5%B0%86%E6%9B%B4%E5%90%8D%E4%B8%BAaltaba/" class="post-title-link" itemprop="url">雅虎出售核心业务后将更名为Altaba</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-01-13 18:10:49" itemprop="dateCreated datePublished" datetime="2017-01-13T18:10:49+08:00">2017-01-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/01/13/%E9%9B%85%E8%99%8E%E5%87%BA%E5%94%AE%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E5%90%8E%E5%B0%86%E6%9B%B4%E5%90%8D%E4%B8%BAaltaba/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/01/13/雅虎出售核心业务后将更名为altaba/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>阿里他爸？</p>
</blockquote>
<p>旧金山——雅虎(Yahoo)或将自己的互联网业务以48亿美元的价格卖给威瑞森通讯公司(Verizon Communications)，这笔交易的命运可能尚不确定。但是如果它成为现实，雅虎亦为公司剩下的业务做好了计划。</p>
<p>周一，该公司在一份监管备案文件中称，交易完成后，它将更名为Altaba。</p>
<p>此外，该公司目前半数以上的董事会成员将退出，包括首席执行官玛丽莎·梅耶尔(Marissa Mayer)在内。</p>
<p>为什么叫Altaba呢？</p>
<p>如果与威瑞森公司的交易能够完成，雅虎所剩的最大单笔资产就是在中国电子商务巨头阿里巴巴公司(Alibaba)所持的15%股份，Altaba这个名字其实就是在“阿里巴巴”的基础上稍作修改。Altaba还将持有雅虎日本35.5%的股份（雅虎的一名发言人拒绝作出评论）。</p>
<p>不过，Altaba当然是一个不同寻常的名字。它碰巧还很接近Al-Taba，那是巴基斯坦的一家剪刀制造公司的名字。</p>
<p>该公司在监管备案文件中称，更名后仍将留下的董事包括帮助推动公司改革的激进投资人杰弗里·史密斯(Jeffrey Smith)；前投资银行家托尔·布雷厄姆(Tor Braham)和凯瑟琳·J·弗里德曼(Catherine J. Friedman)；芯片制造公司博通(Broadcom)的前首席财务官埃里克· 勃兰特(Eric Brandt)；以及媒体公司IAC的前首席财务官托马斯·麦金纳尼(Thomas McInerney)。</p>
<p>即将退位的董事包括梅耶尔；雅虎董事长梅纳德·韦伯(Maynard Webb)；以及雅虎创始人之一大卫·费罗(David Filo)。韦伯将成为更名后的Altaba的荣退主席。</p>
<p>当然，所有这些变化取决于雅虎能否真的把自己最重要的互联网业务卖给威瑞森，要知道，雅虎曾两次遭遇黑客袭击，导致信息泄露，第二次袭击影响了10多亿用户的帐户。</p>
<p>威瑞森的高管曾公开表示，他们在权衡自己的选择，包括支付的金额可能会少于已达成一致的48亿美元。上周，威瑞森的产品创新和新业务主管玛妮·沃尔登(Marni Walden)在谈起这项交易的命运时说，“今天，我不能坐在这里确定地说会发生什么，因为我们还不知道。”</p>
<p>不过，隶属于威瑞森的美国在线(AOL)的首席执行官蒂姆·阿姆斯特朗(Tim Armstrong)在接受<a target="_blank" rel="noopener" href="http://www.cnbc.com/2017/01/05/aol-chief-tim-armstrong-says-hes-confident-vz-yhoo-deal-will-close.html">CNBC</a>采访时称，他感到乐观。</p>
<p>“我依然对达成这项交易充满希望，我觉得，与此同时，我们会看看雅虎调查的结果，”他说。</p>
<blockquote>
<p>来源：<a target="_blank" rel="noopener" href="http://cn.nytstyle.com/technology/20170111/yahoo-would-become-altaba-after-selling-its-internet-business/">纽时中文</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2012 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">时空</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"stx8","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js" defer></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.stx8.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="时空主站">
<meta property="og:type" content="website">
<meta property="og:title" content="时空主站">
<meta property="og:url" content="http://www.stx8.com/page/2/index.html">
<meta property="og:site_name" content="时空主站">
<meta property="og:description" content="时空主站">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="时空">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.stx8.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>时空主站</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90761248-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-90761248-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">时空主站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">嗨，我是时空，一名来自中国的开发者。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-我的软件"><a href="/tags/%E6%88%91%E7%9A%84%E8%BD%AF%E4%BB%B6/" rel="section"><i class="fa fa-desktop fa-fw"></i>我的软件</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-开源博客"><a href="https://my.oschina.net/wudimenghuan" rel="noopener" target="_blank"><i class="fa fa-code fa-fw"></i>开源博客</a></li><li class="menu-item menu-item-pgp"><a href="/pgp/" rel="section"><i class="fa fa-key fa-fw"></i>PGP</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">时空</p>
  <div class="site-description" itemprop="description">时空主站</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2019/03/17/piano-study-order/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/17/piano-study-order/" class="post-title-link" itemprop="url">piano-study-order</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-17 17:37:06" itemprop="dateCreated datePublished" datetime="2019-03-17T17:37:06+08:00">2019-03-17</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019/03/17/piano-study-order/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/03/17/piano-study-order/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>钢琴教学可分为<strong>启蒙，初级，中级和高级</strong>四个阶段，各阶段的学习内容通常包括<strong>基本练习，练习曲，复调作品，乐曲</strong>几大类。作为基础练习，目前仍然是车尔尼的作品最为系统，如《钢琴初步教程》599，《24首左手练习》718，《钢琴流畅练习曲》849，《钢琴快速练习曲》299，《钢琴练习曲50首》740等。</p>
<p><img src="/images/piano-study-order/clip_image001.jpg" alt="车尔尼"></p>
<p>车尔尼是19世纪上半叶维也纳钢琴演奏学派的代表人物，他所写的大量练习曲是针对古典作品演奏技术，即“古典技术”训练的，主要是<strong>手指的颗粒、均匀、快速，对左手的训练较为薄弱，</strong>因此期间必须增加各类作曲家的练习曲目作为补充。这些教材可以根据学生的实际情况，有针对性地选择，穿插进行，不能一味的依次一条条的弹下去。</p>
<p><strong>儿童的启蒙阶段</strong></p>
<p>在目前较流行的儿童启蒙教材中大致可分为<strong>三种五线谱入门型</strong>，即<strong>高音谱表入门法，中央c入门法，多音入门法</strong>。传统的启蒙教材《拜尔钢琴基本教程》用的就是高音谱表入门法，目前在国内广泛应用的《汤普森浅易钢琴教程》1-5册用的是中央c入门法。</p>
<p><strong>李斐岚，董钢锐编著的《幼儿钢琴教程》</strong>采用了以中央c为主的入门法，突破了以往此类教材的音域局限，从3指开始学重量落下，逐步扩大到其余各个手指的方法已被公认为最好的方法。</p>
<p><strong>冯·德·魏尔德：《陶梅格·露丝》系列</strong>。这一幼儿系列较注意引起幼儿的兴趣，从小培养他们具有良好的乐感。</p>
<p><strong>柯达依：《钢琴学校》第一册。</strong></p>
<p><strong>巴托克：《小宇宙》</strong>。这是一本非常重要的入门课本。因为它的五指位置包括种种非大调或小调结构的五指排列，有助于学生及早接触黑键及各种调式，含有许多复调模仿级对位因素。</p>
<p><strong>齐格勒：《钢琴教本》第一册</strong>。该书的特点是先听后弹，耳朵领先。</p>
<p><strong>勋格勒：《钢琴教室》第一册。</strong></p>
<p><strong>狄贝阿里：《二十八首联弹练习曲》</strong>中较容易的，越早让学生进行四首联弹训练，越有利于养成用耳朵听辨声部与互相配合的习惯。</p>
<p><strong>钢琴教学的初级阶段</strong></p>
<p><strong>一、钢琴教学初级阶段的练习曲。</strong>这个阶段的学习内容相当于从车尔尼的《钢琴初步教程》599到车尔尼的《钢琴流畅练习曲》849。</p>
<p><strong>1、车尔尼的《钢琴初步教程》599</strong></p>
<p>这是我国钢琴初级阶段教学运用极为广泛的教材之一。全书可分为三个部分。第一部分是57首以前这部分是巩固手型，训练手指独立性的练习，要求弹奏放松、自然、练习速度以慢速中速为主。</p>
<p>第二部分是58<del>79首。58首到70首是训练快速练习，这里的快速是针对前阶段而言的，在学生奏法正确的基础上要求初步加快速度。71首</del>79首是带装饰音与不带装饰音的旋律练习。练习时先慢速，把节奏弹准确，弹平均，双手对齐，在稍微加快。这部分又是旋律练习要注意乐谱上的表情术语及力度术语，注意分句、呼吸、旋律的连贯与歌唱。</p>
<p>第三部分是80首到结束，是综合性的练习，无论音型、节奏型、音阶琶音类和双音练习都比前面丰富，练习时不仅要弹准确，还要注意音乐起伏，做出力度，速度变化。</p>
<p><strong>2、车尔尼《钢琴简易练习曲》139</strong></p>
<p>这是从599过渡到849的教材之一。139的教材编排不如599集中，可以选择与599不同类型的曲目。在599到50首左右就可以交叉使用。</p>
<p><strong>3、车尔尼《24首钢琴左手练习曲》718</strong></p>
<p>这是全部为左手而写的练习，内容有音阶，琶音型、五指型、分解和弦等，学习顺序要灵活掌握，对于手小的学生，可以先学音阶型或五指型的曲目，八度练习暂缓。</p>
<p><strong>4、车尔尼《160首八小节钢琴练习曲》821</strong></p>
<p>本教材不仅技术类型较丰富，而且难度跨度大，包含了从初级程度到高级程度的练习。每一首只有8小节，技术课题非常集中，尤其适合一些其他课业多，练习时间较少的学生使用。</p>
<p><strong>5、莱蒙《钢琴练习曲》37（又译为“勒穆瓦纳”）</strong></p>
<p>全书共50首，由浅入深。他的特点是较多的左手练习，双手比较均衡。可以弥补车尔尼练习曲中偏重右手的不足之处。</p>
<p><strong>6、布格缪勒《简易练习曲25首》100，《练习18首》109</strong></p>
<p>这两集练习曲都是有标题的小曲，形象鲜明，手法简洁，旋律优美动听，音乐性较强，非常适合初学者学习。在599到50首左右时，可以逐步选用作品100的曲目。</p>
<p>作品109在技术上比作100难，篇幅也大些。在进入车尔尼的849后可以选用。</p>
<p><strong>7、车尔尼的《流畅练习曲》849</strong></p>
<p>从599到849是初级阶段的前期进入到初级阶段的后期。849共30首，每一首的技术内容基本上不重复。在选用时要具体分析每首练习的难点，考虑技术的“过渡”问题。</p>
<p>849与599，139不同之处是每首曲子有了速度标记，根据849教材的标题，应当做到演奏流畅，尽可能按要求的速度去弹，为下一步中级阶段做准备。</p>
<p><strong>8、赫尔契伯格编《趣味钢琴技巧》</strong></p>
<p>从预备到第五册，由浅入深。编者从几十位作曲家的作品中选择了一些旋律优美而短小的练习曲，每首都有标题，并在标题下给予明确的提示和要求。技术类型比较全面，又由于作曲家各自不同的风格特点，因此，曲目丰富多彩，是一套生动有效的教材。</p>
<p><strong>二、初级阶段的复调</strong></p>
<p>复调作品的特点，是左右手不同声部、不同旋律同时进行，在节奏、重音、力度、句法、旋律、起伏等方面既有内在的联系，又各自独立。对于训练大脑的多维思维，节奏感、左右手的独立性等都是很好的教材。</p>
<p><strong>1、巴赫《初步钢琴曲集》</strong></p>
<p>这本教材共28首，是巴赫为其妻子安娜·玛格达蕾娜写的练习小曲，是初级阶段必学的内容。</p>
<p><strong>2、巴赫《小前奏曲与赋格曲》</strong></p>
<p>这是适用于巴赫《钢琴初步曲集》与《创意曲集》之间的教材。</p>
<p><strong>3、中国作品</strong></p>
<p>中国作品中有一些较简单的复调作品，采用了广大群众熟悉的民歌作为主题，比如王震亚的《沂蒙山小调》，陈静荠的《浏阳河》，黎英海的《盼红军》、《花鼓调》、陈铭志的《子弟兵与老百姓》等。</p>
<p><strong>三、钢琴初级阶段的乐曲</strong></p>
<p><strong>1、汤普森《现代钢琴教程》</strong></p>
<p>这是一套内容极为丰富的教材，由浅入深共五册。除了简易的钢琴曲外，还精选了大量歌剧、芭蕾舞剧、交响乐等世界名曲的改编曲，其中包括巴赫、莫扎特、贝多芬、肖邦、李斯特等著名音乐家的经典作品。在每首作品前，或介绍作曲家，或介绍乐曲特点，或讲解音乐常识，或指出练习要点，使学生在学每一首曲子的同时，获得更多的知识，提高音乐素养。由于乐曲形象生动，深受学生的喜爱。</p>
<p><strong>2、威尔《世界儿童钢琴名曲集》</strong></p>
<p>这是一本深受国内外儿童喜爱的曲集，其中都是简化了的世界名曲，在训练技术的同时，培养学生对音乐的感受和表达能力。</p>
<p><strong>3、《钢琴小奏鸣曲大全》</strong></p>
<p>小奏鸣曲是我国钢琴教学中运用较为广泛的内容之一。这本大全收入了海顿、克列门第、库劳、莫扎特、杜舍克、贝多芬、迪亚贝里、卡巴列夫斯基、格季凯等大师的小奏鸣曲共48首。程度相当于599后部，849前部到299。</p>
<p><strong>4、《少年儿童钢琴曲选》（1949~1979）</strong></p>
<p>1979年，为了展现建国30周年我国音乐创作的成就，中国音乐家协会在国庆前选编出版了两套中国作品集，这本《曲选》是器乐作品选中的少年儿童钢琴曲专辑。</p>
<p><strong>5、中国风格《儿童钢琴曲选》</strong></p>
<p>由人民音乐出版社编辑部编的，这本曲集共91首，是适合启蒙阶段程度的小曲。</p>
<p><strong>6、少年儿童《钢琴四首联弹曲集》</strong></p>
<p>四首联弹是一种非常好的教学形式，可以训练学生的听觉与合作能力。并且因为四只手弹比两只手弹更丰富，能提高学生的学习兴趣与练习的积极性。本曲集所选的19首曲子，都是以儿童熟悉的歌曲及乐曲改编而成的。</p>
<p>乐曲的范围很广，相应的教材也很多，如柴可夫斯基的《少年钢琴曲集》舒曼的《儿童组曲》《少年曲集》。全音乐谱出版社出版的《您喜爱的钢琴百曲集》第1、2集（共6集），中央音乐学院钢琴系编的《少年儿童外国钢琴曲选》第1、2集，（共6集），都可以广泛的选用。</p>
<p><strong>钢琴教学的中级阶段</strong></p>
<p>钢琴教学的中级阶段是一个比较长的阶段，其中车尔尼《钢琴快速练习曲》作品299程度与车尔尼《钢琴练习曲50首》作品740程度可视为两个台阶。从车尔尼《钢琴流畅练习曲》作品849过渡到299，再从299进入740，中间必须穿插根中各样的练习曲目作为铺垫，特别是740，技术课题很多，无论难度、速度、都不是那么容易掌握的。</p>
<p>这个阶段要进一步加强手指的独立性与灵活性，使手指能快速、均匀、有力地跑动；学习不同的触键，增强指尖的灵敏度，弹奏出不同层次的音色变化；进一步训练手指、手腕、手臂三者的相互配合，逐步掌握各种专门技术。随着技术的提高，曲目范围的扩大，要学习掌握不同时期作品的风格，重视音乐表达能力的培养，在演奏中恰当的运用这些技术来表现音乐。</p>
<p><strong>一、钢琴教学中级阶段的练习曲</strong></p>
<p><strong>1、车尔尼《25首钢琴小手练习曲》748</strong></p>
<p>对于达到中级程度，而手还小的学生来说，这本教材非常适宜，因为曲目中双音最大的跨度为7度。比起车尔尼其他一些简易练习曲来748增加了左手练习，音乐性也更强。</p>
<p><strong>2、车尔尼《钢琴手指灵巧的初步练习曲》636</strong></p>
<p>这是一本比较机械的练习曲集。共24首，每首的篇幅较小可以把它作为进入299的快速练习准备。</p>
<p><strong>3、车尔尼《160首八小节钢琴练习曲》821</strong></p>
<p>初级阶段中已作了介绍，此阶段可在第2、3集里适当选用。</p>
<p><strong>4、车尔尼《钢琴快速练习曲》299</strong></p>
<p>这是本阶段主要教材之一。全书共40首，分为4集，每集10首。学习时应当根据学生的实际情况和不同阶段又针对地加以选择，不要机械的一条条顺着弹。练习299时要在读谱仔细、方法正确、弹奏熟练的基础上加快速度，力求手指颗粒感、清晰度、均匀有力的基本技术都有明显提高。同时，特别要注意训练快速跑动中有意识地训练手腕、手臂与手指的配合。</p>
<p><strong>5、克拉莫《60首钢琴练习曲》</strong></p>
<p>本书注重同时发展左右手的技术，每一首篇幅不大，技术类型集中，包括各种单音、双音、保留音的练习。全书一半以上都是以一种技术类型，分别在左右手训练，为左右手的手指独立性、颗粒性、准确性、灵敏性和加强手指力量的训练提供了更大的可能。</p>
<p><strong>6、车尔尼《钢琴练习曲50首》740</strong></p>
<p>这是中级阶段最高的程度，这本练习曲包含了各种基本技术和专门技巧。在练740时，除了正确熟练等基本要求外，速度上一定要突破。这是，一首练习曲不是短期能完成的往往需要一至两个月或更长的时间。要讲究练习方法，高标准，反复练，使技术有一个飞跃。如果能够将740中的各种技术类型的练习曲都演奏得很出色的话，就能顺利地进入高级阶段的学习。</p>
<p><strong>二、钢琴教学的中级阶段复调作品</strong></p>
<p>以巴赫的《创意曲集》为主，同时可以学习《法国组曲》以及部分《平均律钢琴曲集》作品。</p>
<p><strong>1、《创意曲集》</strong></p>
<p>分二声部与三声部，各15首。学习二声部创意曲，可以选音符与节奏都稍微简单些得先练，如1、4、8、13。</p>
<p>比起二声部三声部的要难得多。首先要抓住主题，脑子里对三个声部的进行要很清楚，然后手指要控制好不同声部的力度对比和音色对比。可以先练6、2、7、1、15。</p>
<p><strong>2、《法国组曲》</strong></p>
<p>这是巴赫于1720年~1724年间完成的古组曲题材的作品，共六组。他的基本结构是由四首速度和节拍不同的舞曲，按一定顺序组成，这四种舞曲是阿列曼德、库朗特、萨拉班德和基格，他们的调性统一每一组前三首的顺序是固定不变的，而在萨拉班德与基格之间，则可插入“小步舞曲”、“旋律”、“加伏特”等其他舞曲或乐曲。这六组中唯一不同的是第四组，在阿列曼德前面多了一首前奏曲。据说“法国组曲”这个名称不是巴赫本人所提，是因为作品的典雅风格类似法国风味而得。</p>
<p><strong>3、巴赫《平均律钢琴曲集》</strong></p>
<p>平均律是一种调律方法，简而言之，就是将8度音程平均分为十二个半音。在巴赫的时代，所使用的调律法基本上是纯律，这很不利于转调，虽然平均律的调律法曾被提出，但直到巴赫才真正运用。《平均律钢琴曲集》的标题用巴赫亲自题的。</p>
<p>《平均律钢琴曲集》共两集，每集24首，是根据十二个半音的规律，由c大调开始，依次以半音进行，每个音用大，小调分别写一字前奏曲与赋格曲，故24首。这部巨著式复调音乐创作的顶峰，被誉为钢琴音乐的“圣经”——“旧约圣经”。</p>
<p><strong>三、钢琴教学的中级阶段的乐曲</strong></p>
<p><strong>1、莫扎特《钢琴奏鸣曲集》</strong></p>
<p>莫扎特一生创作出版了20首钢琴奏鸣曲，在他全部钢琴音乐创作中占有重要位置，也是钢琴教学中学习古典时期音乐的重要教材。</p>
<p>莫扎特的钢琴奏鸣曲多数由三个乐章组成，因各乐章的程度并不完全一致，学习可以先练习技术上音乐上较容易的乐章，最后再练习全部乐章，学习大型作品的整体把握。</p>
<p><strong>2、肖邦的《圆舞曲集》</strong></p>
<p>肖邦的圆舞曲创作从他的学生时代开始，一直延续到生命的最后。圆舞曲在肖邦的全部创作中，虽然不像波洛涅兹舞曲和玛祖卡舞曲那样重要，但却以通俗、华丽的织体，优美、动人的旋律和激昂、振奋的节奏深受钢琴音乐爱好者的青睐。</p>
<p><strong>3、肖邦的《夜曲》</strong></p>
<p>肖邦的夜曲是一种独放异彩的钢琴体裁，情感充实、思想丰富、织体多彩，是肖邦如诗的音乐的集中体现。学习肖邦的夜曲是学会让钢琴歌唱的最有效的途径。</p>
<p><strong>4、格里格《抒情钢琴小品》</strong></p>
<p>挪威作曲家格里格的《抒情小品》共10集，人民音乐出版社的曲集是从这十集里精选出来的。</p>
<p><strong>5、门德尔松《无词歌》</strong></p>
<p>门德尔松共写了49首无词歌，书中收入的是48首，分为8集，每集6首。乐曲充满了清新、优雅抒情的气息，时而轻快活泼、时而优美秀丽，时而哀怨忧伤。这是一本丰富多彩的、如歌谣般的钢琴曲集。</p>
<p><strong>6、舒伯特的《即兴曲》</strong></p>
<p>舒伯特的《即兴曲》共8首。作品90和作品142各4首。他的作品旋律流畅，和声运用自由，转调特别多，常用的有作品90之2、之4。作品142之2、之3、之4。</p>
<p><strong>7、柴科夫斯基《四季》</strong></p>
<p>这是作曲家受彼得堡一家杂志之约，按月为该杂志刊登的12首诗所写的钢琴独奏曲。每一首都有标题，最著名的是六月—–《船歌》和十一月—–《雪橇》。</p>
<p>中级程度前期可选学四月—–《松雪草》、五月——《清静之夜》、三月——《云雀之歌》，后期可选六月—–《船歌》、十月——《秋之歌》、十一月——-《雪橇》几首。</p>
<p><strong>8、贝多芬《钢琴奏鸣曲集》</strong></p>
<p>贝多芬共写了32首钢琴奏鸣曲，被称为钢琴音乐的“新约全书”，是学习古典音乐的必修教材。贝多芬的钢琴奏鸣曲分为3个时期，1794年<del>1800年创作的13首是第一时期，为早期风格；1801年</del>1804年是第二时期，也是作曲家创作的全盛时期，共有14首；最后五首尾晚期作品。中级阶段主要学习第一时期的奏鸣曲，也可以选用一些第二时期的作品练习。</p>
<p><strong>9、魏廷格主编的《中国钢琴名曲曲库》</strong></p>
<p>中国钢琴作品创作的历史虽不长，但是从我国第一首钢琴曲——赵元任先生1915年创作的《和平进行曲》到现在，特别是70年代以后，出现了大批好作品。由魏廷格、李明俊、许明共同编订，由我国著名音乐家贺绿汀提名这套“曲库”是我国第一套比较系统，内容丰富的中国钢琴曲集，一共4卷，95部作品（其中包括组曲），可供独奏选用的140多首。</p>
<p>以上介绍的是专辑，另外，在一些综合曲选中也有不少好的曲目，如人民音乐出版社编的《外国钢琴曲选》（一）中，贝多芬的《六首变奏曲》，博姆《喷泉》；《曲选》（二）中亨德尔的《快乐的铁匠》；曲选（三）中莫扎特的《d小调幻想曲》以及德彪西钢琴曲选中的《阿拉伯风格曲》二首及《月光》。</p>
<p><strong>钢琴教学的高级阶段</strong></p>
<p>如果说钢琴的初级阶段我们侧重于手指技能的训练，学习和掌握各类基本弹奏技术，那么，随着学习的深入，程度的提高，更要注意培养对音乐的理解能力和表达能力。高级阶段的重点应当是在音乐的表现上，从乐曲中学技术，用技术表现音乐。</p>
<p>这个阶段应广泛地接促各种风格、各种类型的作品，扩大曲目范围。</p>
<p><strong>一、钢琴教学高级阶段的练习曲</strong> </p>
<p><strong>1、莫什科夫斯基《钢琴技巧练习曲》作品72</strong></p>
<p>N·莫什科夫斯基（1854~1925）波兰钢琴家、作曲家、教育家。</p>
<p>经过中级阶段大量的、比较机械的、纯技术性的训练以后，要进入高级阶段，莫什科夫斯基《钢琴技巧练习曲15首》作品72是一个非常好的过渡。它既有相应的难度，又有较强的音乐性，在练习这些曲子是，尤其要注意句子的长线条进行，音乐起伏、均匀而流畅。</p>
<p><strong>2、莫谢莱斯《钢琴练习曲24首》作品70</strong></p>
<p>L·莫谢莱斯（1794~1870）捷克-德国钢琴家、作曲家、杰出的钢琴教师。</p>
<p>莫谢莱斯《钢琴练习曲24首》作品70乐谱的序言里指出:”作者的初衷不在培养完美的机械的技能，而在倾诉演奏之想象，使他善于处理明、暗细腻层次。。。。”，并且指出四个要点“指触”的说明；连奏奏法；遵照节拍演奏；练习的正确方法。</p>
<p>24首练习的技术课题，几乎都是不同的，最后一首还采用了序曲与赋格的写法。作者在每首练习前都注明了具体的要求和方法。练习之前应当仔细的阅读，学习过程中努力去领会和掌握。</p>
<p><strong>3、克列门蒂《钢琴练习曲选29首》</strong></p>
<p>M·克列门蒂（1752~1832）意大利作曲家、钢琴家。</p>
<p>克列门蒂《钢琴练习曲选29首》又称“名手之道”，“艺术津梁”、“通向艺术的阶梯”。是波兰作曲家陶西格从克列门蒂的100首练习曲中精选的。</p>
<p>作为高难度的练习，克列门蒂的这一教材值得推荐。虽然有不少仍然是技巧性的，但是，对于进一步提高手指对各种技术的适应能力是有效的。特别要指出的是：</p>
<p>①乐谱上每一首练习都标明指法，演奏时应当很好地去研究，有些指法对于手的自然状态或习惯用法来说比较别扭，但作为练习必须这样做。</p>
<p>②在第1、3、4、5、8、9、15、17、18、19、20、26、28、29中，作者都注明了具体的练习方法和要求，应当严格去做。</p>
<p><strong>4、凯斯勒《钢琴练习曲15首》作品20</strong></p>
<p>J·凯斯勒（1800~1870）德国钢琴家。凯斯勒《钢琴练习曲15首》作品20是从他全部练习曲中精选出来的重要部分，是训练高难度技巧的专门练习。</p>
<p><strong>5、车尔尼《160首8小节钢琴练习曲》作品821的第三集（部分）第四集</strong></p>
<p><strong>6、肖邦《练习曲集》作品10、作品25</strong></p>
<p><strong>7、李斯特音乐会练习曲</strong>两首之一《森林的呼啸》，之二《侏儒舞》，三首音乐会练习曲之3《叹息》等。</p>
<p><strong>8、李斯特《帕格尼尼练习曲》</strong> </p>
<p><strong>9、拉哈马尼诺夫《钢琴音画练习曲》作品33、作品39</strong></p>
<p><strong>10、德彪西《12首练习曲》</strong></p>
<p><strong>11、斯克里亚宾《钢琴练习曲》</strong></p>
<p><strong>二、钢琴教学高级阶段的复调</strong></p>
<p><strong>1、巴赫《英国组曲》</strong></p>
<p>与《法国组曲》的标题一样，《英国组曲》并非巴赫所订名，有人说是受英国人之托而写，为英国人而作，应此得名，也有说是受英国作曲家的影响，以他们的模式来创作的。</p>
<p>《英国组曲》也是属于“古组曲”体裁，由四种基本舞曲组成，在萨拉班德和几个之间仍然可插入各种舞曲。“英国组曲”与“法国组曲”最大的区别在于“英国组曲”的开头都有一篇篇幅较大的前奏曲，而且，在组曲中占了重要地位，确切的说《英国组曲》应当称为“带前奏曲的组曲”，共有六组。</p>
<p><strong>2、巴赫《帕蒂塔》（又称德国组曲，古组曲）</strong></p>
<p>《帕蒂塔》与《法国组曲》《英国组曲》一样，都是巴赫键盘音乐中的精品，且更为成熟，具有明显的意大利风格。这套组曲中歌曲的编排不像另外两套那样固定，比较自由。不局限于舞曲，还用了随想曲、诙谐曲、幽默曲等。一共7组，第7组是明显的法国风格，仍以法国舞曲组成。现在一般乐谱只有6组。</p>
<p><strong>3、巴赫《平均律钢琴曲集》</strong></p>
<p><strong>三、钢琴教学的高级阶段的乐曲</strong></p>
<p>到了这个阶段，应该说是可以自由驰骋在钢琴音乐的天地。钢琴音乐文库犹如浩瀚大海，取之不尽，用之不竭，掌握高级技巧后，学习的曲目就无限广阔。如：</p>
<p>贝多芬的《钢琴奏鸣曲》中的后期作品。</p>
<p>莫扎特《钢琴奏鸣曲》K475、K498等。</p>
<p>《波兰舞曲》第一首作品26之1；第8首作品71之1；第14首#g小调和第16首降G大调等。</p>
<p>《谐谑曲》第2首作品31，第3首作品39等。</p>
<p>李斯特作品《爱之梦》第3首，根据阿拉比耶夫的原作改编的《夜莺》，《威尼斯与那波里》第3首《塔兰泰拉》等，《匈牙利狂想曲》第11首。</p>
<p>舒曼《童年情景》，《蝴蝶》等。</p>
<p>德彪西《前奏曲》</p>
<p><strong>中国作品：</strong></p>
<p>黎英海《夕阳箫鼓》</p>
<p>谢 耿《霓裳羽衣曲》</p>
<p>王建中《百鸟朝凤》</p>
<p>权吉好《组曲—-“长短”的组合》</p>
<p>王立三《东山魁夷画意》</p>
<p>赵晓生《太极》等等。</p>
<p><strong>手指练习</strong></p>
<p><strong>1、李斐岚编著《儿童钢琴手指练习》</strong></p>
<p>李斐岚（1947~）中央音乐学院副教授，钢琴演奏家、教育家。</p>
<p>《儿童钢琴手指练习》是专为儿童而写的练习。本书充分考虑到儿童的特点，左右的练习都在两个8度以内，篇幅比较小，要求精确，易于儿童掌握。</p>
<p><strong>2、哈农《钢琴练指法》</strong></p>
<p>C·L·哈农（1820~1900）法国风琴家，钢琴家。</p>
<p>哈农《钢琴练指法》是我国使用极为普遍的手指练习教材。</p>
<p><strong>3、什密特《钢琴五指练习》作品16</strong></p>
<p>G·A·什密特（1821~1902）德国钢琴家、作曲家。</p>
<p>这本手指练习，分不带保留音和带保留音五指练习。</p>
<p>以上三本教材适合于启蒙阶段，初级阶段即中级阶段使用。</p>
<p><strong>4、科尔托《钢琴技术的合理原则》</strong></p>
<p><strong>5、马格丽特·朗《钢琴技巧练习》</strong></p>
<p><strong>6、李嘉禄《钢琴基本技术练习》</strong></p>
<p>声明：该文观点仅代表作者本人，搜狐号系信息发布平台，搜狐仅提供信息存储空间服务。 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2019/01/31/vue-multiversion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/31/vue-multiversion/" class="post-title-link" itemprop="url">Vue多版本开发环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-31 10:06:40" itemprop="dateCreated datePublished" datetime="2019-01-31T10:06:40+08:00">2019-01-31</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019/01/31/vue-multiversion/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/31/vue-multiversion/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="下载nodejs版本切换工具nvm"><a href="#下载nodejs版本切换工具nvm" class="headerlink" title="下载nodejs版本切换工具nvm"></a>下载nodejs版本切换工具nvm</h1><pre><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash
</code></pre>
<h1 id="安装特定版本的nodejs"><a href="#安装特定版本的nodejs" class="headerlink" title="安装特定版本的nodejs"></a>安装特定版本的nodejs</h1><h2 id="设置国内node安装文件镜像库"><a href="#设置国内node安装文件镜像库" class="headerlink" title="设置国内node安装文件镜像库"></a>设置国内node安装文件镜像库</h2><pre><code>nvm npm_mirror https://npm.taobao.org/mirrors/npm/
nvm node_mirror https://npm.taobao.org/mirrors/node/
</code></pre>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>可以安装多个nodejs版本</p>
<pre><code>nvm install 10.14.2
</code></pre>
<p>现在可以使用npm和node命令了</p>
<h2 id="镜像切换工具nrm"><a href="#镜像切换工具nrm" class="headerlink" title="镜像切换工具nrm"></a>镜像切换工具nrm</h2><pre><code>npm install -g nrm --registry=https://registry.npm.taobao.org
nrm ls
nrm use taobao
</code></pre>
<h1 id="Vue环境搭建"><a href="#Vue环境搭建" class="headerlink" title="Vue环境搭建"></a>Vue环境搭建</h1><h2 id="新版vue-cli"><a href="#新版vue-cli" class="headerlink" title="新版vue-cli"></a>新版vue-cli</h2><pre><code>npm install -g @vue/cli
vue create hello-world
</code></pre>
<h2 id="拉取-2-x-模板-旧版本"><a href="#拉取-2-x-模板-旧版本" class="headerlink" title="拉取 2.x 模板 (旧版本)"></a>拉取 2.x 模板 (旧版本)</h2><p>Vue CLI 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：</p>
<pre><code>npm install -g @vue/cli-init
vue init webpack my-project
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2019/01/31/navicat-mysql-8-0-password/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/31/navicat-mysql-8-0-password/" class="post-title-link" itemprop="url">Navicat连接Mysql 8.0时密码错误的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-31 10:03:35" itemprop="dateCreated datePublished" datetime="2019-01-31T10:03:35+08:00">2019-01-31</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019/01/31/navicat-mysql-8-0-password/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/31/navicat-mysql-8-0-password/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这个问题是由于Mysql 8.0的认证方式不是mysql_native_password，需要手动修改</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>修改需要登录的用户</p>
<pre><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;YourPassword&#39;;
FLUSH PRIVILEGES;
</code></pre>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>全局修改，将默认的身份认证插件改为mysql_native_password。</p>
<pre><code>vim /etc/my.cnf
</code></pre>
<p>在[mysqld]中添加</p>
<pre><code>default_authentication_plugin=mysql_native_password
</code></pre>
<p>重启MySQL</p>
<pre><code>service mysqld restart
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/11/10/programmer-kuaibo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/10/programmer-kuaibo/" class="post-title-link" itemprop="url">关于程序员和产品经理两大世界体系的对话——论快播庭审</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-10 10:23:21" itemprop="dateCreated datePublished" datetime="2018-11-10T10:23:21+08:00">2018-11-10</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/11/10/programmer-kuaibo/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/10/programmer-kuaibo/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近快播的段子都快传疯了。很多网友也在那里分析快播有没有罪，辩护有没有问题之类的。其实结果对我来说一点都不重要。快播有没有罪，这个留给法庭审判。我今天要说的是庭审所暴露出来的一些问题，一些我日常中经常看到的问题。</p>
<p>我们先看两个段子（其实基本是庭审里的事实）：</p>
<blockquote>
<p>审判长问：文件加了密，你为什么不解密呢？</p>
<p>张克东：如果达不到一定的码率，快播软件就会启动缓存服务器开始加速，达到了码率，就会自动断开。<br>法官：软件它为什么会知道？它是机器人么？</p>
</blockquote>
<p>也许有些人看到段子1，会喷国家审查啊什么的。其实这不是审查，而是无知。审查一定是懂行的，无知才会要人解密。至于段子2，也有类似的问题——码率的衡量问题在大多数程序员，甚至包括懂一点技术的用户那里都不是秘密。问“软件为什么知道”，实际上非常无知。</p>
<p>甚至同样的问题，也存在于某些网友的评论中。例如<a target="_blank" rel="noopener" href="http://www.leiphone.com/news/201601/101BbjfiTqPv2N6d.html">这篇</a>。我引用这个评论段落：</p>
<blockquote>
<p>我看到不少网友以此取笑法官如何外行。其实法官非常聪明，不管张克东如何回复，都回避不开“软件如何知道”，也就是系统如何识别片源问题,只要这个回答了,你快播就摆脱不了你”清楚”播放哪些视频的问题。</p>
</blockquote>
<p>如果懂一点技术的话，应该明白一点。对软件而言，码率一定是知道的。而内容，则未必。或者换个对不了解技术的同学们更友好一点说法。对浏览器而言，网页上的图片的大小，格式，都是知道的对吧？浏览器也可以用来浏览黄色网站对吧？那问题也一样，软件它为什么会知道？</p>
<p>红衣主教，是不是该轮到你出庭聊一聊了？</p>
<p>同样，所有聚焦点在“软件应当可以监管浏览内容”的人，同时也面临这么个问题，浏览器是否可以监管黄色网页？作为处理数据流的软件，肯定是了解被处理数据的格式，大小，码率等参数的。那么处理软件是否应当对被处理的数据的内容合法性负责呢？如果是的话，那毫无疑问，所有黄色信息都必然经过了Intel和AMD两家生产的CPU，而且绝大多数也经过了Windows。</p>
<p>实际上，整个庭审中通篇都是法官和公诉人各种技术外行。例如用IP地址标识服务器，硬盘大小标识硬盘等等。如果在国外正常庭审，这证据其实就算废掉了。因为被告可以当场演示给你看改IP地址，你连服务器是不是他的都无法证明，还怎么构成证据链呢？当然，在中国来说，最后是否取信还是合议庭说了算的。</p>
<p>对于程序员来说，这个故事是不是很熟悉？是不是觉得和产品经理打交道很像？一样是对技术一无所知，却对一无所知不以为耻。我碰到过一个产品经理，自以为提了一个很犀利的需求——为什么我们不通过软件自动算出地址，还要客户自己填？</p>
<p>我听到这个问题的时候，估计表情和听到“为什么不解密”时的表情是一样的。心里一万头草泥马奔腾而过——合着不是你实现啊。尼马我怎么算？IP地址只能知道大致地区，还不一定准。GPS当时还不是每个浏览器都支持，就算支持也只能算出坐标，算不出地址。</p>
<p>很多时候，产品上的一点小小的改变，往往是技术上的翻天覆地。不信你考虑一个论坛系统，如果做到像腾讯那么大流量的时候会是什么样一个样子？再考虑一个交易系统，在同样一个量下是什么样子？前者应该还能做，后者应该已经没法弄了吧。为什么同样是个网站，同样的量，一个没事，一个挂了？</p>
<p>因为论坛系统是典型的无事务低写高读系统，因此可以使用分库分表，多层缓存的方法来增强性能。而交易系统是典型的事务，没法用这个手段。所以交易系统在海量压力下的技术难度，和论坛系统在海量压力下的技术难度，其水平和重点根本不是一类的。从这个意义上说，淘宝双11，很不容易。</p>
<p>而这种技术难度，产品经理是不知道的。所以他搞不好会给一个超大流量论坛提出一个很实在的需求——咱们弄一个内部交易系统吧，应该会变成不错的盈利点。呵呵。这个系统要么做出来会有各种各样的事务问题，要不然这个系统大量使用的时候，整个系统（做的好的话应该不会波及论坛）就会慢到无法接受。</p>
<p>当然，现实中一般是没有这么大论坛的。京东实打实在事务性能上吃过亏没错，但是那时候京东已经多大体量了？一个论坛，要引流过去那么大体量，自身得多大？但是这个例子本身说明技术难题的非直观性和在下判断时的必要性。如果你不了解这个技术本身会引发什么问题，你就无法得到合理的结论。</p>
<p>作为产品经理，或者要和技术打交道的一切人士。不懂技术并不可耻，可耻的是不懂技术又无视技术。既不去学，也不去问。装作技术不会对他产生影响，装作不懂技术并不影响他决策的权威性。</p>
<p>与此形成对比的，是微软垄断诉讼案中法官的表现。那个案子里，微软律师强调的是IE内核和windows系统的严密整合，导致两者几乎无法拆分。从软件架构角度来说，这没错。但是法官很明白里面的门槛——保留IE内核不代表保留IE。鼠标一点，IE直接从系统中干掉。虽然内核还在系统上，但是不额外安装IE的话，无法使用浏览器。如果没有后来的一些事的话，估计微软就难逃一劫了。</p>
<p>话题拉回到快播庭审的事情上来。快播有没有问题？排除色情非罪化（我支持内容分级审查和色情非罪化），我觉得是有的。就好像我们说**的时候，一般都会想到约炮。（由于某些因素，我不能写出这两个字来。但是如果你这两个字和我想的不一样，那你的问题就大了）如果快播没有放任色情传播的话，是很难做到这么大的，更不可能做到我们一说找XX内容就想到快播。这不能说因为检方派了几个猪队友，所以快播干净了。</p>
<p>但是这个问题是不是罪？这不好说。定罪这个事情是个专业性很强的活，我的法律知识不足以下这个判断。但是个人意见，我觉得应该无罪，至少不能拿缓存服务器上的色情信息来定罪。如果缓存服务器上有色情内容就可以定罪的话，那铁通小区宽带就可以直接去转型了。因为他们为了减少对电信的依赖，降低流量结算费。在小区里都是装了缓存服务器的，而且是强制透明缓存，想不做都不行。小区里有没有人看色情网站？他们为什么不人工看？</p>
<p>看，这又是一个不懂技术就不知道我在说什么的问题。对用户来说，可能铁通的感觉就是“不好用”。技术人员才知道，电信和铁通的流量结算价格问题，还有铁通（以及各种小ISP）的透明代理的存在。知道这个透明代理和快播的缓存是不是在技术上是等效的。</p>
<p>还有解密，可行不可行？对于快播来说，要解密应该是可以的。但是对于百度网盘来说，连解密都不行。我把我的一堆生活照在百度网盘上备了个份。为求安全，我用GPG做了加密，然后再用SHA256。我自己倒是问心无愧，但是对百度来说，里面到底是不是色情内容？我觉得百度要是还能解开，不妨把技术卖给CIA。</p>
<blockquote>
<p>转自<a target="_blank" rel="noopener" href="http://blog.shell909090.org/blog/archives/2816/">Shell Xu</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/10/02/internet-aaron-swartz/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/02/internet-aaron-swartz/" class="post-title-link" itemprop="url">互联网之子 – AARON SWARTZ</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-02 23:52:07" itemprop="dateCreated datePublished" datetime="2018-10-02T23:52:07+08:00">2018-10-02</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/10/02/internet-aaron-swartz/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/02/internet-aaron-swartz/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1986年11月8日，有个叫Aaron Swartz的人在美国芝加哥伊利诺伊州出生。因为他父母创办了一个软件公司，所以，Aaron在3岁的时候就接触到了电脑，然后就着迷了。</p>
<p>我们先通过Aaron Swartz 的青少年时期来看一下他是怎么样的一个天才：</p>
<p>12岁的时候Aaron就创建了一个类似于Wikipedia式的网站（那时还没有Wikipedia），13岁的时候，Aaron赢得为年轻人而设，创作教育及协同非商业网站的<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/ArsDigita_Prize">ArsDigita Prize</a>比赛首名。 奖品包括参观麻省理工学院及与网际网路界的知名人士见会。</p>
<p>14岁的时候，他就成为了<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/RSS">RSS1.0</a>的开发组的一员。（后来，他和 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/John_Gruber">John Gruber</a>一起开发了Markdown）</p>
<p>15岁的时候，进入W3C的 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Resource_Description_Framework">RDF</a> 核心工作组，并写了RFC3870——这个文档描述了一个新的media type – “<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/RDF/XML">RDF&#x2F;XML</a>“，用于定义互联网上的“<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Semantic_Web">语义网络</a>”</p>
<p>17岁进入斯坦福大学，1年半后，18岁的时候因为受不了教条式的教育缀学，并通过Y Combinator公司的夏季创办人计划成立Infogami软件公司，在那里，他设想了一个Wiki平台来实现他的Internet Open Library——一个开放的网络图书馆。并写了著名的web.py 开发框架。但他觉得自己太年轻，还要有一个合伙人，于是Y Combinator建议他和Reddit合并。于是他在19岁的时候成了Reddit的创始人</p>
<p>虽然Reddit不挣钱，但是相当火，当他20岁的时候（2006年10月），他们把Reddit卖给了<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cond%C3%A9_Nast_Publications">Condé Nast出版社</a>，据说挣到了百万美金。然后，他去了这家出版社工作，受不了办公室的那种工作环境，2007年1月离职。</p>
<p>但是，你能想得到这么天才的一个人，于2013年1月11日自杀了么？那年他才26岁。</p>
<p>从前面Aaron的经历我们可以看到，他是一个特别喜欢Wiki的人，也是非常喜欢开放的人，但并不喜欢那些有CopyRight的东西，也也不喜欢那些循规蹈矩的东西，他喜欢质疑，他喜欢打破常规，他用生命坚持着互联网真正的开放精神。但是这样一来，必然会和守旧的世界相冲突。</p>
<p>他在YC搞的那个Internet Open Library（互联网开放图书馆）的项目，他就想把那些没有Copyright的书籍和学术期刊放在网上让全世界的人免费查阅。<strong>他就认为固体的图书馆遮蔽了知识的传播，互联网理应成为连接书籍，读者，作者，纸张与思想的最好载体，他非常痛恨任何一家巨型的机构独吞所有书籍的做法。他想把Public Access 变成 Public Domain</strong>。在他的青少年时期，他就在不懈地和一切限制信息自由交换和自由共享的做法做斗争。这是他认为的互联网精神，他同时也觉得这和美国民主自由的宪法的精神是一致的。</p>
<p>其中有一个例子是这样的，美国法院行政办公室有一个叫 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/PACER_(law)">PACER</a>（Public Access to Court Electronic Records） 的政府服务。这个服务会把法庭记录的文件放在网上，如果你要看的话，一页要付费8美分（注意是每页，不是每个文档，美国政府说这只是成本式的收费），这个事他非常不能理解，他觉得这些文件本来就属于公众，没有CopyRight，为什么属于公众的东西还要收费。PACER这个服务每年可以为政府带来1.2亿美金的收入。</p>
<p>于是Aaron在2008年9月4日到20日，他22岁的时候，他用Perl在AWS上写了一个程序，从PACER上下载了270万的文档（2000万页，纽约时报里说他下载大约是总量的20%，但是也有人不到总量的1%）。于是FBI对他调查了两个多月，但最终没有对他起诉。（今天，PACER还在收费，不过你可以使用一个叫<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/RECAP">RECAP</a>的Firefox插件来免费浏览当年Aaron下载的相关的法律文档）</p>
<p>2008年同年，Aaron创建了Watchdog.net – “the good government site with teeth” 专门用来收集和呈现和政客相关的数据（这个网站访问不到了，不过你可以在<a target="_blank" rel="noopener" href="http://www.aaronsw.com/weblog/watchdog">Aaron的blog上看一下他的想法</a>）。然后，他还起草了*<a target="_blank" rel="noopener" href="http://openaccessmanifesto.org/">Guerrilla Open Access Manifesto</a>*（<a target="_blank" rel="noopener" href="http://openaccessmanifesto.org/%E6%B8%B8%E5%87%BB%E9%98%9F%E5%BC%80%E6%94%BE%E8%AE%BF%E9%97%AE%E5%AE%A3%E8%A8%80/">中文版</a>） 下面是节选</p>
<blockquote>
<p>信息就是能源。但就像所有能源一样，有些人只想占为己有。世界上所有的科学和文化遗产，已在书籍和期刊上发布了数个世纪，正渐渐地被少数私有的公司数字化并上锁。想要阅读那些有着最著名研究成果的论文？你必须支付给如 Reed Elsevier 这样的出版商大把钱。</p>
<p>…… ……</p>
<p>我们要夺回信息，无论它们被存在何处，制作我们的副本并和全世界分享。我们要取到版权到期的东西并将它们归档，我们要买下秘密的资料库并将它们放到网上。我们要下载科学期刊并将它们上传到文件分享网络。我们要为游击队开放访问而战。</p>
<p>只要全世界有足够多的我们，那就不仅是传达了一个反对知识私有化的强有力信号，我们还将让它成为过去。你愿意和我们一起吗？</p>
<p>亚伦·斯沃茨 (Aaron Swartz) 2008 年 7 月，意大利 Eremo</p>
</blockquote>
<p>Aaron觉得那些对人类有价值的科学和文化遗产属于全人类，美国大学每年会向那些出版学术期刊、论文的机构（比如 ISI，Jstor）支付许可费用，许可费用极高，他觉得这是这个时代的悲剧。于是完美主义的他产生了一种责任感。</p>
<p>2009年，他成立了<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Progressive_Change_Campaign_Committee">Progressive Change Campaign Committee</a>（进步改变运动委员会），2010年，他又创建了 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Demand_Progress">Demand Progress</a> （求进会）——利用互联网来组织群众与议会和政府对话。</p>
<p>也因为Aaron并不理解政府和这个时代的这些荒唐的行为，于是他开始学习各种政治上的东西去寻求突破，这让他在2010年到2011年，在哈佛大学Edmond J. Safra研究实验室以Lab Fellow的身份主导到了“制度腐败”课题的研究。也因为这个身份，Aaron在MIT做访问学者的时候有 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/JSTOR">JSTOR</a>的帐号可以通过MIT的网络访问大量的学术期刊。</p>
<p>于是，他把他的laptop放到了地下室网络交换机的机房中，直接插上网线，然后全天后地下载那些JSTOR的学术期刊。（他利用了这些学术期刊的URL链接中的规律来下载所有的期刊），一开始JSTOR把他的帐号和IP封了，并报告给了警，美国的国家安全警察找到了那间楼道里的机房，然后让JSTOR不禁止他访问，并在那间机房里安了摄像头，钓鱼执法。然后等Aaron去换硬盘时录好像，2011年1月6日就把他给抓了。</p>
<p>那年Aaron才24岁。2011年7月11日，检查官以通信欺诈、计算机欺诈、非法获得信息，以及破坏被保护的罪名电脑来起诉他。可能会受到35年以上的牢狱之灾。这是相当重的罪名。你能想像得到为什么罪名会这么重吗？</p>
<p>事后，JSTOR发声明，说他们并不想起诉Aaron，起诉Aaron的是政府行为，而MIT方面虽然也放弃起诉，并也发表了相关的说明——保持中立。保持中立让MIT基本上名誉扫地，因为这种保持中立的行为违背于MIT一贯鼓吹的黑客文化，MIT成了千夫之指。</p>
<p>当然，美国政府的检查官坚持以重罪起诉他。当时，放在Aaron前有两条路：1）认罪，承认犯下重罪，35年的判决会变成3个月入狱+1年的居家监禁（不得使用电脑），2）不认罪，那就有可能接受35监禁年的最坏结果。Aaron选择了后者，而他的女友则选择了认罪。他的第一任女友后来非常的悔恨，面对国家机器，个体太渺小了。</p>
<p>在起诉期间，大家是否还记得美国那个臭名昭著的SOPA（ <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Stop_Online_Piracy_Act">Stop Online Piracy Act</a>）法案？Aaron通过他的 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Demand_Progress">Demand Progress</a> 把民众们网聚起来，和政府做斗争，最终导致了整个社会都在反对SOPA，也导致了那些议员纷纷改变自己的想法，并导致了白宫最终放弃了这个法案。这是一次民主的胜利，与Aaron有密切的相关。（相信大家都还记得那时美国各大网站都在反对这个网络审查制度）</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2014/09/800px-AaronSwartzPIPA.jpg" alt="斯沃茨在2012年反对禁止网络盗版法案(SOPA)的抗议活动上发言"> 斯沃茨在2012年反对禁止网络盗版法案(SOPA)的抗议活动上发言</p>
<p>而在次年2012年9月，政府对Aaron进行了更为严厉的起诉，新加入了另外9条起诉，如果成立，Aaron最多获刑50年外加100万美金的罚款。同样，检察官给出了优惠条件，只要Aaron认罪，那就只起诉他6个月的监禁。Aaron再次拒绝。</p>
<p>看到这里，你觉得下载一些期刊，也没有挣钱，为什么要判他这么重呢？这后面有什么故事呢？这是不是更像是一种政治迫害呢（这段时间，好像这些消息并没有进入中国，我们的大多数人依然在使用百度在墙内活得很滋润，另外，这个事在美国那边的IT 圈闹得很大，但似乎也不见各个IT圈的老大们有没有什么表态）</p>
<p>不过，可以肯定的是，美国政府受够了像阿桑奇这样的人了，而Aaron让美国政府更为害怕在有规模有组织的事，所以一定少不了相关的政治迫害，天下政府一般黑。</p>
<p>之后，2013年1月11日，Aaron自杀了。大家觉得他是因为来自美国政府的长期恐吓的压力和以及长期的抑郁（理想主义者可能都会有或多或少的抑郁证）</p>
<p><strong>这就是Aaron Swartz传奇的一生。他用他的生命捍卫了互联网的开放和自由。</strong></p>
<p><img src="https://coolshell.cn/wp-content/uploads/2014/09/87d31fea0996abbedb297c70b8b0b945_b.jpg" alt="87d31fea0996abbedb297c70b8b0b945_b"></p>
<p>互联网之父，<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</a>，在2012伦敦奥运会上的网络环节我们都见过这个人。世界上第一个web网站是1991年8月6日在CERN内的NeXT服务器上运行（今天这个网站依然可以访问：<a target="_blank" rel="noopener" href="http://info.cern.ch/hypertext/WWW/TheProject.html">链接</a>），Tim并被没有用这个发明挣钱，而是无偿地把WWW的构想和设计推广给了全世界。《时代》周刊评论他的时候用了这样的一条话：“与所有的推动人类进程的发明不同，这是一件纯粹个人的劳动成果”。</p>
<p>而Aaron最崇拜的人就是Tim，Tim也是Aaron的精神导师。</p>
<p>Aaron死了以后，Aaron朋友和合作者，哈佛大学法学院教授Laurence Lessig，回忆说，他当年和仅15岁的Aaron 有过一次谈话。Aaron问他：“您刚才讲到网络审查和管制的这些弊病，那您有没有什么实际的方案来解决这些问题呢？”Lessig有点尴尬地说：“没有。我是个学者，我只负责做研究，解决问题不关我的事儿。”Aaron接着问：“您是个学者，所以解决问题不关你的事儿。那，您作为一个公民，又该如何呢？”</p>
<p>有个男孩叫 Jack Andraka，来自巴尔的摩，14岁，阅读了 Aaron 自杀前推广的JSTOR 的免费学术论文，想出了一种提早检测胰腺癌的方法（一般胰腺癌被查出的时候就是你死的时候。）以此，他成功去了约翰霍普金斯大学做研究。Jack说——</p>
<blockquote>
<p>“我之所以上了新闻，是因为我们的实验成功了，而这就是为什么 Aaron 做的事有那么重要……这个宇宙中的真理不是只有那些政策制定者曾经弄清楚过的，比如应该限速多少，它还包括那些能让你的孩子，不会因胰腺癌而死的研究。<strong>如果没有访问阅读权，那个能解决你的问题的人，可能就永远找不到答案</strong>。”</p>
</blockquote>
<p><strong>强烈推荐纪录片——《<a target="_blank" rel="noopener" href="http://www.tudou.com/programs/view/jefojo_-HjQ/">互联网之子</a>》</strong></p>
<p>Aaron说的一句话让我挺有感触的——</p>
<p><strong>相信你应该真的每时每刻都问自己，现在这世界有什么最重要的事是我能参与去做的？</strong></p>
<p><strong>如果你没在做那最重要的事，那又是为什么？</strong></p>
<p><img src="https://coolshell.cn/wp-content/uploads/2014/09/aaron_swartz__freedom_fighter_by_caq_qoq-d5rzbi8.jpg" alt="aaron_swartz__freedom_fighter_by_caq_qoq-d5rzbi8"></p>
<p><strong>延伸阅读</strong>：<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/3363.html">偷了世界的程序员</a></p>
<p>（全文完）</p>
<blockquote>
<p>来源：**<a target="_blank" rel="noopener" href="https://coolshell.cn/">酷 壳 – CoolShell</a>**</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/10/02/why-not-wechat-articles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/10/02/why-not-wechat-articles/" class="post-title-link" itemprop="url">为什么我不在微信公众号上写文章</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-10-02 23:39:56" itemprop="dateCreated datePublished" datetime="2018-10-02T23:39:56+08:00">2018-10-02</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/10/02/why-not-wechat-articles/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/02/why-not-wechat-articles/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>很多朋友问我为什么不在微信公众号上写文章。我都没有直接回答，老实说，我也是扭扭捏捏的，才去开了个个人的微信的公众号，而且还只能搜索我博客这边的文章，我承认现在的阅读都在移动端，而且微信的公众号是国内移动端的文章流量及分享的入口，但是我还是更愿意使用blog这样的方式分享文章，最多也是在blog这边写好文章后，再去微信公众号那边贴一下。这个原因，不是因为我是一个老顽固，有习惯思维，而是，我不觉得微信公众号是一个好的信息传播和交流的平台。</p>
<p><strong>我下面的言论仅仅代表我的个人观点，我不想强加给别人，我只是想说明一下为什么我不把我的blog迁移到微信公众号上。</strong></p>
<p>首先，互联网是开放和共享的，不是封闭的。信息的传播更是需要开放的，大家可以看看<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/11928.html">互联网之子</a>。</p>
<ul>
<li>我希望我的文章能够被rss feed到各种阅读器中。</li>
<li>我希望我的文章可以被搜索引擎所检索到。</li>
<li>我希望我的文章能被别人整理，与其它人的文章放在一起互补。</li>
<li>我希望我的文章能被修改，因为文章会有错误，也会需要时常更新。</li>
</ul>
<p>然而，微信公众号都不能很好的支持。我希望我的文章能成为生态圈的里的一部份。所谓生态圈是相互融合，不是唯我独尊。这个和做开源软件的道理一样，开源软件不是把源代码开出来就好了，而是要去和已有的其它软件互相融合，互相兼容，互相支持，这本就是软件设计的真谛（参看《UNIX编程艺术》）。所以，我想，写文章也一样。</p>
<p>下面是我觉得文章传播的姿势。</p>
<h4 id="文章传播的姿势"><a href="#文章传播的姿势" class="headerlink" title="文章传播的姿势"></a>文章传播的姿势</h4><p><strong>我希望我的文章是被检索的，这意味着，就算文章写过了好多年，它依然可以被检索到，而不是在社交圈上被大众转了3-4天后就完了，然后再也没有然后了</strong>。</p>
<p>今天，我十多年前写的文章依然可以被检索到，依然对后来的新人有帮助。因为我的文章被搜索引擎检索了，我的文章被转载fork出去了，被人引用和标注，所以，可以长期被传播。</p>
<p>今天的酷壳（CoolShell.cn）已经很长时间没有更新了，然而里面的很多文章依然在被转发着，在被搜索着，在被重复阅读和被人推荐着，文章不断的被后来的人阅读。这就是被检索被共享被转载的好处。</p>
<p>同时，我并不希望成为某个平台写文章的苦力。在微信公众号下，你需要不断的更新才会积累起人气（订阅者），而文章的保鲜期非常有限，因为不能被检索，所以，你写的越多，你过去的文章也会被遗忘的越快。<strong>而微信公众平台让能写文章的人好像成为了这个平台的一个写作的奴隶，而不是让他们的文章中的内容和观点可以有长时间的影响力</strong>。换言之，在社交网络上，如果你要有影响力，你就要使劲写，需要更多的粉丝和订阅者。我个人认为这是违反了信息传播规律的。</p>
<p><strong>最重要的是，我希望我的文章和观点是有讨论的，希望我的文章能被指正和批评，最好是引发讨论和思辨</strong>，这样才会让我们每一个人都可以在交流中成长。<strong>很多时候，文章本身并没有什么太大的价值，而引发的讨论和思辨才更有价值，这是我认为文章传播最正确的姿势。而微信的公众号在讨论方面人为的阻止或大大消弱了大家的沟通和讨论</strong>。虽然我承认有些讨论也是无效的，而且还有漫骂和跑题，但是我依然觉得讨论的利大于弊。</p>
<p>我私以为，<strong>信息的传播正确姿势，是被检索、讨论、引用、整理、补充和更新，而不是社交网络的转发、点赞、粉丝、订阅和打赏</strong>。</p>
<p>换句话说，<strong>我关注的是的文章的长期价值，而不是短期的表象</strong>。</p>
<h4 id="关于文章的版权"><a href="#关于文章的版权" class="headerlink" title="关于文章的版权"></a>关于文章的版权</h4><p>很多人认为，封闭的平台有个比开放平台天然的优势，就是盗版和抄袭的问题，可以通过平台举报和惩罚对方。我以前也受到一些被抄袭和盗用的困扰，还曾经拿起来法律的武器维护自己的权利。</p>
<p>可能是我经历这样的事情比较早，所以，我今天在这个问题上不纠结了。</p>
<p>1、好的有价值的文章总是被人盗用抄袭的，这也算是对作者的一种认可吧。</p>
<p>2、我从来没有见过有人靠抄袭和盗用别人文章而成功的，无非就是收获几个赞罢了。</p>
<p>3、原创文章被人过抄袭和盗用，反而容易得到更多的关注。</p>
<p><strong>微信公众号的原创保护也只是局限在微信上，微信之外的平台，它也无能为力，所以，对于我的文章会被转到很多地方的这种情况来看，微信公众号的原创保护也非常有限。</strong></p>
<p>现在，我倒是不纠结有人会盗用和抄袭我的文章，因为，一方面，你可以有一些小伎俩来保护你的文章，比如在文章内容中放入一些你自己特有的标识，另一方面，我的文章被人盗用了抄袭的时候，总有一些网友能在盗用者那边指出来原文章是什么，并批评之。<strong>所以，还是应该把主要精力放在文章的内容和质量上，并让文章可以被检索和被更多的地方所引用，这样，你的文章才会得到最大的保护</strong>。</p>
<p>另外，<strong>既然别人对我的文章有抄袭和盗用的需求，要不我就让别人干得更体面一些。所以，我的文章完全可以自由的转载，但不得用于商业目的，只需要注明作者和出处就好了</strong>。</p>
<h4 id="关于写文章挣钱"><a href="#关于写文章挣钱" class="headerlink" title="关于写文章挣钱"></a>关于写文章挣钱</h4><p>首先，如果你觉得写文章出书是可以挣钱的，那么你可以洗洗睡了，尤其是在中国，这几乎是不可能的。</p>
<p>当然，你要挣点小钱是可以有的，但是，你需要写软文中植入广告，或是消费热点主题，比如前段时间的魏则西事件，有的公众号被打赏了一些钱。</p>
<p>老实说，这对我来说完全无感，因为，我的逻辑是这样的：<strong>我觉得一个人有一定的影响力，其中有很大一部份原因来自他的独立性，如果我开始写软文了，相当于我把自己卖了</strong>。</p>
<p>所以，我现在从来不通过写文章挣钱，因为我会写代码，我还是通过我的技能挣钱，通过给一些公司做咨询、培训、企业服务挣钱，老实说，靠自己的能力挣钱，比写文章挣钱挣得多多了，因为我觉得，<strong>像我写的这类的文章本来就是用来分享和传播的，不是用来挣钱的。写文章的目的是分享和影响，不是挣钱。</strong></p>
<p>关于独立性，这里说两个花絮吧——</p>
<p>我在Amazon的时候，我和公司讲，我想在我的博客上写几篇关于亚马逊的文章，介绍亚马逊的技术和一些做事的方法，也算是个宣传，让我的团队也好招人，但是，我当时的老板和我说，你的博客之所以有影响力是因为你的独立性，不要写亚马逊的，这样会把你自己卖了，千万别这么做。</p>
<p>然而，我在Alibaba的时候，我的大老板要求我用我的博客和微博帮阿里云做营销，我非常委婉地拒绝了，结果，团队合作的价值观不达标了。呵呵。</p>
<p>P.S. 本来酷壳上是不做广告的，今天，酷壳上也广告，但是广告费是全部捐给Wikipedia的，广告主的钱是没有到我的手的。</p>
<p>微信公众号上的文章都有软文和广告植放，我觉得这不是我的调调，我害怕微信公众平台的整体格调影响了我的格调。就好像我认为我的网络被百度检索到了会我的网站的格调下降好几个档次。所以，我还是保持一定的距离吧。</p>
<p><strong>这么说吧，我写文章不是为了挣钱，我也不认为写文章能挣到钱，我写文章就是为了分享和影响，我会借助社交网络，但不会寄宿在社交网络上，更不会被社交网络所绑架。</strong></p>
<p>谢谢看我的唠叨！</p>
<p>（全文完）</p>
<blockquote>
<p>来源：**<a target="_blank" rel="noopener" href="https://coolshell.cn/">酷 壳 – CoolShell</a>**</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/03/08/c%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/08/c%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-08 21:24:02" itemprop="dateCreated datePublished" datetime="2018-03-08T21:24:02+08:00">2018-03-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/03/08/c%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/08/c学习笔记/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-讲义"><a href="#C-讲义" class="headerlink" title="C++讲义"></a>C++讲义</h1><h2 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h2><h3 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h3><p>在字符字面前加L就能够得到wchar_t类型的宽字符字面值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">L&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><h4 id="const-限定符把一个对象转化为一个常量"><a href="#const-限定符把一个对象转化为一个常量" class="headerlink" title="const 限定符把一个对象转化为一个常量"></a>const 限定符把一个对象转化为一个常量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;</span><br></pre></td></tr></table></figure>

<p>任何修改bufSize的尝试都会导致编译错误i，定义时必须初始化。</p>
<h4 id="const默认为文件的局部变量"><a href="#const默认为文件的局部变量" class="headerlink" title="const默认为文件的局部变量"></a>const默认为文件的局部变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_1.cpp</span></span><br><span class="line"><span class="type">int</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file_2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count;</span><br><span class="line">++counter;</span><br></pre></td></tr></table></figure>

<p>除特别声明，在全局作用域声明的const变量是定义该对象文件的局部变量，不能被别的文件访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//file_2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize; <span class="comment">//在这里bufSize的声明同样是extern; 这样extern 标志着bufSize是一个声明，所以没有初始化式</span></span><br><span class="line">a = bufSize; <span class="comment">//使用文件1中的bufSize</span></span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用就是对象的另一个名字，在实际程序中主要用作函数的形式参数。</p>
<p>引用是一种复合类型，在变量名前“&amp;”来定义，不能定义引用类型的引用，但是能定义任何其他类型的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival; <span class="comment">//√</span></span><br><span class="line"><span class="type">int</span> &amp;refVa2; <span class="comment">//× 必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;refVa3 = <span class="number">10</span>; <span class="comment">//× 初始化必须是对象</span></span><br></pre></td></tr></table></figure>

<h3 id="const-引用"><a href="#const-引用" class="headerlink" title="const 引用"></a>const 引用</h3><p>const引用是指向const对象的引用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;refVal = ival;<span class="comment">//√</span></span><br><span class="line"><span class="type">int</span> &amp;ref2 = ival;<span class="comment">//× 会导致能够对ival进行修改</span></span><br></pre></td></tr></table></figure>

<p>可以读取但是不可以修改refVal，因此对refVal的赋值都是不合法的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, &amp;ri = i;</span><br><span class="line">i = <span class="number">5</span>; ri = <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ri &lt;&lt; std::endl; <span class="keyword">return</span> <span class="number">0</span>; &#125; ``` &amp;gt; <span class="number">52</span>页&lt;/iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span>引用可以初始化为不同类型的的对象或者初始化为右值</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line"><span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = <span class="number">1024</span>;<span class="comment">//对比前面</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = r + i;<span class="comment">//因为只读</span></span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;第三章 标准库类型&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;标准string类型&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">string类型支持长度可变的字符串</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span><span class="comment">//表示将s1初始化为字符‘c&#x27;的n个副本</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;blockquote&gt;</span></span><br><span class="line"><span class="function">  由于历史原因以及为了与C语言兼容，字符串字面值与标准库string类型不是同一类型。</span></span><br><span class="line"><span class="function">&lt;/blockquote&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;pre&gt;&lt;code <span class="keyword">class</span></span>=<span class="string">&quot;c&quot;</span>&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,line))<span class="comment">//一个输入流一个string对象</span></span><br><span class="line">cout &lt;&lt; line &lt;&lt; endl; <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//由于getline 函数返回时丢弃换行符，换行符将不会存储在string对象中 &#125; ``` ### string对象的操作 - s.empty() //如果是空串返回true - s.size() //串字符的个数 不要把size的返回值赋给一个int变量（unsigned） ### string对象中字符的处理 ``#include&amp;lt;cctype&amp;gt;`` - isalnum(c) //c是字母或数字 返回true - isalpha(c) //c是字母 - isgraph(c) //c不是空格，但可打印 - tolower(c）//如果c是大写则返回其小写字母，否则返回c - toupper(c) ### 标准vector类型 &amp;gt; P78</span></span><br><span class="line"></span><br><span class="line">vector是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。</span><br><span class="line"></span><br><span class="line">一个容器中所有对象必须是同一种类型的</span><br><span class="line"></span><br><span class="line">- `vector&amp;lt;<span class="type">int</span>&amp;gt; ivec;` 和其他变量定义一样，定义vector对象要指定类型和一个变量列表（<span class="type">int</span> 类型对象vector 变量名为ivec）</span><br><span class="line">- `vector&amp;lt;T&amp;gt; <span class="built_in">v</span>(n,i)` v包含n个值为i的元素</span><br><span class="line">- `vector&amp;lt;<span class="type">int</span>&amp;gt; <span class="built_in">fvec</span>(<span class="number">10</span>)`</span><br><span class="line"></span><br><span class="line">##<span class="meta"># vector 对象的操作</span></span><br><span class="line"></span><br><span class="line">- v.<span class="built_in">empty</span>()</span><br><span class="line">- v.<span class="built_in">size</span>()</span><br><span class="line">- v.<span class="built_in">push_back</span>(t)</span><br><span class="line"></span><br><span class="line">大家认为vector的下标操作可以添加元素,以下是错误</span><br><span class="line"></span><br><span class="line">​```<span class="function">c</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; ivec</span></span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(vector&lt;<span class="type">int</span>&gt;::size_type ix=<span class="number">0</span>;ix=<span class="number">0</span>;ix != <span class="number">10</span>; ++ix)</span></span></span><br><span class="line"><span class="function">ivec[ix] </span>= ix;</span><br><span class="line">​```&lt;/<span class="type">int</span>&gt;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line">但是ivec是vector对象，而且下标只能用于获取已存在的元素</span><br><span class="line"></span><br><span class="line">正确写法：</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line"><span class="keyword">for</span>（vector&lt;<span class="type">int</span>&gt;::size_type ix=<span class="number">0</span>;ix!=<span class="number">10</span>;++ix)</span><br><span class="line">ivec.<span class="built_in">push_back</span>(ix);</span><br><span class="line">​```&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line">&gt; `<span class="type">const</span> <span class="type">char</span>*`与`<span class="type">char</span> <span class="type">const</span>*`效果一样，都是不允许修改指针指向的地址空间的值，即把值作为常量，而`<span class="type">char</span> * <span class="type">const</span>`则是不允许修改指针自身，不能再指向其他地方，把指针自己当作常量使用。需要注意的是，使用`<span class="type">char</span> * <span class="type">const</span>`定一个常量指针的时候一定记得赋初始值，否则再其他地方就没法赋值了。</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;&lt;/iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *st = <span class="string">&quot;The expense of spirit\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*st) &#123; ++len; ++st; &#125;</span><br><span class="line">cout &lt;&lt; len &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; st &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code <span class="keyword">class</span>=<span class="string">&quot;c&quot;</span>&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;&lt;/iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *st = <span class="string">&quot;The expense of spirit\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = st;</span><br><span class="line"><span class="keyword">while</span> (*p) &#123; ++len; ++p; &#125;</span><br><span class="line">cout &lt;&lt; len &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; st &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code <span class="keyword">class</span>=<span class="string">&quot;c&quot;</span>&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;&lt;/iostream&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string substr = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string phrase = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">string slang = <span class="string">&quot;Hiya&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (substr &lt; phrase) cout &lt;&lt; <span class="string">&quot;substr is smaller&quot;</span> &lt;&lt; endl; <span class="keyword">if</span> (slang &gt; substr) cout &lt;&lt; <span class="string">&quot;slang is greater&quot;</span> &lt;&lt; endl; <span class="keyword">if</span> (slang &gt; phrase) cout &lt;&lt; <span class="string">&quot;slang is greater&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code <span class="keyword">class</span>=<span class="string">&quot;c&quot;</span>&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span><span class="string">&lt;/vector&gt;</span><span class="string">&lt;/iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// empty vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="comment">// give each element a new value</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>;</span><br><span class="line">ix != <span class="number">10</span>; ++ix)</span><br><span class="line">ivec.<span class="built_in">push_back</span>(ix);&lt;/<span class="type">int</span>&gt;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ivec.size: &quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// prints 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reset the elements in the vector to zero</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != ivec.<span class="built_in">size</span>(); ++ix)</span><br><span class="line">ivec[ix] = <span class="number">0</span>;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is there anything to print?</span></span><br><span class="line"><span class="keyword">if</span> (ivec.<span class="built_in">empty</span>() == <span class="literal">false</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vector contents: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">// print each element separated by a newline</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>;</span><br><span class="line">ix != ivec.<span class="built_in">size</span>(); ++ix)</span><br><span class="line">cout &lt;&lt; ivec[ix] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​```&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span><span class="string">&lt;/iostream&gt;</span><span class="string">&lt;/string&gt;</span><span class="string">&lt;/vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reset all the elements in ivec to 0</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != ivec.<span class="built_in">size</span>(); ++ix)</span><br><span class="line">ivec[ix] = <span class="number">0</span>;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// print what we&#x27;ve got so far: should print 10 0&#x27;s</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != ivec.<span class="built_in">size</span>(); ++ix)</span><br><span class="line">cout &lt;&lt; ivec[ix] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent loop using iterators to reset all the elements in ivec to 0</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = ivec.<span class="built_in">begin</span>();</span><br><span class="line">iter != ivec.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">*iter = <span class="number">0</span>; <span class="comment">// set element to which iter refers to 0&lt;/int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// print using iterators: should print 10 0&#x27;s</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = ivec.<span class="built_in">begin</span>();</span><br><span class="line">iter != ivec.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// print the element to which iter refers</span></span><br><span class="line">cout &lt;&lt; endl;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter = ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != ivec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">*iter = <span class="number">0</span>;</span><br><span class="line">++iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">​```&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line">## 迭代器</span><br><span class="line"></span><br><span class="line">&gt; P84</span><br><span class="line"></span><br><span class="line">除了使用下标来访问vector对象的元素外，标准库还提供了另外一种访问元素的方法。迭代器是一种检查容器内元素并遍历元素的数据类型。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 容器的iterator类型</span><br><span class="line">vector&amp;lt;<span class="type">int</span>&amp;gt;::iterator iter;<span class="comment">//定义了一个名为iter的变量，它的数据类型是由vector&amp;lt;int&amp;gt;定义的iterator类型。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> begin和end操作</span><br><span class="line">end操作返回的迭代器并不指向vector中的任何实际元素，哨兵的作用。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 应用程序示例</span><br><span class="line">​```<span class="function">c</span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;::iterator iter = ivec.begin();iter !=ivec.end(); ++iter)</span></span></span><br><span class="line"><span class="function">*iter </span>= <span class="number">0</span>;</span><br><span class="line">​```&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> const_iterator</span><br><span class="line">该类型只能用于读取容器内的元素，但不能修改他的值。</span><br><span class="line"></span><br><span class="line">与<span class="type">const</span> iteator的区别：</span><br><span class="line">使用const_iterator类型时，得到一个迭代器，自身值是可以改变的，但不能用来改变其所指向的元素的值（可以自增但不能赋值）</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> 的迭代器必须初始化迭代器，初始化后不能改变。</span><br><span class="line"></span><br><span class="line">​```<span class="function">c</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> vector &lt;<span class="type">int</span>&gt;::iterator cit = nums.<span class="built_in">begin</span>();</span><br><span class="line">*cit =<span class="number">1</span>;</span><br><span class="line">++cit;<span class="comment">//×</span></span><br><span class="line">​```&lt;/<span class="type">int</span>&gt;&lt;/<span class="type">int</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span>迭代器几乎没什么用，一旦初始化后只能用它来改写其指向的元素但不能指向别的元素。</span><br><span class="line"></span><br><span class="line">#<span class="meta"># bitset</span></span><br><span class="line"></span><br><span class="line">&gt; P88</span><br><span class="line"></span><br><span class="line">- `bitset&amp;lt;<span class="number">32</span>&amp;gt; bitvec` 初始化<span class="number">32</span>位，每位都是<span class="number">0</span></span><br><span class="line">- `bitset&amp;lt;n&amp;gt; <span class="built_in">b</span>(u)` b是<span class="type">unsigned</span> <span class="type">long</span>类型的一个副本</span><br><span class="line">- `bitset&amp;lt;n&amp;gt; <span class="built_in">b</span>(s)`</span><br><span class="line">- `<span class="function">bitset <span class="title">b</span><span class="params">(s,pos,n)</span>` b是s中从位置pos开始的n个位副本</span></span><br><span class="line"><span class="function">- `string <span class="title">strval</span><span class="params">(<span class="string">&quot;1100&quot;</span>)</span>`</span></span><br><span class="line"><span class="function">- `bitset &amp;lt</span>;<span class="number">32</span>&amp;gt; <span class="built_in">bitset4</span>(strval)` 高阶置<span class="number">0</span>，反向转化的</span><br><span class="line">- `b.<span class="built_in">any</span>()`</span><br><span class="line">- `b.<span class="built_in">none</span>()`</span><br><span class="line">- `b.<span class="built_in">count</span>()`</span><br><span class="line">- `b.<span class="built_in">size</span>()`</span><br><span class="line">- `b[pos]`</span><br><span class="line">- `b.<span class="built_in">set</span>()` `b.<span class="built_in">set</span>(pos)`</span><br><span class="line">- `b.<span class="built_in">reset</span>()`</span><br><span class="line">- `b.<span class="built_in">flip</span>()`</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;cstddef&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;string&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::<span class="type">size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;bitset&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> std::bitset;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bitset&amp;lt;<span class="number">32</span>&amp;gt; bitvec; <span class="comment">// 32 bits, all zero</span></span><br><span class="line"><span class="type">bool</span> is_set = bitvec.<span class="built_in">any</span>(); <span class="comment">// false, all bits are zero</span></span><br><span class="line"><span class="type">bool</span> is_not_set = bitvec.<span class="built_in">none</span>(); <span class="comment">// true, all bits are zero</span></span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec: &quot;</span> &amp;lt;&amp;lt; bitvec &amp;lt;&amp;lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> sz = bitvec.<span class="built_in">size</span>(); <span class="comment">// returns 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> bits_set = bitvec.<span class="built_in">count</span>(); <span class="comment">// returns number of bits that are on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// assign 1 to even numbered bits</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index != <span class="number">32</span>; index += <span class="number">2</span>)</span><br><span class="line">bitvec[index] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent loop using set operation</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index != <span class="number">32</span>; index += <span class="number">2</span>)</span><br><span class="line">bitvec.<span class="built_in">set</span>(index);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> i;</span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec: positions turned on:\n\t&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index != <span class="number">32</span>; ++index)</span><br><span class="line"><span class="keyword">if</span> (bitvec[index])</span><br><span class="line">cout &amp;lt;&amp;lt; index &amp;lt;&amp;lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &amp;lt;&amp;lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent; turn off first bit</span></span><br><span class="line">bitvec.<span class="built_in">reset</span>(<span class="number">0</span>);</span><br><span class="line">bitvec[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bitvec.<span class="built_in">reset</span>(); <span class="comment">// set all the bits to 0.</span></span><br><span class="line">bitvec.<span class="built_in">set</span>(); <span class="comment">// set all the bits to 1</span></span><br><span class="line"></span><br><span class="line">bitvec.<span class="built_in">flip</span>(<span class="number">0</span>); <span class="comment">// reverses value of first bit</span></span><br><span class="line">bitvec[<span class="number">0</span>].<span class="built_in">flip</span>(); <span class="comment">// also reverses the first bit</span></span><br><span class="line">bitvec.<span class="built_in">flip</span>(); <span class="comment">// reverses value of all bits</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// leaves bitvec unchanged; yields a copy of bitvec with all the bits reversed</span></span><br><span class="line">bitvec = ~bitvec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bitvec1 is smaller than the initializer</span></span><br><span class="line">bitset&amp;lt;<span class="number">16</span>&amp;gt; <span class="built_in">bitvec1</span>(<span class="number">0xffff</span>); <span class="comment">// bits 0 ... 15 are set to 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bitvec2 same size as initializer</span></span><br><span class="line">bitset&amp;lt;<span class="number">32</span>&amp;gt; <span class="built_in">bitvec2</span>(<span class="number">0xffff</span>); <span class="comment">// bits 0 ... 15 are set to 1; 16 ... 31 are 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// on a 32-bit machine, bits 0 to 31 initialized from 0xffff</span></span><br><span class="line">bitset&amp;lt;<span class="number">128</span>&amp;gt; <span class="built_in">bitvec3</span>(<span class="number">0xffff</span>); <span class="comment">// bits 32 through 127 initialized to zero</span></span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec1: &quot;</span> &amp;lt;&amp;lt; bitvec1 &amp;lt;&amp;lt; endl;</span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec2: &quot;</span> &amp;lt;&amp;lt; bitvec2 &amp;lt;&amp;lt; endl;</span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec2[0] &quot;</span> &amp;lt;&amp;lt; bitvec2[<span class="number">0</span>] &amp;lt;&amp;lt; endl;</span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec2[31] &quot;</span> &amp;lt;&amp;lt; bitvec2[<span class="number">31</span>] &amp;lt;&amp;lt; endl;</span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec3: &quot;</span> &amp;lt;&amp;lt; bitvec3 &amp;lt;&amp;lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">strval</span><span class="params">(<span class="string">&quot;1100&quot;</span>)</span></span>;</span><br><span class="line">bitset&amp;lt;<span class="number">32</span>&amp;gt; <span class="built_in">bitvec4</span>(strval);</span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;strval: &quot;</span> &amp;lt;&amp;lt; strval &amp;lt;&amp;lt; endl;</span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec4: &quot;</span> &amp;lt;&amp;lt; bitvec4 &amp;lt;&amp;lt; endl;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;1111111000000011001101&quot;</span>)</span></span>;</span><br><span class="line">bitset&amp;lt;<span class="number">32</span>&amp;gt; <span class="built_in">bitvec5</span>(str, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 4 bits starting at str[5], 1100</span></span><br><span class="line">bitset&amp;lt;<span class="number">32</span>&amp;gt; <span class="built_in">bitvec6</span>(str, str.<span class="built_in">size</span>() - <span class="number">4</span>); <span class="comment">// use last 4 characters</span></span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;str: &quot;</span> &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;</span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec5: &quot;</span> &amp;lt;&amp;lt; bitvec5 &amp;lt;&amp;lt; endl;</span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;str: &quot;</span> &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;</span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec6: &quot;</span> &amp;lt;&amp;lt; bitvec6 &amp;lt;&amp;lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulong = bitvec3.<span class="built_in">to_ulong</span>();</span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;ulong = &quot;</span> &amp;lt;&amp;lt; ulong &amp;lt;&amp;lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bitset&amp;lt;<span class="number">32</span>&amp;gt; bitvec7 = bitvec2 &amp;amp; bitvec4;</span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec7: &quot;</span> &amp;lt;&amp;lt; bitvec7 &amp;lt;&amp;lt; endl;</span><br><span class="line"></span><br><span class="line">bitset&amp;lt;<span class="number">32</span>&amp;gt; bitvec8 = bitvec2 | bitvec4;</span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec8: &quot;</span> &amp;lt;&amp;lt; bitvec8 &amp;lt;&amp;lt; endl;</span><br><span class="line"></span><br><span class="line">cout &amp;lt;&amp;lt; <span class="string">&quot;bitvec2: &quot;</span> &amp;lt;&amp;lt; bitvec2 &amp;lt;&amp;lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四章-数组和指针"><a href="#第四章-数组和指针" class="headerlink" title="第四章 数组和指针"></a>第四章 数组和指针</h2><h3 id="指针的定义和初始化"><a href="#指针的定义和初始化" class="headerlink" title="指针的定义和初始化"></a>指针的定义和初始化</h3><p><code>string*</code> 错误的理解成一种数据类型</p>
<p><code>string* ps1,ps2</code> 实际上是ps1是指针，ps2是一个普通的string对象</p>
<p>未初始化的指针是无效的，直到给该指针赋值后，才能使用它</p>
<h4 id="赋值操作的约束"><a href="#赋值操作的约束" class="headerlink" title="赋值操作的约束"></a>赋值操作的约束</h4><p>int型变量赋值给指针式非法的，尽管这个int型变量的值可能是0，允许把数值0或在编译时可获得0值的const量赋值给指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival;</span><br><span class="line"><span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_ival = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *pi = ival;(×)</span><br><span class="line">pi = zero;(×)</span><br><span class="line">pi = c_ival;</span><br><span class="line">pi = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>从C继承下来的预处理变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a><code>void*</code> 指针</h4><p>C++ 提供了一种特殊的指针类型 <code>void*</code>，它可以保存任何类型对象的地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> obj = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> *pd = &amp;obj;</span><br><span class="line"><span class="type">void</span> *pv = &amp;obj;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure>

<p><code>void*</code> 指针只支持几种有限的操作：与另一个指针进行比较；向函数传递<code>void*</code> 指针或从函数返回 <code>void*</code> 指针；给另一个 <code>void*</code> 指针赋值。</p>
<p>不允许使用<code>void*</code> 指针操纵它所指向的对象。</p>
<h3 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h3><h4 id="指针和引用的比较"><a href="#指针和引用的比较" class="headerlink" title="指针和引用的比较"></a>指针和引用的比较</h4><p>第一个区别在于引用总是指向某个对象：定义引用时没有初始化是错误的。第二个重要区别则是赋值行为的差异：给引用赋值修改的是该引用所关联的对象的值，而并不是使引用与另一个对象关联。引用一经初始化，就始终指向同一个特定对象。</p>
<h4 id="指针和const限定符"><a href="#指针和const限定符" class="headerlink" title="指针和const限定符"></a>指针和const限定符</h4><p>介绍了指针和 const 限定符之间的两种交互类型：指向 const对象的指针和 const 指针。</p>
<h4 id="指向const-对象的指针"><a href="#指向const-对象的指针" class="headerlink" title="指向const 对象的指针"></a>指向const 对象的指针</h4><p>我们使用指针来修改其所指对象的值。但是如果指针指向const 对象，则不允许用指针来改变其所指的 const 值。</p>
<p>为了保证这个特性，C++ 语言强制要求指向 const 对象的指针也必须具有 const 特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr;</span><br></pre></td></tr></table></figure>

<p>这里的 cptr 是一个指向 double 类型 const 对象的指针，const 限定了cptr 指针所指向的对象类型，而并非 cptr 本身。也就是说，cptr 本身并不是const。在定义时不需要对它进行初始化，如果需要的话，允许给 cptr 重新赋值，使其指向另一个 const 对象。但不能通过 cptr 修改其所指对象的值：</p>
<p>不能使用 void* 指针保存 const 对象的地址，而必须使用 const void* 类型的指针保存 const 对象的地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> universe = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *cpv = &amp;universe; <span class="comment">// ok</span></span><br><span class="line"><span class="type">void</span> *pv = &amp;universe; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>允许把非 const 对象的地址赋给指向 const 对象的指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cptr = &amp;dval;</span><br></pre></td></tr></table></figure>

<p>但是同样必须遵循不能通过cptr修改对象的值</p>
<h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><p>const指针指的是指针本身的值不能改变</p>
<h4 id="指向const对象的const指针"><a href="#指向const对象的const指针" class="headerlink" title="指向const对象的const指针"></a>指向const对象的const指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pi_ptr = π</span><br></pre></td></tr></table></figure>

<p>既不能修改 pi_ptr 所指向对象的值，也不允许修改该指针的指向。</p>
<h4 id="指针和-typedef-讨论）"><a href="#指针和-typedef-讨论）" class="headerlink" title="指针和 typedef (讨论）"></a>指针和 typedef (讨论）</h4><p>下面是一个几乎所有人刚开始时都会答错的问题。假设给出以下语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr;</span><br></pre></td></tr></table></figure>

<p>请问 cstr 变量是什么类型？</p>
<p>简单的回答是 <code>const pstring</code> 类型的指针。</p>
<p>进一步问：<code>const pstring</code> 指针所表示的真实类型是什么？很多人都认为真正的类型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string *cstr;</span><br></pre></td></tr></table></figure>

<p>也就是说，const pstring 是一种指针，指向 string 类型的 const 对象，但这是错误的。</p>
<p>错误的原因在于将 typedef 当做文本扩展了。声明 const pstring 时，const 修饰的是 pstring 的类型，这是一个指针。因此，该声明语句应该是把cstr 定义为指向 string 类型对象的 const 指针，这个定义等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *<span class="type">const</span> cstr;</span><br></pre></td></tr></table></figure>

<h3 id="创建动态数组"><a href="#创建动态数组" class="headerlink" title="创建动态数组"></a>创建动态数组</h3><p>每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆。</p>
<h3 id="const-对象的动态数组"><a href="#const-对象的动态数组" class="headerlink" title="const 对象的动态数组"></a>const 对象的动态数组</h3><p>如果我们在自由存储区中创建的数组存储了内置类型的 const 对象，则必须为这个数组提供初始化：因为数组元素都是 const 对象，无法赋值。实现这个要求的唯一方法是对数组做值初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *pci_bad = <span class="keyword">new</span> <span class="type">const</span> <span class="type">int</span>[<span class="number">100</span>];（×）</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *pci_ok = <span class="keyword">new</span> <span class="type">const</span> <span class="type">int</span>[<span class="number">100</span>]();（√）</span><br></pre></td></tr></table></figure>

<p>C++ 允许定义类类型的 const 数组，但该类类型必须提供默认构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string *pcs = <span class="keyword">new</span> <span class="type">const</span> string[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>

<p>已创建的常量元素不允许修改――因此这样的数组实际上用处不大。</p>
<h2 id="第五章-表达式"><a href="#第五章-表达式" class="headerlink" title="第五章 表达式"></a>第五章 表达式</h2><h3 id="箭头操作符"><a href="#箭头操作符" class="headerlink" title="箭头操作符"></a>箭头操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;` 相当于 `（*sp）</span><br></pre></td></tr></table></figure>

<h3 id="const对象的动态分配和回收"><a href="#const对象的动态分配和回收" class="headerlink" title="const对象的动态分配和回收"></a>const对象的动态分配和回收</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span> (<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>与其他常量一样，动态创建的const对象必须在创建时初始化，并且一经初始化，其值就不能修改。</p>
<p>对于类类型的const动态对象，如果该类提供了默认构造函数，则此类可以隐身初始化，但是内置类型对象以及未提供默认构造函数的类类型对象必须显示初始化。</p>
<h3 id="有符号与无符号类型之间的转换"><a href="#有符号与无符号类型之间的转换" class="headerlink" title="有符号与无符号类型之间的转换"></a>有符号与无符号类型之间的转换</h3><p>如果<code>int</code>类型足够表示所有的<code>unsigned short</code>型的值，则将<code>unsigned short</code>转换为<code>int</code>,否则将这两个操作数转换为 <code>unsigned int</code>.</p>
<p>同理 <code>unsigned int</code>和<code>long</code>转换为<code>unsigned long</code>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/03/08/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/08/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Git学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-08 21:23:36" itemprop="dateCreated datePublished" datetime="2018-03-08T21:23:36+08:00">2018-03-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/03/08/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/08/git学习笔记/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Git讲义"><a href="#Git讲义" class="headerlink" title="Git讲义"></a>Git讲义</h1><p>讲义内容参考：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/wilber2013/p/4189920.html">http://www.cnblogs.com/wilber2013/p/4189920.html</a></p>
<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git是一个<strong>分布式</strong>版本控制工具</p>
<h3 id="集中式版本控制"><a href="#集中式版本控制" class="headerlink" title="集中式版本控制"></a>集中式版本控制</h3><p>一个系统中只有一个机器是服务端，其他机器全是客户端。</p>
<p>缺点：</p>
<ul>
<li><p>网络依赖性强，工作环境保持网络连接，如果网络断掉了，所有的客户端就无法工作了。</p>
</li>
<li><p>安全性较弱，所有的代码以及版本信息保存在服务器中，一旦服务器挂掉了，代码和版本控制信息就丢失了。</p>
</li>
</ul>
<h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p>没有服务端&#x2F;客户端的概念，每台机器都是一个服务器。但是一般选一个机器作为中心服务器，方便大家交换更新。</p>
<p>优点：</p>
<ul>
<li><p>每台机器都是一台服务器，无需依赖网络就可以帮自己的更新提交到本地服务器，支持离线工作。当有网络环境的时候，就可以把更新推送给其他服务器。</p>
</li>
<li><p>安全性高，每台机器都有代码以及版本信息的维护，所有即使某些机器挂掉了，代码依然是安全的。</p>
</li>
</ul>
<h3 id="Git下载"><a href="#Git下载" class="headerlink" title="Git下载"></a>Git下载</h3><p>Git刚开始只能支持Linux和Unix环境，后来才慢慢的支持Windows系统。</p>
<p>主程序：<a target="_blank" rel="noopener" href="https://git-scm.com/">Git</a></p>
<p>Windows下可视化界面：<a target="_blank" rel="noopener" href="https://download.tortoisegit.org/">TortoiseGit</a></p>
<h3 id="Git安装后的配置"><a href="#Git安装后的配置" class="headerlink" title="Git安装后的配置"></a>Git安装后的配置</h3><p>安装完成后，一般都会对本机的Git进行一些基本的配置。下面的命令就是给Git环境配置全局的用户名和邮箱地址，这样每一个从这台机器上提交的更新都会标上这些用户信息。</p>
<ul>
<li>当第一次安装完Git时</li>
</ul>
<p>设置全局名字：设置成自己在GitHub上的账号显示名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置名字</span><br><span class="line">$ git config --global user.name &quot;你的名字&quot;</span><br><span class="line"># 设置邮箱</span><br><span class="line">$ git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>当每一次创建项目时</li>
</ul>
<p>设置项目中自己的名字：这里设置的名字是针对本项目的，本地设置的user.name要和服务器上的账号显示名一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置名字</span><br><span class="line">$ git config user.name &quot;你的名字&quot;</span><br><span class="line"># 设置邮箱（邮箱与全局相同可以不设置）</span><br><span class="line">$ git config user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>在git设置中注意<strong>关闭忽略大小写</strong>，这一项貌似设成全局的不管用，所以每个项目创建时都要设置一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#关闭忽略大小写</span><br><span class="line">git config core.ignorecase false</span><br></pre></td></tr></table></figure>

<p><strong>尽量使用UTF-8编码</strong></p>
<h2 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h2><p>在Git中，每个版本库都叫做一个仓库（repository，缩写repo），每个仓库可以简单理解成一个目录，这个目录里面的所有文件都通过Git来实现版本管理，Git都能跟踪并记录在该目录中发生的所有更新。</p>
<p>我们现在建立一个仓库（repo），那么在建立仓库的这个目录中会有一个”.git”的文件夹。这个文件夹非常重要，所有的版本信息、更新记录，以及Git进行仓库管理的相关信息全都保存在这个文件夹里面。所以，<strong>不要</strong>修改&#x2F;删除其中的文件，以免造成数据的丢失。</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>通过”Git Bash”命令行窗口进入到想要建立版本仓库的目录，通过<code>git init</code>就可以轻松的建立一个仓库。</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>先编写一个文件reader.txt</p>
<p>通过<code>git status</code>可以查看WorkSpace的状态，看到输出显示reader.txt没有被Git跟踪，并且提示我们可以使用”git add …”把该文件添加到待提交区（暂存区）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add reader.txt</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>通过<code>git status</code>可以查看WorkSpace的状态，这时的更新已经从WorkSpace保存到了Stage中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<p>xxx是对此操作的描述，这时的更新已经又从Stage保存到了Local Repo中。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>修改文件reader.txt</p>
<p>修改文件后，查看WorkSpace的状态，会发现提示文件有更新，但是更新只是在WorkSpace中，没有存到暂存区中。</p>
<p>同样，通过add、commit的操作，我们可以把文件的更新先存放到暂存区，然后从暂存区提交到repo中。</p>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>通过”git diff”来<strong>查看WorkSpace和Stage的diff情况</strong>，当我们把更新add到Stage中，diff就不会有任何输出了。</p>
<p>当然，我们也可以把WorkSpace中的状态跟repo中的状态进行diff，命令如下，关于HEAD，将在后面解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD~n</span><br></pre></td></tr></table></figure>

<h3 id="撤销更新"><a href="#撤销更新" class="headerlink" title="撤销更新"></a>撤销更新</h3><p>根据前面对基本概念的了解，更新可能存在三个地方，WorkSpace中、Stage中和repo中。下面就分别介绍一下怎么撤销这些更新。</p>
<ul>
<li>撤销WorkSpace中的更新</li>
</ul>
<p>即：暂存区有内容，即有未commit的内容，此操作是将暂存区覆盖到WorkSpace，即将最后没add的内容取消</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- filename</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，在使用这种方法撤销更新的时候一定要慎重，因为通过这种方式撤销后，更新将没有办法再被找回。</p>
<ul>
<li>撤销Stage中的更新</li>
</ul>
<p>即：add完成，但是还没commit</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD filename</span><br></pre></td></tr></table></figure>

<p>此时，就把暂存区的更新移出到WorkSpace中。如果想继续撤销WorkSpace中的更新，请参考上面一步。</p>
<ul>
<li>撤销repo中的更新</li>
</ul>
<p>即：commit操作完成</p>
<p>查看历史记录：通过下面的命令我们可以查看commit的历史记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure>

<p>撤销commit有两种方式：使用HEAD指针和使用commit id</p>
<p>HEAD指针指向当前分支中最新的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">$ git reset --hard 一长串数字</span><br></pre></td></tr></table></figure>

<p><strong>注：当前版本，我们使用”HEAD^”，那么再前一个版本可以使用”HEAD^^”，如果想回退到更早的提交，可以使用”HEAD<del>n”。（也就是，HEAD^&#x3D;HEAD</del>1，HEAD^^&#x3D;HEAD~2）</strong></p>
<ul>
<li>恢复撤销repo中的更新</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<p><code>git reflog</code> 查看记录在这个仓库中的<em>所有分支</em>的<em>所有更新</em>记录，包括已经撤销的更新</p>
<p>注：在”.git&#x2F;logs”文件夹内有一个HEAD文件和refs目录，这些就是记录reflog的地方</p>
<p><code>git log</code> 查看<em>当前分支</em>中的commit记录</p>
<p>有了reflog，我们就可以查找到刚才撤销的提交，然后可以通过下面命令来恢复撤销操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD@&#123;1&#125;</span><br><span class="line">$ git reset --hard 一长串数字</span><br></pre></td></tr></table></figure>

<p><em>–hard和–soft</em></p>
<blockquote>
<p>–hard：撤销并删除相应的更新<br>–soft：撤销相应的更新，把这些更新的内容放的Stage中</p>
</blockquote>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm</span><br></pre></td></tr></table></figure>

<h2 id="Git对象模型"><a href="#Git对象模型" class="headerlink" title="Git对象模型"></a>Git对象模型</h2><h3 id="Git对象"><a href="#Git对象" class="headerlink" title="Git对象"></a>Git对象</h3><p>在Git系统中有四种类型的对象，所有的Git操作都是基于这四种类型的对象。</p>
<blockquote>
<ul>
<li>“blob”：这种对象用来保存文件的内容</li>
<li>“tree”：可以理解成一个对象关系树，它管理一些”tree”和 “blob”对象</li>
<li>“commit”：只指向一个”tree”，它用来标记项目某一个特定时间点的状态。它包括一些关于时间点的元数据，如时间戳、最近一次提交的作者、指向上次提交（初始commit没有这一项）</li>
<li>“tag”：给某个提交(commit) 增添一个标记</li>
</ul>
</blockquote>
<h3 id="SHA1哈希值"><a href="#SHA1哈希值" class="headerlink" title="SHA1哈希值"></a>SHA1哈希值</h3><p>在Git系统中，每个Git对象都有一个特殊的ID来代表这个对象，这个特殊的ID就是我们所说的SHA1哈希值。</p>
<p>SHA1哈希值是通过SHA1算法（SHA算法家族的一种）计算出来的哈希值，对于内容不同的对象，会有不同的SHA1哈希值。前面讲的根据commit id撤销更新的，这里的commit id就是一个SHA1哈希值。</p>
<h3 id="Git对象模型实例"><a href="#Git对象模型实例" class="headerlink" title="Git对象模型实例"></a>Git对象模型实例</h3><ul>
<li><ol>
<li>新建一个仓库，添加一个文件</li>
</ol>
</li>
</ul>
<p>通过<code>git log --pretty=raw</code>可以得到每个commit的SHA1哈希值，也可以得到这个commit对应的tree的哈希值。</p>
<p>所以，一个commit对象一般包含以下信息：代表commit的哈希值、指向tree 对象的哈希值、作者、提交者、注释</p>
<p>在Git对象模型的研究中，有一个很有用的命令<code>git cat-file</code>，可以通过这个命令查询特定对象的信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#通过一个对象的哈希值查看对象的类型（blob、tree、commit或tag）</span><br><span class="line">$ git cat-file -t commit_id</span><br><span class="line">#通过对象的哈希值可以查看这个对象的内容</span><br><span class="line">$ git cat-file -p commit_id</span><br></pre></td></tr></table></figure>

<ul>
<li>2.更新文件，添加新东西</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=raw</span><br><span class="line">$ git cat-file</span><br></pre></td></tr></table></figure>

<h2 id="git目录"><a href="#git目录" class="headerlink" title=".git目录"></a>.git目录</h2><p>进入.git目录，通过<code>ls -l</code>查看.git目录中的文件和子目录</p>
<blockquote>
<ul>
<li>(D) hooks：这个目录存放一些<strong>shell脚本</strong>，可以设置特定的git命令后触发相应的脚本；在搭建gitweb系统或其他git托管系统会经常用到hook script</li>
<li>(D) info：包含仓库的一些<strong>信息</strong></li>
<li>(D) logs：保存所有更新的<strong>引用记录</strong></li>
<li>(D) objects：所有的<strong>Git对象</strong>都会存放在这个目录中，对象的SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名</li>
<li>(D) refs：这个目录一般包括三个子文件夹：heads、remotes和tags，heads中的文件标识了项目中的各个分支指向的当前commit</li>
<li>(F) COMMIT_EDITMSG：保存<strong>最新的commit message</strong>，Git系统不会用到这个文件，只是给用户一个参考</li>
<li>(F) config：这个是Git仓库的<strong>配置文件</strong></li>
<li>(F) description：仓库的<strong>描述信息</strong>，主要给gitweb等git托管系统使用</li>
<li>(F) index：这个文件就是我们前面文章提到的<strong>暂存区（stage）</strong>，是一个二进制文件</li>
<li>(F) HEAD：这个文件包含了一个<strong>当前分支</strong>（branch）的引用，通过这个文件Git可以得到下一次commit的parent</li>
<li>(F) ORIG_HEAD：HEAD指针的<strong>前一个</strong>状态</li>
</ul>
</blockquote>
<h3 id="Git引用"><a href="#Git引用" class="headerlink" title="Git引用"></a>Git引用</h3><p>Git系统中的分支名、远程分支名、tag等都是指向某个commit的引用。比如master分支，origin&#x2F;master远程分支，命名为V1.0.0.0的tag等都是引用，它们通过保存某个commit的SHA1哈希值指向某个commit。</p>
<ul>
<li>HEAD</li>
</ul>
<p>HEAD也是一个引用，一般情况下间接指向你当前所在的分支的<strong>最新的commit</strong>上。</p>
<p>HEAD跟Git中一般的引用不同，它并不包含某个commit的SHA1哈希值，而是包含当前所在的分支，所以HEAD直接指向当前所在的分支，然后间接指向当前所在分支的最新提交。</p>
<ul>
<li>Git索引（index）</li>
</ul>
<p>index（索引）显示一个存放了已排序的路径的二进制文件，并且每个路径都对应一个SHA1哈希值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#显示index文件的内容</span><br><span class="line">$ git ls-files --stage</span><br></pre></td></tr></table></figure>

<p>从命令的输出可以看到，所有的记录都对应仓库中的文件（包含全路径）。通过<code>git cat-file</code>命令查看reader.txt对应的哈希值，可以看到这个哈希值就是代表reader.txt的blob对象。</p>
<p>现在我们更新之前的文件，加上新内容并通过”git add”添加到暂存区，这时发现index中之前对象的哈希值已经变化了。</p>
<p>通过这个例子，我们也可以理解diff操作应该会有怎样的输出了：</p>
<blockquote>
<p>git diff：比较WorkSpace和stage，add之前有diff输出；add之后没有diff输出<br>git diff HEAD：比较WorkSpace和repo，add之前之后都有diff输出<br>git diff –cached：比较stage和repo，add之前没有diff输出；add之后有diff输出</p>
</blockquote>
<h3 id="对象的存储"><a href="#对象的存储" class="headerlink" title="对象的存储"></a>对象的存储</h3><p>前面提到所有的Git对象都会存放在”.git&#x2F;objects”目录中，对象SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名。</p>
<p>所以，我们前面提到的master上最新的commit对象的哈希值是”4ea6c317a67e73b0befcb83c36b915c1481f2efe”，那么这个对象会被存储在”.git&#x2F;objects&#x2F;4e&#x2F;a6c317a67e73b0befcb83c36b915c1481f2efe”。进入objects目录后，我们确实找到了这个文件。<br>在Git系统中有两种对象存储的方式，松散对象存储和打包对象存储。</p>
<ul>
<li>松散对象（loose object）</li>
</ul>
<p>松散对象存储就是前面提到的，每一个对象都被写入一个单独文件中，对象SHA1哈希值的前两位是文件夹名称，后38位作为对象文件名。</p>
<ul>
<li>打包对象（packed object）</li>
</ul>
<p>对于松散存储，把每个文件的每个版本都作为一个单独的对象，它的效率比较低，而且浪费空间。所以就有了通过打包文件（packfile）的存储方式。</p>
<p>Git使用打包文件(packfile)去节省空间.。在这个格式中,，Git只会保存第二个文件中改变了的部分，然后用一个指针指向相似的那个文件。</p>
<p>一般Git系统会自动完成打包的工作，在已经发生过打包的Git仓库中，”.git&#x2F;objects&#x2F;pack”目录下会成对出现很多”pack-***.idx”和”pack-***.pack”文件。</p>
<h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><p>在代码版本控制工具中，都会有branch的概念。刚开始建立版本仓库的时候，我们只有一个主分支（master branch），我们不可能把日常的新功能开发、代码优化以及bug修复等概念工作全都放在主分支上，这样会使主分支很难维护。这就是为什么会有branch。</p>
<h3 id="分支的创建"><a href="#分支的创建" class="headerlink" title="分支的创建"></a>分支的创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev //创建并切换到分支dev</span><br><span class="line">#相当于：</span><br><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure>

<p>查看当前分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure>

<p><strong>注：checkout – 表示还原，checkout 表示切换。</strong></p>
<p>可以<code>git log</code>查看一下</p>
<h3 id="分支的删除"><a href="#分支的删除" class="headerlink" title="分支的删除"></a>分支的删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure>

<h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>branch的创建是为了方便开发、修复bug以及保持master的稳定。但是最终branch上的内容还是要合并到master的，接下来就看看分支的合并。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#合并到master上</span><br><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure>

<p><strong>注意：一定要先切换回master分支<code>git checkout master</code>后再合并。</strong></p>
<h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>在branch的合并中，很多时候我们会遇到冲突，那么我们就需要手动解决冲突，然后再提交了。</p>
<p>为了演示冲突合并，我们回退master到上一次提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD~1</span><br></pre></td></tr></table></figure>

<p>然后在master分支上修改reader.txt，之后add、commit</p>
<p>这时我们在合并master和dev上的内容，就会出现冲突。</p>
<p>在Git中，会用”&lt;&lt;&lt;&lt;&lt;&lt;&lt;”，”&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;”，”&gt;&gt;&gt;&gt;&gt;&gt;&gt;”标记出冲突区域，我们需要根据这些符号找到所有的冲突并解决，之后再次add、commit即可。</p>
<p>查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>

<ul>
<li>–graph：显示commit的历史，包括不同分支的提交</li>
<li>–pretty&#x3D;oneline：只显示一行提交的信息； 多行：–pretty&#x3D;raw</li>
<li>–abbrev-commit：以精简的方式显示commit的哈希值</li>
</ul>
<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>在branch的使用过程中，我们还会经常使用到stash和diff操作，下面分别进行介绍。</p>
<p>在Git中，stash是个很有用的命令，可以保存我们做到一半的工作，可以理解成一个未完成工作的保存区。</p>
<p>假如我们在dev branch做了一些更新，但是想做的事情还没有全部完成，不能提交，这时我们又要切换到master branch，此时Git会禁止branch切换。</p>
<p>这个时候我们就需要使用stash来保存未完成的工作了。</p>
<p><strong>注：在要保存的分支上进行stash操作。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 保存未提交的内容</span><br><span class="line">$ git stash</span><br><span class="line"># 查看所有stash内容</span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>

<p>此时，我们就可以在其他分支上继续做别的工作了。</p>
<p>当其他工作完成，想回来继续刚才的操作的时候，我们可以通过<code>git stash apply</code>还原被保存的工作状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看dev分支的状态</span><br><span class="line">$ git status</span><br><span class="line"># 还原被保存的工作</span><br><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure>

<p>stash空间就像是一个栈空间，每次通过stash保存等内容都会被压入stash栈。命令不仅仅是支持简单的list、apply操作，接下来我们看看更多的stash命令。</p>
<ul>
<li><code>git stash save</code>可以通过自定义的信息来描述一个stash</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash save &quot;Reupdate reader.txt&quot;</span><br><span class="line">#再次查看当前stash的内容</span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>

<ul>
<li><code>git stash apply stash@&#123;n&#125;</code>通过这个命令，我们可以选择stash栈中的stash，从而恢复到特定的状态；”git stash apply”使用栈顶来还原WorkSpace。</li>
<li><code>git stash pop</code>就像”git stash apply”使用栈顶来还原WorkSpace，但是同时会从stash栈中删除当前的栈顶stash。</li>
</ul>
<h3 id="branch之间的diff"><a href="#branch之间的diff" class="headerlink" title="branch之间的diff"></a>branch之间的diff</h3><p>在前面的文章中我们通过diff比较过同一个分支上的内容在WrokSpace、stage和repo中的差别。</p>
<p>同样diff可以支持分支之间的比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff branchName`把当前branch跟branchName进行比较，也可以使用`git diff branchNameA branchNameB</span><br></pre></td></tr></table></figure>

<p><code>git diff branchName -- fileName</code>比较两个branch的fileName文件差异</p>
<hr>
<h2 id="Git-远程仓库"><a href="#Git-远程仓库" class="headerlink" title="Git 远程仓库"></a>Git 远程仓库</h2><p>前面文章中出现的所有Git操作都是基于本地仓库的，但是日常工作中需要多人合作，不可能一直都在自己的代码仓库工作。所以，这里我们就开始介绍Git远程仓库。</p>
<p>在Git系统中，用户可以通过push&#x2F;pull命令来推送&#x2F;获取别的开发人员的更新，当时对于一个工作组来说，这种方式会效率比较低。所以，在一个Git系统中，都会有一个中心服务器，大家都通过中心服务器来推送&#x2F;获取更新。</p>
<p>为了方便本篇例子的进行，我就使用多个目录来模拟多个用户以及中心服务器，这样就不用搭建Git服务器了。</p>
<p>中心服务器：C:\VM\CentralRepo</p>
<p>用户A：C:\VM\AWorkSpace</p>
<p>用户B：C:\VM\BWorkSpace</p>
<h3 id="建立中心服务器（服务器文件）"><a href="#建立中心服务器（服务器文件）" class="headerlink" title="建立中心服务器（服务器文件）"></a>建立中心服务器（服务器文件）</h3><p>前面通过<code>git init</code>来建立一个Git仓库，这里，我们使用<code>git init --bare</code>来建立中心仓库。</p>
<p><code>git init --bare</code>方法创建的是一个裸仓库，之所以叫裸仓库是因为这个仓库只保存Git历史提交的版本信息，而不允许用户在上面进行各种git操作。</p>
<p>之所以有裸仓库，是因为用<code>git init</code>初始化的版本库，用户也可以在该目录下执行所有git方面的操作。但别的用户在将更新push上来的时候容易出现冲突。在这种情况下，最好就是使用”–bare”选项建立一个裸仓库。</p>
<h3 id="Clone一个仓库-（A仓库的位置）"><a href="#Clone一个仓库-（A仓库的位置）" class="headerlink" title="Clone一个仓库 （A仓库的位置）"></a>Clone一个仓库 （A仓库的位置）</h3><p>在Git中，我们有两种方式建立Git仓库：一个是通过<code>git init</code>建立一个新的仓库，另一个是通过<code>git clone</code>命令clone一个已有的Git仓库。</p>
<p>既然中心服务器，用户A就可以通过clone命令来复制一个Git仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone /c/vm/CentralRepo/ #被clone的仓库的地址</span><br></pre></td></tr></table></figure>

<p>这时，用户A就从中心服务器clone了一个空的仓库，接下来A就可以在这个本地仓库工作了。</p>
<h3 id="更新的push和pull"><a href="#更新的push和pull" class="headerlink" title="更新的push和pull"></a>更新的push和pull</h3><p>现在A在本地仓库中添加了一个”calc.py”的文件，并且提交到了本地仓库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add calc.py</span><br><span class="line">$ git commit -m &quot;add calc file&quot;</span><br></pre></td></tr></table></figure>

<p>为了使其他用户可以得到这个更新，A需要把这个更新push到中心服务器上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>现在用户B可以通过clone方式获得心服务器上的仓库副本，通过”git log”显示A的更新已经自动被clone了下来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone /c/vm/CentralRepo/</span><br><span class="line">$ cd CentralRepo</span><br><span class="line">$ git log</span><br></pre></td></tr></table></figure>

<p>现在，B提交了一个新的更新，那么A就可以通过<code>git pull</code>从中心服务器得到这个更新</p>
<h2 id="上游仓库-upstream-repository"><a href="#上游仓库-upstream-repository" class="headerlink" title="上游仓库(upstream repository)"></a>上游仓库(upstream repository)</h2><p>在Git系统中，通常用”origin” 来表示上游仓库。我们可以通过 <code>git branch -r</code>命令查看上游仓库里所有的分支，再用 origin&#x2F;name-of-upstream-branch 的名字来抓取(fetch)远程追踪分支里的内容。</p>
<p>中心服务器上建立两个新的”dev1”和”dev2”分支，通过<code>git pull</code> ，用户B就看到了这些上游分支。</p>
<h3 id="–set-upstream-to"><a href="#–set-upstream-to" class="headerlink" title="–set-upstream-to"></a>–set-upstream-to</h3><p>当我们在本地仓库建立一个branch的时候，我们的pull操作会遇到以下问题，提示我们这个branch没有任何的跟踪信息。仔细想想也是，我们应该把本地仓库中的分支与上游分支关联起来。这时，我们就可以根据Git的提示，使用”–set-upstream-to”命令进行关联了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 先在B上创建同名分支</span><br><span class="line">$ git checkout -b dev1</span><br><span class="line"># 拉取</span><br><span class="line">$ git pull # 出错！</span><br><span class="line"># 本地仓库中的分支与上游分支关联起来</span><br><span class="line">$ git branch --set-upstream-to=origin/dev1 dev1</span><br><span class="line"># 此时拉取就能成功了</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<p>还可以通过下面的命令创建关联分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#一般，&quot;localBranchName&quot;名称跟&quot;remoteBranchName&quot;名称设置成一样。</span><br><span class="line">$ git checkout -b localBranchName origin/remoteBranchName</span><br></pre></td></tr></table></figure>

<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>在Git中patch绝对是一个很有用的东西。假设在一个没有网络的环境中，A和B还要继续工作，这时B有一个更新，A需要基于这个更新进行下一步的工作。如果是集中式的代码版本工具，这种情况就没有办法工作了，但是在Git中，我们就可以通过patch的方式，把B的更新拷贝给A。</p>
<p>在Git中有两种patch的方式</p>
<ul>
<li><p>通过<code>git diff</code>生成一个标准的patch</p>
</li>
<li><p>通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git format-patch</span><br></pre></td></tr></table></figure>

<p>生成一个Git专用的patch。</p>
</li>
<li><p>基于<code>git diff</code>的patch</p>
</li>
</ul>
<p>假设现在B更新”calc.py”文件并且通过<code>git diff</code>生成了一个patch。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># B更新后，通过`git diff `查看B的更新</span><br><span class="line">$ git diff</span><br><span class="line"># 把diff的结果保存到一个文件中，生成一个patch</span><br><span class="line">$ git diff &amp;gt; BPatch</span><br></pre></td></tr></table></figure>

<p>下面，我们把 BPatch这个文件拷贝到A的工作目录中，然后通过<code>git apply</code>应用这个patch，从而得到B的更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># A通过`git apply`命令应用BPatch得到了B的更新</span><br><span class="line">$ git apply BPatch</span><br><span class="line"># 通过`git diff`查看B的更新</span><br><span class="line">$ git diff</span><br></pre></td></tr></table></figure>

<ul>
<li>基于<code>git format-patch</code>的patch</li>
</ul>
<p>B更新提交之后，使用”git format-patch”来生成patch。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git format-patch origin/master</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>git format-patch</code>命令的参数”origin&#x2F;master”，这个参数的含义是，找出当前master跟origin&#x2F;master之间的差别，然后生成一个patch，比如：0001-update-calc.py.patch。</p>
<p>把patch文件拷贝到A的工作目录，则此我们通过”git am”命令来应用这个patch。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 应用patch</span><br><span class="line">$ git am 0001-update-calc.py.patch</span><br><span class="line"># 再查看日志</span><br><span class="line">$ git log</span><br></pre></td></tr></table></figure>

<ul>
<li>两种patch方式的比较</li>
</ul>
<blockquote>
<p>patch兼容性：<code>git diff</code>生成的patch兼容性强。也就是说，如果别人的代码版本库不是Git，那么必须使用git diff生成的patch才能被别的版本控制系统接受。<br>patch合并提示：对于<code>git diff</code>生成的patch，你可以用git apply –check 查看patch是否能够干净顺利地应用到当前分支中；如果<code>git format-patch</code>生成的patch不能打到当前分支，git am会给出提示，帮你解决冲突，两者都有较好的提示功能。<br>patch信息管理：通过<code>git format-patch</code>生成的patch中有很多信息，比如开发者的名字，因此在应用patch时，这个名字会被记录进版本库，这样做是比较合理的。</p>
</blockquote>
<h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>项目中可能会经常生成一些Git系统不需要追踪(track)的文件，在编译生成过程中 产生的文件或是编程器生成的临时备份文件。我们可以在使用”git add”是避免添加这些文件到暂存区中，但是每次都这么做会比较麻烦。</p>
<p>所以，为了满足上面的需求，Git系统中有一个忽略特定文件的功能。我们可以在工作目录中添加一个叫”.gitignore”的文件，j将要忽略的内容写进文件，来告诉Git系统要忽略哪些文件。</p>
<p><strong>注意：</strong></p>
<ul>
<li>在windows环境中不支持文件名为”.gitignore”，所以可以把文件命名为”.gitignore.”</li>
<li>“.gitignore”文件只会对当前目录以及所有当前目录的子目录生效；也就是说如果我们把”.gitignore”文件移到”advance”文件夹中，那么过滤规则就是会对”advance”及其子目录生效了</li>
<li>建议把”.gitignore”文件提交到仓库里，这样其他的开发人员也可以共享这套过滤规则</li>
</ul>
<h4 id="过滤语法"><a href="#过滤语法" class="headerlink" title="过滤语法"></a>过滤语法</h4><ul>
<li>斜杠”&#x2F;“开头表示目录</li>
<li>星号”*”通配多个字符</li>
<li>问号”?”通配单个字符</li>
<li>方括号”[]”包含单个字符的匹配列表</li>
<li>叹号”!”表示不忽略匹配到的文件或目录<br>下面举一些简单的例子：</li>
<li>foo&#x2F;*：忽略目录 foo下的全部内容</li>
<li>*.[oa]：忽略所有.o和.a文件</li>
<li>!calc.o：不能忽略calc.o文件</li>
</ul>
<h2 id="远程仓库命令"><a href="#远程仓库命令" class="headerlink" title="远程仓库命令"></a>远程仓库命令</h2><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><ul>
<li><code>git branch -r</code> 列出远程分支</li>
<li><code>git branch -a</code> 列出所有分支</li>
</ul>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><ul>
<li><code>git remote</code> 列出所有远程主机</li>
<li><code>git remote -v</code>列出所有远程主机，并显示远程主机地址</li>
</ul>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>push命令用来将本地分支的更新推送的远程仓库，该命令的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>

<p>通过”git push”更新、创建、删除远程分支</p>
<ul>
<li><code>git push origin dev1:dev1</code> 将本地dev1分支推送到远程origin的dev1分支上</li>
<li><code>git push origin dev1</code> 省略远程分支名时，推送到远程origin下的同名（dev1）分支上</li>
<li><code>git push origin dev0</code> 如果远程分支不存在，则创建一个同名远程分支与本地分支相关联</li>
<li><code>git push origin :dev1</code> 省略本地分支名时，表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。等价于<code>git push origin --delete dev1</code>，只是删除了远程分支，本地还有~</li>
</ul>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>pull命令的作用是取回远程某个分支的更新，然后合并到指定的本地分支，pull命令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p><code>git pull origin dev1:dev1</code>：取回origin主机dev1分支的更新，与本地的dev1分支合并。</p>
<p>一般来说，pull命令都是在关联的本地分支和远程分支之间进行；当然，你可以使用不关联的本地分支和远程分支进行pull操作，但是不建议这么做。</p>
<p>省略本地分支名：git pull origin dev1，表示取回origin&#x2F;dev1远程分支的更新，然后合并到当前分支</p>
<p>如果当前分支存在上游（关联）分支，可以直接使用git pull origin</p>
<p><code>git pull</code>操作实际上等价于，先执行<code>git fetch</code>获得远程更新，然后<code>git merge</code>与本地分支进行合并。</p>
<p>pull命令也支持使用rebase模式进行合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>git pull</code>就等价于<code>git fetch</code>加上<code>git rebase</code>。</p>
<p>建议使用”git fetch”加上”git rebase”的方式来取代”git pull”获取远程更新。</p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>fetch命令比较简单，作用就是将远程的更新取回到本地。</p>
<p><code>git fetch origin</code>表示将远程origin主机的所有分支上的更新取回本地</p>
<p><code>git fetch origin master</code>只取回远程origin主机上master分支上的更新</p>
<h2 id="Git-的merge和-rebase"><a href="#Git-的merge和-rebase" class="headerlink" title="Git 的merge和 rebase"></a>Git 的merge和 rebase</h2><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>merge命令会有三种情况发生：</p>
<ol>
<li>merge命令不生效</li>
</ol>
<p>当前分支已经是最新的了，在这种情况下merge命令没有任何效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure>

<p>提示”Already up-to-date.”，表示merge不生效，因为master比dev还要新，就不用merge了。</p>
<ol>
<li>Fast-forward合并模式</li>
</ol>
<p><code>git merge --no-ff master</code> 合并master时可以禁止Fast-forward， 以保留版本演进的历史信息，否则commit仍然是线性的</p>
<ol>
<li>三方合并：不使用！</li>
</ol>
<h4 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h4><p>在实际应用中，我们可能会经常碰到这种情况，在分支A上提交了一个更新，但是后来发现我们同样需要在分支B上应用这个更新。那么这时cherry-pick就可以帮助你解决问题。</p>
<p>我们要做的就是通过<code>git reflog</code>找到A上那个更新的SHA1哈希值，然后切换到<strong>B分支上</strong>使用<code>git cherry-pick</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#假设A上的更新是00abc3f</span><br><span class="line">$ git cherry-pick 00abc3f</span><br></pre></td></tr></table></figure>

<p>如果出错，按提示修改，先进行手动合并冲突，之后<code>git add</code>，然后继续cherry-pick，<code>git cherry-pick --continue</code>即可。</p>
<p>如果想要终止cherry-pick：<code>git cherry-pick --abort</code></p>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>在merge的过程中，比较好的就是我们可以看到分支的历史信息，但是，如果分支很多的时候，这个分支历史可能就会变得很复杂了。如果我们使用rebase，那么提交的历史会保持线性。</p>
<p>rebase的原理：先将当前分支的HEAD引用指向目标分支和当前分支的共同祖先commit节点，然后将当前分支上的commit一个个apply到目标分支上，apply完以后再将HEAD引用指向当前分支。是不是有点绕，下面我们看个实例。<br>下面就开始rebase的介绍，我们会基于master新建一个release-1.0的分支，并在该分支上提交一个更新。</p>
<p>这时，我们在release-1.0分支上执行”git rebase master”，就会得到下面的对象关系图。</p>
<p>根据rebase的工作原理进行分析：<br>把当前分支的HEAD引用指向”00abc3f”<br>然后将当前分支上的commit一个个apply到目标分支，这里就是把”ed53897”更新apply到master上；注意，如果没有冲突，这里将直接生成一个新的更新<br>最后更新当前分支的HEAD引用执行最新的提交”8791e3b”<br>这个就是rebase操作，可以看到通过rebase操作的话，我们的commit历史会一直保持线性。在这种情况下，当我们切换到master分支，然后进行”git merge release-1.0”分支合并时，master将会直接是Fast-forward合并模式，commit历史也会是线性的。<br>当然rebase操作也会产生冲突，当一个冲突发生的时候，我们可以skip过当前的patch（一定要当心，不要随便使用，以免丢失更新）；也可以手动的解决冲突，然后继续rebase操作</p>
<p>rebase交互模式<br>其实，rebase还有别的很强大功能，比如rebase交互模式，通过交互模式我们可以改变commit的信息，删除commit，合并commit以及更改commit的顺序等等。<br>假如我们现在想要更新一个commit的信息，我们就可以使用rebase交互模式，找到commit的哈希值，然后进入交互模式。</p>
<p>根据rebase的操作提示，我们选择edit操作，然后保存退出。</p>
<p>这时，Git将会提示我们，是进行更改，还是可以继续操作。这里我们通过”git commit –amend”进入编辑模式。</p>
<p>在编辑模式中对commit进行更新，然后保存退出，继续rebase操作。</p>
<p>关于rebase交互模式的其他命令，这里就不做介绍了，有兴趣的同学可以google一下。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章主要对merge和rebase进行了介绍。对于最终的结果而言，rebase和merge是没有区别的，不会发生rebase和merge导致最终更新不一致的情况。<br>rebase和merge的差别主要是：<br>rebase更清晰，因为commit历史是线性的，但commit不一定按日期先后排，而是当前分支的commit总在后面（参考rebase原理）<br>merge之后commit历史变得比较复杂，并且一定程度上反映了各个分支的信息，而且 commit按日期排序的。<br>大家可以根据自己的项目需求进行选择使用哪种方式拉取远程的更新。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/03/08/qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/08/qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Qt学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-08 21:22:49" itemprop="dateCreated datePublished" datetime="2018-03-08T21:22:49+08:00">2018-03-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/03/08/qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/08/qt学习笔记/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="QT学习"><a href="#QT学习" class="headerlink" title="QT学习"></a>QT学习</h1><h2 id="什么是QT"><a href="#什么是QT" class="headerlink" title="什么是QT"></a>什么是QT</h2><p>Qt是一个1991年由奇趣科技开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展（称为元对象编译器(Meta Object Compiler, moc)）以及一些宏，易于扩展，允许组件编程。2008年，奇趣科技被诺基亚公司收购，QT也因此成为诺基亚旗下的编程语言工具。2012年，Qt被Digia收购。2014年4月，跨平台集成开发环境Qt Creator 3.1.0正式发布，实现了对于iOS的完全支持，新增WinRT、Beautifier等插件，废弃了无Python接口的GDB调试支持，集成了基于Clang的C&#x2F;C++代码模块，并对Android支持做出了调整，至此实现了全面支持iOS、Android、WP。</p>
<blockquote>
<p>学习视频教程网站<a target="_blank" rel="noopener" href="http://my.tv.sohu.com/pl/5176735/">http://my.tv.sohu.com/pl/5176735/</a></p>
</blockquote>
<h2 id="QT-x2F-安装步骤-x2F-环境搭建"><a href="#QT-x2F-安装步骤-x2F-环境搭建" class="headerlink" title="QT&#x2F;安装步骤&#x2F;环境搭建"></a>QT&#x2F;安装步骤&#x2F;环境搭建</h2><p>下面介绍Windows版QT开发环境Qt Creater + MinGW + Qt libraries配置方法</p>
<h3 id="下载安装MinGW"><a href="#下载安装MinGW" class="headerlink" title="下载安装MinGW"></a>下载安装MinGW</h3><p>从MinGW网站下载，默认安装到C盘根目录下：C:\MinGW，安装时选择C和C++ compiler，默认只选中了C编译器。</p>
<h3 id="下载安装配置QT-libraries"><a href="#下载安装配置QT-libraries" class="headerlink" title="下载安装配置QT libraries"></a>下载安装配置QT libraries</h3><p><a target="_blank" rel="noopener" href="http://qt-project.org/downloads">http://qt-project.org/downloads</a></p>
<p>默认安装路径为C:\Qt\4.8.3，安装时需要指定MinGW的安装路径为C:\MinGW。</p>
<p>安装完后需要把C:\Qt\4.8.3\bin目录添加到系统变量的Path路径中。</p>
<p>并新建系统环境变量QMAKESPEC，32位系统把值设置为C:\Qt\4.8.3\mkspecs\win32-g++；如果是64位系统，需要把值设置为C:\Qt\4.8.3\mkspecs\tru64-g++</p>
<p>还要新建系统环境变量QTDIR，值为C:\Qt\4.8.3</p>
<h3 id="下载安装配置QT-Creater"><a href="#下载安装配置QT-Creater" class="headerlink" title="下载安装配置QT Creater"></a>下载安装配置QT Creater</h3><p>默认安装到C:\Qt\qtcreator-2.6.0目录下。</p>
<p>需要把C:\Qt\qtcreator-2.6.0\bin目录添加到系统变量的Path路径中。如果不设置系统环境变量，则创建工程时kit不能设置成功，并且可创建的工程类型也会受到限制。</p>
<p>设置QT Creator构建和运行配置项：打开QT Creator，选择菜单“工具&#x2F;选项”，选择左边的”构建和运行”，再选择“Qt版本”选项卡，点击“添加”，qmake路径：C:\Qt\4.8.3\bin\qmake.exe。</p>
<p>还需要设置Compilers选项卡中的“手动设置”项的编译器，Name设置为MinGW，编译器路径设置为C:\MinGW\bin\mingw32-g++.exe。</p>
<h3 id="hello-word程序"><a href="#hello-word程序" class="headerlink" title="hello word程序"></a>hello word程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;qcoreapplication&gt;</span><br><span class="line">#include&lt;qdebug&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">QCoreApplication a(argc, argv);&lt;/qdebug&gt;&lt;/qcoreapplication&gt;</span><br><span class="line"></span><br><span class="line">qDebug()&lt;&lt;&quot;hello world&quot;;</span><br><span class="line">return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用界面标签显示Hello-World"><a href="#用界面标签显示Hello-World" class="headerlink" title="用界面标签显示Hello World"></a>用界面标签显示Hello World</h3><p>新建—&gt;其他项—&gt;空的QT项目—&gt;c++ source</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">###basic application and HTML WIDEGTS</span><br><span class="line">#include&lt;qapplication&gt;</span><br><span class="line">#include&lt;qlabel&gt;</span><br><span class="line">int main(int argc ,char *argv[])</span><br><span class="line">&#123;&lt;/qlabel&gt;&lt;/qapplication&gt;</span><br><span class="line"></span><br><span class="line">QApplication app(argc, argv);</span><br><span class="line">QLabel *label =new QLabel(&quot;Hello World&quot;);//显示Hello World</span><br><span class="line">label-&gt;show();</span><br><span class="line">return app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pushButton按钮"><a href="#pushButton按钮" class="headerlink" title="pushButton按钮"></a>pushButton按钮</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">QMainWindow(parent),</span><br><span class="line">ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">ui-&amp;gt;setupUi(this);</span><br><span class="line">ui-&amp;gt;pushButton-&amp;gt;setText(&quot;close&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加事件—&gt;信号槽—&gt;<code>clicked()</code>—&gt;<code>close()</code>, 这是直接在控件操作的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Dialog::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">QMessageBox::information(this,&quot;hello world&quot;,&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和MFC中的<code>messagebox()</code>,效果一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Dialog::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//QMessageBox::information(this,&quot;hello world&quot;,&quot;hello world&quot;);</span><br><span class="line">ui-&gt;lineEdit-&gt;setText(&quot;Hello world!&quot;);</span><br><span class="line">ui-&gt;lineEdit_2-&gt;setText(&quot;sssssss&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按一下按钮就在EDIT上面显示字符串”hello world”.</p>
<h3 id="Signal和slot程序"><a href="#Signal和slot程序" class="headerlink" title="Signal和slot程序"></a>Signal和slot程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">QMainWindow(parent),</span><br><span class="line">ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">ui-&amp;gt;setupUi(this);</span><br><span class="line">connect(ui-&amp;gt;horizontalSlider,SIGNAL(valueChanged(int)),ui-&amp;gt;progressBar,SLOT(setValue(int)));//添加信号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接用信号槽和上面的一样</p>
<p>如果再加一条工程条，则代码一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(ui-&amp;gt;horizontalSlider,SIGNAL(valueChanged(int)),ui-&amp;gt;progressBar_2,SLOT(setValue(int)));</span><br></pre></td></tr></table></figure>

<p>只是其中的名字发生了改变<code>ui-&gt;progressBar</code>–&gt;<code>ui-&gt;progressBar_2</code></p>
<p>下面为取消信号槽</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disconnect(ui-&gt;horizontalSlider,SIGNAL(valueChanged(int)),ui-&gt;progressBar_2,SLOT(setValue(int)));</span><br></pre></td></tr></table></figure>

<h3 id="显示对话框"><a href="#显示对话框" class="headerlink" title="显示对话框"></a>显示对话框</h3><p>首先先创立工程文件 DialogTest—-&gt;然后点“在这里输入”—–&gt;”输入File”——&gt;在File下面输入所需要的列表”New Window”——-&gt;在界面上拖入文本框</p>
<p>然后执行下列程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setCentralWidget(ui-&gt;plainTextEdit);//是文本框左右充满整个mainwindow</span><br></pre></td></tr></table></figure>

<p>在DialogTest下面添加新的类MyDialog</p>
<p>然后在”New Window”添加触发事件<code>trigged()</code></p>
<p>下面往里面添加代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_actionNew_Window_triggered()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">MyDialog dialog;</span><br><span class="line"></span><br><span class="line">// dialog.setModal(true);</span><br><span class="line">// dialog.exec();//显示Dialog（第一种显示方法）</span><br><span class="line">dialog.show();这样直接是不好使的，dialog一闪就没</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种dialog显示是在MainWindow类下直接写<code>#include &quot;mydialog.h&quot;</code></p>
<p>然后在mainwindow.h里面private中声明<code>MyDialog *mydialog</code></p>
<p>然后直接在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_actionNew_Window_triggered()</span><br><span class="line">&#123;</span><br><span class="line">mydialog=new MyDialog(this);</span><br><span class="line">mydialog-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>直接创建Qdialog,添加事件。</p>
<h3 id="Basic-Application-and-HTML-Aware-Widgets"><a href="#Basic-Application-and-HTML-Aware-Widgets" class="headerlink" title="Basic Application and HTML Aware Widgets"></a>Basic Application and HTML Aware Widgets</h3><p>对之前的helloworld进行文件的变化(比如加粗或者上颜色)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;qapplication&gt;</span><br><span class="line">#include&lt;qlabel&gt;</span><br><span class="line">int main(int argc ,char *argv[])</span><br><span class="line">&#123;&lt;/qlabel&gt;&lt;/qapplication&gt;</span><br><span class="line"></span><br><span class="line">QApplication app(argc, argv);</span><br><span class="line">QLabel *label =new QLabel(&quot;&lt;b&gt;Hello&lt;/b&gt; &lt;span color=&quot;red&quot; style=&quot;color: red;&quot;&gt; &lt;i&gt;World&lt;/i&gt;&lt;/font color =red&gt;&quot;);//标签属性</span><br><span class="line">label-&gt;show();</span><br><span class="line">return app.exec();</span><br><span class="line">//QLabel *label =new QLabel(&quot;&lt;/span&gt;</span><br><span class="line">&lt;h2&gt;Hello &lt;span color=&quot;red&quot; style=&quot;color: red;&quot;&gt; &lt;i&gt;World&lt;/i&gt;&lt;/font color =red&gt;&lt;/span&gt;&lt;/h2&gt;</span><br><span class="line">&quot;);标签可以随便加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Horizontal-and-Vertical-Layouts"><a href="#Horizontal-and-Vertical-Layouts" class="headerlink" title="Horizontal and Vertical Layouts"></a>Horizontal and Vertical Layouts</h3><p>界面的布局</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;qapplication&gt;</span><br><span class="line">#include&lt;qpushbutton&gt;</span><br><span class="line">#include&lt;qhboxlayout&gt;</span><br><span class="line">#include&lt;qvboxlayout&gt;</span><br><span class="line">int main(int argc ,char *argv[])</span><br><span class="line">&#123;&lt;/qvboxlayout&gt;&lt;/qhboxlayout&gt;&lt;/qpushbutton&gt;&lt;/qapplication&gt;</span><br><span class="line"></span><br><span class="line">QApplication app(argc, argv);</span><br><span class="line">QWidget *window =new QWidget;//创建一个新的window</span><br><span class="line">window-&gt;setWindowTitle(&quot;my app&quot;);//把window的title 设置为 my app</span><br><span class="line">QPushButton *button1=new QPushButton(&quot;one&quot;);//button1名字为one</span><br><span class="line">QPushButton *button2=new QPushButton(&quot;two&quot;);</span><br><span class="line">QPushButton *button3=new QPushButton(&quot;three&quot;);</span><br><span class="line">QHBoxLayout *layout=new QHBoxLayout;//创建一个水平布局变量</span><br><span class="line">//QVBoxLayout *layout=new QVBoxLayout;//创建一个垂直布局变量</span><br><span class="line">layout-&gt;addWidget(button1);</span><br><span class="line">layout-&gt;addWidget(button2);</span><br><span class="line">layout-&gt;addWidget(button3);</span><br><span class="line">window-&gt;setLayout(layout);</span><br><span class="line">window-&gt;show();</span><br><span class="line">return app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QGridLayout"><a href="#QGridLayout" class="headerlink" title="QGridLayout"></a>QGridLayout</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;qapplication&gt;</span><br><span class="line">#include&lt;qtgui&gt;</span><br><span class="line">#include&lt;qtcore&gt;&lt;/qtcore&gt;&lt;/qtgui&gt;&lt;/qapplication&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc ,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">QApplication app(argc, argv);</span><br><span class="line">QWidget *window =new QWidget;</span><br><span class="line">window-&gt;setWindowTitle(&quot;my app&quot;);</span><br><span class="line">QGridLayout *layout=new QGridLayout;</span><br><span class="line">QLabel *label=new QLabel(&quot;Name:&quot;);</span><br><span class="line">QLineEdit *txtName=new QLineEdit;</span><br><span class="line">layout-&gt;addWidget(label,0,0);</span><br><span class="line">layout-&gt;addWidget(txtName,0,1);</span><br><span class="line">window-&gt;setLayout(layout);</span><br><span class="line">window-&gt;show();</span><br><span class="line">return app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果还要在加一行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout-&gt;addWidget(label2,1,0);//把名字改变就行，然后里面的参数也要改变</span><br><span class="line">layout-&gt;addWidget(txtName2,1,1);</span><br></pre></td></tr></table></figure>

<p>往里面添加按钮</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout-&gt;addWidget(button,2,0,1,2);//行，列 ，上下宽度，左右长度</span><br></pre></td></tr></table></figure>

<h3 id="Splitters"><a href="#Splitters" class="headerlink" title="Splitters"></a>Splitters</h3><p>Qdialog</p>
<p>用到spliter键，我们可以用两个按钮进行演示—-&gt;先用水平splider—&gt;水平布局</p>
<h3 id="QDir"><a href="#QDir" class="headerlink" title="QDir"></a>QDir</h3><p>调用<code>#include&lt;QDir&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;qcoreapplication&gt;</span><br><span class="line">#include &lt;qdebug&gt;</span><br><span class="line">#include &lt;qdir&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">QCoreApplication a(argc, argv);</span><br><span class="line">QDir m_dir(&quot;C:\\TEXT&quot;);</span><br><span class="line">qDebug() &lt;&lt; m_dir.exists();</span><br><span class="line">return a.exec();</span><br><span class="line">&#125;</span><br><span class="line">​```&lt;/qdir&gt;&lt;/qdebug&gt;&lt;/qcoreapplication&gt;</span><br><span class="line"></span><br><span class="line">其作用是判断一个某个路径下的文件是否存在</span><br><span class="line">如果存在返回“true”不存在返回&quot;false&quot;</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">QDir m_dir;</span><br><span class="line">foreach (QFileInfo M_Item,m_dir.drives())</span><br><span class="line">&#123;</span><br><span class="line">qDebug() &lt;&lt; M_Item.absoluteFilePath();//返回硬盘的路径</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这段程序为判断是否这有没”3.txt”文件，如果没有则创建，然后输出”created”，否则输出”already exists”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">QDir m_dir;</span><br><span class="line">QString m_path=&quot;C:\\3.txt&quot;;</span><br><span class="line">if(!m_dir.exists(m_path))</span><br><span class="line">&#123;</span><br><span class="line">m_dir.mkpath(m_path);</span><br><span class="line">qDebug()&lt;&lt;&quot;Created&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">qDebug()&lt;&lt;&quot;Already Exits&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">QDir m_dir;</span><br><span class="line">QString m_path=&quot;C:/&quot;;</span><br><span class="line">m_dir.setPath(m_path);</span><br><span class="line">foreach (QFileInfo m_Item, m_dir.entryInfoList())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">qDebug()&lt;&lt;m_Item.absoluteFilePath();//为查看当前下的文件目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QFile文件读写"><a href="#QFile文件读写" class="headerlink" title="QFile文件读写"></a>QFile文件读写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void write(QString Filename)//文件写</span><br><span class="line">&#123;</span><br><span class="line">QFile mFile(Filename);</span><br><span class="line">if(!mFile.open(QFile::WriteOnly|QFile::Text))</span><br><span class="line">&#123;</span><br><span class="line">qDebug()&lt;&lt;&quot;could not open the file for writting&quot;;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">QTextStream out(&amp;mFile);</span><br><span class="line">out&lt;&lt;&quot;Hello man!&quot;;</span><br><span class="line">qDebug()&lt;&lt;&quot;Write Correctly&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mFile.flush();</span><br><span class="line">mFile.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void read(QString Filename)//文件读</span><br><span class="line">&#123;</span><br><span class="line">QFile mFile(Filename);</span><br><span class="line">if(!mFile.open(QFile::ReadOnly|QFile::Text))</span><br><span class="line">&#123;</span><br><span class="line">qDebug()&lt;&lt;&quot;could not open the file for writting&quot;;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">QTextStream in(&amp;mFile);</span><br><span class="line">QString s=in.readAll();</span><br><span class="line">qDebug() &lt;&lt; s;</span><br><span class="line">qDebug() &lt;&lt; &quot;Read Correctly&quot;; &#125; mFile.close(); &#125; ``` ### CheckBox和RadioBOX、Commbox, listwidget ```c void Dialog::on_pushButton_clicked() &#123; if(ui-&amp;gt;checkBox-&amp;gt;isChecked()//ui-&amp;gt;radioBox-&amp;gt;isChecked())//判断是否已经选择 &#123; QMessageBox::information(this,&quot;&quot;,&quot;selected&quot;); &#125; else &#123; QMessageBox::information(this,&quot;&quot;,&quot;not selected&quot;); &#125; &#125; ``` ``ui-&amp;gt;comboBox-&amp;gt;addItem(&quot;123&quot;);//commbox加项`` 显示当前comboBox所选择项的文本 ```c QMessageBox::information(this,&quot;&quot;,ui-&amp;gt;comboBox-&amp;gt;currentText());</span><br></pre></td></tr></table></figure>

<p>显示当前listwidget所选择项的文本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox::information(this,&quot;hello world&quot;,ui-&amp;gt;listWidget-&amp;gt;currentItem()-&amp;gt;text());</span><br><span class="line">QListWidgetItem *item=ui-&amp;gt;listWidget-&amp;gt;currentItem();</span><br><span class="line">item-&amp;gt;setText(&quot;123&quot;);//选中当前项然后改变的文本</span><br><span class="line">item-&amp;gt;setTextColor(Qt::red);//把当前文本变成红色</span><br></pre></td></tr></table></figure>

<h3 id="qtreewidget"><a href="#qtreewidget" class="headerlink" title="qtreewidget"></a>qtreewidget</h3><p>首先在Dialog.h里面声明两个函数 （addroot 和 addchild）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void AddRoot(QString name, QString Description);</span><br><span class="line">void AddChild(QTreeWidgetItem *parent, QString name, QString Description);</span><br></pre></td></tr></table></figure>

<p>然后在构造函数里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ui-&amp;gt;treeWidget-&amp;gt;setColumnCount(2);</span><br><span class="line">AddRoot(&quot;HELLO&quot;,&quot;WORLD&quot;);</span><br><span class="line">AddRoot(&quot;2&quot;,&quot;3&quot;);</span><br><span class="line">void Dialog::AddRoot(QString name ,QString Description)</span><br><span class="line">&#123;</span><br><span class="line">QTreeWidgetItem *itm=new QTreeWidgetItem(ui-&amp;gt;treeWidget);</span><br><span class="line">itm-&amp;gt;setText(0,name);</span><br><span class="line">itm-&amp;gt;setText(1,Description);</span><br><span class="line">ui-&amp;gt;treeWidget-&amp;gt;addTopLevelItem(itm);//这如果删除会产生什么情况</span><br><span class="line">AddChild(itm,&quot;one&quot;,&quot;hello&quot;);</span><br><span class="line">AddChild(itm,&quot;two&quot;,&quot;world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void Dialog::AddChild(QTreeWidgetItem *parent,QString name,QString Description)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">QTreeWidgetItem *itm=new QTreeWidgetItem(ui-&amp;gt;treeWidget//这如果删除会产生什么情况);</span><br><span class="line">itm-&amp;gt;setText(0,name);</span><br><span class="line">itm-&amp;gt;setText(1,Description);</span><br><span class="line">parent-&amp;gt;addChild(itm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AddRoot()中加入AddChild()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Dialog::AddRoot(QString name, QString Description)</span><br><span class="line">&#123;</span><br><span class="line">QTreeWidgetItem *itm=new QTreeWidgetItem(ui-&amp;gt;treeWidget);</span><br><span class="line">itm-&amp;gt;setText(0,name);</span><br><span class="line">itm-&amp;gt;setText(1,Description);</span><br><span class="line">ui-&amp;gt;treeWidget-&amp;gt;addTopLevelItem(itm);</span><br><span class="line">AddChild(itm,&quot;one&quot;,&quot;hello&quot;);</span><br><span class="line">AddChild(itm,&quot;two&quot;,&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>button里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Dialog::on_pushButton_clicked()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ui-&amp;gt;treeWidget-&amp;gt;currentItem()-&amp;gt;setBackgroundColor(0,Qt::red);//设置第一排颜色为red</span><br><span class="line">ui-&amp;gt;treeWidget-&amp;gt;currentItem()-&amp;gt;setBackgroundColor(1,Qt::yellow);//设置第一排颜色为yellow</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置头标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Dialog::Dialog(QWidget *parent) :</span><br><span class="line">QDialog(parent),</span><br><span class="line">ui(new Ui::Dialog)</span><br><span class="line">&#123;</span><br><span class="line">ui-&amp;gt;setupUi(this);</span><br><span class="line"></span><br><span class="line">ui-&amp;gt;treeWidget-&amp;gt;setColumnCount(2);</span><br><span class="line">//ui-&amp;gt;treeWidget-&amp;gt;setHeaderLabel(&quot;123&quot;);</span><br><span class="line">ui-&amp;gt;treeWidget-&amp;gt;setHeaderLabels(QStringList()&amp;lt;&amp;lt;&quot;123&quot;&amp;lt;&amp;lt;&quot;456&quot;); AddRoot(&quot;HELLO&quot;,&quot;WORLD&quot;); AddRoot(&quot;2&quot;,&quot;3&quot;); &#125; ui-&amp;gt;treeWidget-&amp;gt;setHeaderLabel(&quot;123&quot;);</span><br><span class="line">ui-&amp;gt;treeWidget-&amp;gt;setHeaderLabels(QStringList()&amp;lt;&amp;lt;&quot;123&quot;&amp;lt;&amp;lt;&quot;456&quot;);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.stx8.com/2018/03/08/java-%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="时空">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时空主站">
      <meta itemprop="description" content="时空主站">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 时空主站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/08/java-%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Java 笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-03-08 21:21:27" itemprop="dateCreated datePublished" datetime="2018-03-08T21:21:27+08:00">2018-03-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/03/08/java-%E7%AC%94%E8%AE%B0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/08/java-笔记/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java-笔记"><a href="#Java-笔记" class="headerlink" title="Java 笔记"></a>Java 笔记</h1><h2 id="数据类型和运算符"><a href="#数据类型和运算符" class="headerlink" title="数据类型和运算符"></a>数据类型和运算符</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>bool</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="普通常量"><a href="#普通常量" class="headerlink" title="普通常量"></a>普通常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">final int A = 20;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test1 test1 = new Test1();</span><br><span class="line">System.out.println(test1.A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类常量"><a href="#类常量" class="headerlink" title="类常量"></a>类常量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">static final int B = 20;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(B);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量一般都定义为大写字母</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 30;</span><br><span class="line">System.out.println(a++);</span><br><span class="line">System.out.println(++a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>30<br>32</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>binarySearch()</code>, 使用二分搜索法来搜索指定数组，以获得指定对象。</p>
<p>在进行此调用之前，必须根据元素的自然顺序对数组进行升序排序（通过 sort() 方法）</p>
<p>参数：</p>
<ul>
<li>a - 要搜索的数组</li>
<li>key - 要搜索的值</li>
</ul>
<p>返回：</p>
<ul>
<li>如果它包含在数组中，则返回搜索键的索引；</li>
<li>否则返回 (-(插入点) - 1) 。</li>
<li>插入点被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为<code>a.length</code>。</li>
<li>注意，这保证了当且仅当此键被找到时，返回的值将 &gt;&#x3D; 0。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SearchArray</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">int[] array = &#123;2, 4, 6, 1, 3, 5, 9, 11, -5, 30, 100&#125;;</span><br><span class="line">Arrays.sort(array);</span><br><span class="line">int index = Arrays.binarySearch(array, 11);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line">System.out.println(&quot;The index of 11 is &quot;+index);</span><br><span class="line">index = Arrays.binarySearch(array, 10);</span><br><span class="line">System.out.println(&quot;The index of 10 is &quot;+index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>[-5, 1, 2, 3, 4, 5, 6, 9, 11, 30, 100]<br>The index of 11 is 8<br>The index of 10 is -9</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ol>
<li>串连接：<code>+</code>，<code>concat()</code></li>
<li>提取子字符串：<code>substring()</code></li>
<li>提取字符：<code>charAt()</code></li>
<li>获取字符串长度：<code>length</code></li>
<li>判断字符串是否相等：<code>equal()</code></li>
</ol>
<p>有的登陆系统密码忽略大小写。此时java语言中有个方法就是equalsIgnoreCase(String str)，这个方法忽略字符串大小写。</p>
<h3 id="常见疑难-equals-和-x3D-x3D-的区别"><a href="#常见疑难-equals-和-x3D-x3D-的区别" class="headerlink" title="常见疑难: equals 和 &#x3D;&#x3D; 的区别"></a>常见疑难: equals 和 &#x3D;&#x3D; 的区别</h3><p>java中的数据类型，可分为两类：</p>
<ol>
<li>基本数据类型，也称原始数据类型。</li>
</ol>
<p>byte,short,char,int,long,float,double,boolean</p>
<p>他们之间的比较，应用双等号（&#x3D;&#x3D;）,比较的是他们的值。</p>
<ol>
<li>复合数据类型(类)</li>
</ol>
<p>当他们用（&#x3D;&#x3D;）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。</p>
<p>对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（&#x3D;&#x3D;）进行比较的，所以比较后的结果跟双等号（&#x3D;&#x3D;）的结果相同。</p>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><ol>
<li>追加：<code>append()</code></li>
<li>指定位置插入字符串：<code>insert()</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class StringBufferTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">StringBuffer strbuf1 = new StringBuffer();</span><br><span class="line">System.out.println(strbuf1.capacity());</span><br><span class="line">System.out.println(strbuf1.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>16<br>0</p>
<h3 id="常见疑难-：String-和-StringBufffer-的区别"><a href="#常见疑难-：String-和-StringBufffer-的区别" class="headerlink" title="常见疑难 ：String 和 StringBufffer 的区别"></a>常见疑难 ：String 和 StringBufffer 的区别</h3><p>StringBuffer对象的内容可以修改；String对象一旦产生后就不可以被修改，重新赋值其实是两个对象。</p>
<p>StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。</p>
<h4 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h4><p>在String类中没有用来改变已有字符串中的某个字符的方法，由于不能改变一个java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的。然而，不可改变的字符串具有一个很大的优点:编译器可以把字符串设为共享的。</p>
<h4 id="StringBuffer-1"><a href="#StringBuffer-1" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>StringBuffer类属于一种辅助类，可预先分配指定长度的内存块建立一个字符串缓冲区。这样使用StringBuffer类的append方法追加字符 比 String使用 + 操作符添加字符 到 一个已经存在的字符串后面有效率得多。因为使用 + 操作符每一次将字符添加到一个字符串中去时，字符串对象都需要寻找一个新的内存空间来容纳更大的字符串，这无凝是一个非常消耗时间的操作。添加多个字符也就意味着要一次又一次的对字符串重新分配内存。使用StringBuffer类就避免了这个问题。<br>StringBuffer是线程安全的，在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="访问控制符：public-private-protected-default"><a href="#访问控制符：public-private-protected-default" class="headerlink" title="访问控制符：public ,private ,protected, default"></a>访问控制符：public ,private ,protected, default</h4><table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中可见</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>同一包中对子类可见</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>同一包中对非子类可见</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不同包中对子类可见</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不同包中对非子类可见</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="基础类-：Math，Date"><a href="#基础类-：Math，Date" class="headerlink" title="基础类 ：Math，Date"></a>基础类 ：Math，Date</h4><h2 id="重载和包"><a href="#重载和包" class="headerlink" title="重载和包"></a>重载和包</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载的实质</p>
<ul>
<li>方法名相同</li>
<li>参数个数可以不同</li>
<li>参数类型可以不同</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class overload &#123;</span><br><span class="line">// /一个普通的方法，不带参数</span><br><span class="line">void test() &#123;</span><br><span class="line">System.out.println(&quot;No parameters&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /重载上面的方法，并且带了一个整型参数</span><br><span class="line">void test(int a) &#123;</span><br><span class="line">System.out.println(&quot;a: &quot; + a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /重载上面的方法，并且带了两个参数</span><br><span class="line">void test(int a, int b) &#123;</span><br><span class="line">System.out.println(&quot;a and b: &quot; + a + &quot; &quot; + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /重载上面的方法，并且带了一个双精度参数，与上面带一个参数的重载方法不一样</span><br><span class="line">double test(double a) &#123;</span><br><span class="line">System.out.println(&quot;double a: &quot; + a);</span><br><span class="line">return a * a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">overload o = new overload(); //创建了对象o</span><br><span class="line">o.test();</span><br><span class="line">o.test(2);</span><br><span class="line">o.test(2, 3);</span><br><span class="line">o.test(2.0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>No parameters<br>a: 2<br>a and b: 2 3<br>double a: 2.0</p>
<h3 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h3><p><code>import com.stx8.test</code>，相当于C#里的<code>using</code>语句，C++里的头文件及namespace</p>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>extends</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">int a;</span><br><span class="line"></span><br><span class="line">People() &#123;</span><br><span class="line">a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People(int a) &#123;</span><br><span class="line">this.a = a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class men extends People &#123;</span><br><span class="line">int b;</span><br><span class="line"></span><br><span class="line">men(int a, int b) &#123;</span><br><span class="line">super(a);</span><br><span class="line">this.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">men m = new men(10, 20); //通过带参构造函数创建men类对象</span><br><span class="line">System.out.println(m.a + &quot; &quot; + m.b); //调用对象的成员变量a和b</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设计类的继承时的建议"><a href="#设计类的继承时的建议" class="headerlink" title="设计类的继承时的建议"></a>设计类的继承时的建议</h4><p>不要使用受保护字段，即<code>protected</code>字段</p>
<p>如果不希望自己的类再被扩展，可以在类的声明之前加上<code>final</code>关键字。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>构造函数名字与类名相同(包括大小写)</li>
<li>一个类可以有多个构造函数</li>
<li>构造函数没有返回值，也不用写<code>void</code>关键字</li>
<li>构造函数总和new运算符一起被调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Test3_super&#123;</span><br><span class="line">public Test3_super() &#123;</span><br><span class="line">// TODO 自动生成的构造函数存根</span><br><span class="line">System.out.println(&quot;父类构造函数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void fun1()&#123;</span><br><span class="line">System.out.println(&quot;父类F1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">protected void fun2() &#123;</span><br><span class="line">System.out.println(&quot;父类F2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">private void fun3() &#123;</span><br><span class="line">System.out.println(&quot;父类F3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test3 extends Test3_super&#123;</span><br><span class="line"></span><br><span class="line">Test3()&#123;</span><br><span class="line">super();</span><br><span class="line">System.out.println(&quot;子类构造函数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void fun2() &#123;</span><br><span class="line">System.out.println(&quot;子类F2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Test3 test3 = new Test3();</span><br><span class="line">test3.fun1();</span><br><span class="line">test3.fun2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>父类构造函数<br>子类构造函数<br>父类F1<br>子类F2</p>
<h4 id="java-的单继承性"><a href="#java-的单继承性" class="headerlink" title="java 的单继承性"></a>java 的单继承性</h4><p>针对同一方法，子类的访问控制权限只能等于或大于父类。</p>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态一定要遵守两个规则：</p>
<ul>
<li>方法名称一定要一样</li>
<li>传入参数的类型一定要不一样</li>
</ul>
<p>多态的两种表现形势</p>
<ul>
<li>重载</li>
<li>覆盖</li>
</ul>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 <code>interface</code></h2><p>接口中只有方法名，没有具体实现的方法体。</p>
<p>接口的声明默认是 <code>public</code>，有时候也可以省略。</p>
<p>类实现接口是要使用 <code>implements</code>关键字</p>
<p>在类实现接口时要注意：</p>
<ul>
<li>声明类需要实现指定接口</li>
<li>提供接口中所有方法的定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.interfacetest;</span><br><span class="line"></span><br><span class="line">interface Alarm &#123;</span><br><span class="line">void alarm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AlarmDoor implements Alarm &#123;</span><br><span class="line"></span><br><span class="line">void open() &#123;</span><br><span class="line">System.out.println(&quot;door open&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void close() &#123;</span><br><span class="line">System.out.println(&quot;door close&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void alarm() &#123;</span><br><span class="line">System.out.println(&quot;a door with alarm&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">AlarmDoor alarmDoor = new AlarmDoor();</span><br><span class="line">alarmDoor.alarm();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的多重实现"><a href="#接口的多重实现" class="headerlink" title="接口的多重实现"></a>接口的多重实现</h3><p>为解决java类中的单继承，一个类可以实现一个接口，也可以实现其他接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.interfacetest;</span><br><span class="line"></span><br><span class="line">interface Alarm &#123;</span><br><span class="line">void alarm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Window &#123;</span><br><span class="line">void window();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AlarmDoor implements Alarm, Window &#123;</span><br><span class="line"></span><br><span class="line">public void window() &#123;</span><br><span class="line">System.out.println(&quot;a door with window&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void alarm() &#123;</span><br><span class="line">System.out.println(&quot;a door with alarm&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceTest2 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">AlarmDoor alarmDoor = new AlarmDoor();</span><br><span class="line">alarmDoor.alarm();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h3><p>接口不是一个类，不可以使用关键字<code>new</code>来生成一个接口的实例。但是可以声明一个接口变量 “school sc”.</p>
<p>如果要生成一个接口的实例，可以让接口变量指向一个已经实现该接口的类的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">school sc = new student();</span><br></pre></td></tr></table></figure>

<p>在接口中，不能声明实例字段及静态方法，但可以声明常量。接口不一定要有方法，可以全是常量。</p>
<h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>和类一样，使用<code>extends</code>关键字实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.interfacetest;</span><br><span class="line"></span><br><span class="line">interface Lock &#123;</span><br><span class="line">void lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface HighLock extends Lock&#123;</span><br><span class="line">void hignlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Door implements HighLock &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void hignlock() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">System.out.println(&quot;WOW high lock&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void lock() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">System.out.println(&quot;just lock&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceTest3 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Door door = new Door();</span><br><span class="line">door.lock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类就是在类的内部再创建一个类。</p>
<h3 id="内部类的基本结构"><a href="#内部类的基本结构" class="headerlink" title="内部类的基本结构"></a>内部类的基本结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.interclass;</span><br><span class="line"></span><br><span class="line">//外部类</span><br><span class="line">class Out &#123;</span><br><span class="line">private int age = 12;</span><br><span class="line"></span><br><span class="line">//内部类</span><br><span class="line">class In &#123;</span><br><span class="line">public void print() &#123;</span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterclassTest1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Out.In in = new Out().new In();</span><br><span class="line">in.print();</span><br><span class="line"></span><br><span class="line">Out out = new Out();</span><br><span class="line">Out.In in2 = out.new In();</span><br><span class="line">in2.print();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类也就是没有名字的内部类，正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</p>
<p>不使用匿名内部类来实现抽象方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.interclass;</span><br><span class="line"></span><br><span class="line">abstract class Person &#123;</span><br><span class="line">public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Person &#123;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;eat something&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterclassTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person p = new Child();</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>eat something</p>
<p>可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用，但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p>
<p>这个时候就引入了匿名内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.interclass;</span><br><span class="line"></span><br><span class="line">abstract class Person1 &#123;</span><br><span class="line">public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterclassTest3 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Person p = new Person() &#123;</span><br><span class="line">public void eat() &#123;</span><br><span class="line">System.out.println(&quot;eat something&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>eat something</p>
<p>由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p>
<p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承<code>Thread</code>类或是继承<code>Runnable</code>接口</p>
<p><code>Thread</code>类的匿名内部类实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Thread t = new Thread() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">System.out.print(i + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Runnable</code>接口的匿名内部类实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Runnable r = new Runnable() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 1; i &lt;= 5; i++) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; &#125;; Thread t = new Thread(r); t.start(); &#125; &#125; ``` 内部类的好处： - 内部类的对象能够访问创建他的对象的所有方法和属性，包括私有数据 - 对于同一个包中的其他类来说，内部类是隐形的 。 - 匿名内部类可以很方便的定义回调 - 使用内部类可以方便的编写时间驱动的程序。 作为一个单独的类，只能有 `default` 和 `public` 两种访问控制符，但是作为内部类，可以使用 `private` 控制符。当内部类设置为 `private` 时，包含此内部类的外部类的方法才可以访问它。 ### 使用内部类来访问对象 内部类这个机制之所以出现，是因为存在如下两个目的： - 可以让程序中逻辑上相关的类结合在一起 - 内部类可以直接访问外部类的成员。 ## 常见疑难 接口与继承的区别： - 属性：接口中的所有属性都是公开静态常量，继承则无所谓 - 方法：接口中所有方法都是公开抽象方法，继承中所有方法不一定是抽象的 - 接口方法：接口没有构造器，继承有构造器 ## 抽象和封装 抽象就是讲拥有共同方法和属性的对象提取出来，提取后，重新设计一个更加通用、更加大众的类，这个类成为抽象类。 ### 抽象类 `abstract` 具有一个或多个抽象方法的类，本身就要被定义为抽象类。含有抽象方法的类一定是抽象类。 抽象类不仅可以有抽象方法，也可以又具体的方法，一个类中只要有一个抽象方法，就是抽象类。 抽象类中不一定含有抽象的方法，也可以全部都是具体的方法。 抽象类是可以继承的，如果子类没有实现抽象类的全部抽象方法，那么子类也是抽象类。如果实现了抽象类的全部抽象方法，那么子类就不是抽象类。 抽象类不可以被实例化。但是可以声明一个抽象类的变量指向具体子类的对象。 抽象类的好处在于，有的方法在父类中不想实现时，可以不用实现。 ```java package com.abstracttest; abstract class Door&#123; abstract void open(); abstract void close(); &#125; class MyDoor extends Door&#123; @Override void open() &#123; // TODO 自动生成的方法存根 System.out.println(&quot;i can open&quot;); &#125; @Override void close() &#123; // TODO 自动生成的方法存根 System.out.println(&quot;i can close&quot;); &#125; &#125; public class AbstractTest1 &#123; public static void main(String[] args) &#123; MyDoor myDoor = new MyDoor(); myDoor.close(); &#125; &#125; ``` ## 常见疑难 抽象与接口的区别： 共同点 - 都不能创建实例对象 - 可以声明变量，通过指向子类或实现类的对象类，来创建对象实例。 不同点 - Java 不支持多重继承，即一个子类只能有一个父类，但一个子类可以实现多个接口。 - 接口内不能有实例字段，只能有静态变量，抽象类可以拥有实例字段 - 接口内方法自动设置为 `public`的，抽象类中的方法必须手动声明访问控制符。 ## 枚举 `enum` ## 反射 程序自己能够检查自身信息。反射使得java语言具有了“动态性”，即程序首先会检查某个类中的方法、属性等信息，然后再动态的调用或动态的创建该类或该类的对象。 ### 反射类的基石 ――`Class`类 任何事物都可以用类表示，那么java中的类可以用一个什么类表示呢？ 从JDK1.2开始，就出现了Class类，该类描述Java中的一切事物，该类描述了关于类事务的类名字、类的访问属性、类所属的包名等。 ### 反射的基本应用 所谓反射就是把java类中的各种成分映射成相应的java类。 不仅java类，可以用`Class`类的对象表示，而java类的各种成员：成员变量、方法、构造方法、包等也可以用相应的类表示。 Java反射机制主要提供了以下功能： - 在运行时判断任意一个对象所属的类； - 在运行时构造任意一个类的对象； - 在运行时判断任意一个类所具有的成员变量和方法； - 在运行时调用任意一个对象的方法。 反射一般会设计如下类 ： - `Class` : 表示一个类的类 - `Filed` : 表示属性的类 - `Method` ： 表示方法的类 - `Constructor` : 表示类的构造方法的类 &amp;gt; `Class`类位于java.lang包中，而后面3个的类都位于java.lang.reflect包中</span><br><span class="line"></span><br><span class="line">编写Java反射程序的步骤：</span><br><span class="line"></span><br><span class="line">- 必须首先获取一个类的Class对象</span><br><span class="line">- 然后分别调用Class对象中的方法来获取一个类的属性/方法/构造方法的结构</span><br><span class="line"></span><br><span class="line">现有一个类：</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">package com.reflection;</span><br><span class="line">public class TestReflection &#123;</span><br><span class="line"></span><br><span class="line">private String username;</span><br><span class="line">private String password;</span><br><span class="line">private int[] age;</span><br><span class="line"></span><br><span class="line">public void setUserName(String username) &#123;</span><br><span class="line">this.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setPassWord(String password) &#123;</span><br><span class="line">this.password = password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取一个类的Class对象：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;TestReflection tfReflection = new TestReflection();</span><br><span class="line">Class c1 = TestReflection.class;</span><br><span class="line">Class c2 = Class.forName(&quot;com.reflection.TestReflection&quot;);</span><br><span class="line">Class c3 = tfReflection.getClass();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定的包名：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;String package01 = c1.getPackage().getName();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取类的修饰符:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;int mod = c1.getModifiers();</span><br><span class="line">String modifier = Modifier.toString(mod);</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定类的完全限定名：</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;String className = c1.getName();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定类的父类:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Class superClazz = c1.getSuperclass();</span><br><span class="line">String superClazzName = superClazz.getName();</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取实现的接口:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Class[] interfaces = c1.getInterfaces();</span><br><span class="line">for (Class t : interfaces) &#123;</span><br><span class="line">System.out.println(&quot;interfacesName = &quot; + t.getName());</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取指定类的成员变量:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Field[] fields = c1.getDeclaredFields();</span><br><span class="line">for (Field field : fields) &#123;</span><br><span class="line">modifier = Modifier.toString(field.getModifiers()); // 获取每个字段的访问修饰符</span><br><span class="line">Class type = field.getType(); // 获取字段的数据类型所对应的Class对象</span><br><span class="line">String name = field.getName(); // 获取字段名</span><br><span class="line">if (type.isArray()) &#123; // 如果是数组类型则需要特别处理</span><br><span class="line">String arrType = type.getComponentType().getName() + &quot;[]&quot;;</span><br><span class="line">System.out.println(&quot;&quot; + modifier + &quot; &quot; + arrType + &quot; &quot; + name + &quot;;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">System.out.println(&quot;&quot; + modifier + &quot; &quot; + type + &quot; &quot; + name + &quot;;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取类的构造方法:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Constructor[] constructors = c1.getDeclaredConstructors();</span><br><span class="line">for (Constructor constructor : constructors) &#123;</span><br><span class="line">String name = constructor.getName(); // 构造方法名</span><br><span class="line">modifier = Modifier.toString(constructor.getModifiers()); // 获取访问修饰符</span><br><span class="line">System.out.println(&quot;&quot; + modifier + &quot; &quot; + name + &quot;(&quot;);</span><br><span class="line">Class[] paramTypes = constructor.getParameterTypes(); // 获取构造方法中的参数</span><br><span class="line">for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123;</span><br><span class="line">System.out.print(&quot;,&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (paramTypes[i].isArray()) &#123;</span><br><span class="line">System.out.println(paramTypes[i].getComponentType().getName() + &quot;[]&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(paramTypes[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;);&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">获取成员方法:</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Method[] methods = c1.getDeclaredMethods();</span><br><span class="line">for (Method method : methods) &#123;</span><br><span class="line">modifier = Modifier.toString(method.getModifiers());</span><br><span class="line">Class returnType = method.getReturnType(); // 获取方法的返回类型</span><br><span class="line">if (returnType.isArray()) &#123;</span><br><span class="line">String arrType = returnType.getComponentType().getName() + &quot;[]&quot;;</span><br><span class="line">System.out.print(&quot;&quot; + modifier + &quot; &quot; + arrType + &quot; &quot; + method.getName() + &quot;(&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(&quot;&quot; + modifier + &quot; &quot; + returnType.getName() + &quot; &quot; + method.getName() + &quot;(&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Class[] paramTypes = method.getParameterTypes();</span><br><span class="line">for (int i = 0; i &lt; paramTypes.length; i++) &#123; if (i &gt; 0) &#123;</span><br><span class="line">System.out.print(&quot;,&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (paramTypes[i].isArray()) &#123;</span><br><span class="line">System.out.println(paramTypes[i].getComponentType().getName() + &quot;[]&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.print(paramTypes[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;);&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">反射调用方法，可以通过Method类的invoke方法实现动态方法的调用:</span><br><span class="line"></span><br><span class="line">&lt;code&gt;public Object invoke(Object obj, Object... args)&lt;/code&gt;</span><br><span class="line">第一个参数代表对象</span><br><span class="line">第二个参数代表执行方法上的参数</span><br><span class="line"></span><br><span class="line">若反射要调用类的某个私有方法，可以在这个私有方法对应的Mehtod对象上先调用&lt;code&gt;setAccessible(true)&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static void test02() throws InstantiationException, IllegalAccessException, SecurityException,</span><br><span class="line">NoSuchMethodException, IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">Class c1 = TestReflection.class;</span><br><span class="line">TestReflection t1 = (TestReflection) c1.newInstance(); // 利用反射来创建类的对象</span><br><span class="line"></span><br><span class="line">Method method = c1.getDeclaredMethod(&quot;setUserName&quot;, String.class);</span><br><span class="line">method.invoke(t1, &quot;Java反射的学习&quot;);</span><br><span class="line">method = c1.getDeclaredMethod(&quot;setPassWord&quot;, String.class);</span><br><span class="line">method.setAccessible(true);</span><br><span class="line">method.invoke(t1, &quot;反射执行某个Private修饰的方法&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;反射的一些应用&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">既然String是不可变字符串对象，如何才能改变让其可变?[反射的一些应用][1]</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public static void stringReflection() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">String s = &quot;Hello World&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;s = &quot; + s); //Hello World</span><br><span class="line"></span><br><span class="line">//获取String类中的value字段</span><br><span class="line">Field valueField = String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line"></span><br><span class="line">//改变value属性的访问权限</span><br><span class="line">valueField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">char[] value = (char[]) valueField.get(s);</span><br><span class="line"></span><br><span class="line">//改变value所引用的数组中的第5个字符</span><br><span class="line">value[5] = &#x27;_&#x27;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;s = &quot; + s); //Hello_World</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">既然String对象中没有对外提供可用的public setters等方法，因此只能通过Java中的反射机制实现。因此，前文中说到的String是不可变字符串对象只是针对“正常情况下”。而非必然。</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  Java的反射机制的概念：</span><br><span class="line">  在Java运行时环境中，对于任意一个类，能否知道这个类的哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java语言的反射（Reflection）机制。</span><br><span class="line">  </span><br><span class="line">  Reflection是Java被视为动态（准动态）语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括modifiers（诸如static、public等等）、superclass（例如Object）、实现interfaces（例如Serializable），也包括fields和methods的所有信息，并可于运行时改变fields内容或调用methods。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;标注 Annotation&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">在实际的应用中期可以部分或全部的取代传统的XML等部署描述文件。之所以要出现标注特性，是因为部署描述文件很复杂，在具体编写时很容易出错。</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;标注的简单使用&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@SuppressWarning&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class SimpleAnnotation &#123;</span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.runFinalizersOnExit(true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;几个简单的内置标注&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@Override&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.Annotation;</span><br><span class="line"></span><br><span class="line">class People&#123;</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;people name&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends People&#123;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;student name&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Annotation_Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Student student = new Student();</span><br><span class="line">System.out.println(student.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  &lt;code&gt;@Override&lt;/code&gt; 是方法标注，只能作用于方法，在覆盖父类方法却又写错了方法名的时候发挥作用。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@Deprecated&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">很多时候，设计了一个包含&lt;code&gt;sayHello()&lt;/code&gt;方法的类&lt;code&gt;Hello.java&lt;/code&gt;，但是经过一段时间发现，&lt;code&gt;sayHello1()&lt;/code&gt;可以更好更快的实现相同的功能。但是这个时候如果去掉方法&lt;code&gt;sayHello()&lt;/code&gt;，那么调用该方法的类就会出现错误。为了兼容之前的类，而又不建议新设计的类使用方法&lt;code&gt;sayHello()&lt;/code&gt;，就需要把&lt;code&gt;Hello.java&lt;/code&gt;中的方法&lt;code&gt;sayHello()&lt;/code&gt;做&lt;code&gt;@Deprecated&lt;/code&gt;标注。</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;package com.Annotation;</span><br><span class="line"></span><br><span class="line">class Hello&#123;</span><br><span class="line"></span><br><span class="line">@Deprecated</span><br><span class="line">public void sayHello()&#123;</span><br><span class="line">System.out.println(&quot;已经过时的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void sayHello1() &#123;</span><br><span class="line">System.out.println(&quot;现在的方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Deprecated_Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Hello hello = new Hello();</span><br><span class="line">hello.sayHello();</span><br><span class="line">hello.sayHello1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">当一个类或者类成员使用&lt;code&gt;@Deprecated&lt;/code&gt;修饰的话，编译器将不鼓励使用这个被标注的程序元素，而且这种修饰具有一定的“延续性”，即在代码中通过继承或者覆盖使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型并不是被声明为&lt;code&gt;@Deprecated&lt;/code&gt;，但是编译器仍要报警。</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  &lt;code&gt;@Deprecated&lt;/code&gt;标注不仅可以用在方法前面，而且可以用在参数或类的前面。</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;code&gt;@SuppressWarning&lt;/code&gt;</span><br><span class="line"></span><br><span class="line">可以用作标注类，属性、方法等成员，主要用于屏蔽警告。该标注于前面两个标注最大不同点在于其带有参数，并且参数可以是一个，可以是多个。参数的值为警告的类型。如：</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;已过时的警告 ： deprecation&lt;/li&gt;</span><br><span class="line">&lt;li&gt;没有使用警告 ： unused&lt;/li&gt;</span><br><span class="line">&lt;li&gt;类型不安全警告 ： unchecked&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">  当&lt;code&gt;@SuppressWarning&lt;/code&gt; 接收的参数为多个值得时候，必须使用数组的方式为参数赋值。例如@SuppressWarning(&#123;&quot;deprecation&quot;,&quot;unused&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;泛型 &lt;code&gt;&amp;lt;E&amp;gt;&lt;/code&gt;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">所谓泛型，其本质就是实现参数化类型，也就是说所操作的数据类型被指定为一个参数。</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;泛型概念的提出:&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;qqyumidi&quot;);</span><br><span class="line">list.add(&quot;corn&quot;);</span><br><span class="line">list.add(100);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123; String name = (String) list.get(i); // 1 System.out.println(&quot;name:&quot; + name); &#125; &#125; &#125; ``` 运行结果 name:qqyumidi name:corn Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String at com.fan.GenericTest.main(GenericTest.java:15) &amp;gt; Java2的集合框架，抽其核心，主要有三种：List、Set和Map。</span><br><span class="line">需要注意的是，这里的 Collection、List、Set和Map都是接口（Interface），不是具体的类实现。 List lst = new ArrayList(); 这是我们平常经常使用的创建一个新的List的语句，在这里， List是接口，ArrayList才是具体的类。</span><br><span class="line">常用集合类的继承结构如下：</span><br><span class="line">Collection&amp;lt;--List&amp;lt;--Vector</span><br><span class="line">Collection&amp;lt;--List&amp;lt;--ArrayList</span><br><span class="line">Collection&amp;lt;--List&amp;lt;--LinkedList</span><br><span class="line">Collection&amp;lt;--Set&amp;lt;--HashSet</span><br><span class="line">Collection&amp;lt;--Set&amp;lt;--HashSet&amp;lt;--LinkedHashSet</span><br><span class="line">Collection&amp;lt;--Set&amp;lt;--SortedSet&amp;lt;--TreeSet</span><br><span class="line">Map&amp;lt;--SortedMap&amp;lt;--TreeMap</span><br><span class="line">Map&amp;lt;--HashMap</span><br><span class="line"></span><br><span class="line">定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。</span><br><span class="line"></span><br><span class="line">在如上的编码过程中，我们发现主要存在两个问题：</span><br><span class="line"></span><br><span class="line">1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。</span><br><span class="line"></span><br><span class="line">2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。</span><br><span class="line"></span><br><span class="line">那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。</span><br><span class="line"></span><br><span class="line">### 什么是泛型？</span><br><span class="line"></span><br><span class="line">泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*</span><br><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;qqyumidi&quot;);</span><br><span class="line">list.add(&quot;corn&quot;);</span><br><span class="line">list.add(100);</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">List&lt;string&gt; list = new ArrayList&lt;string&gt;();</span><br><span class="line">list.add(&quot;qqyumidi&quot;);</span><br><span class="line">list.add(&quot;corn&quot;);</span><br><span class="line">//list.add(100); // 1 提示编译错误&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">String name = list.get(i); // 2</span><br><span class="line">System.out.println(&quot;name:&quot; + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义泛型接口、泛型类和泛型方法"><a href="#自定义泛型接口、泛型类和泛型方法" class="headerlink" title="自定义泛型接口、泛型类和泛型方法"></a>自定义泛型接口、泛型类和泛型方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest1 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; num = new Box&lt;integer&gt;(4);</span><br><span class="line">System.out.println(&quot;name:&quot; + name.getData());</span><br><span class="line">System.out.println(&quot;num:&quot; + num.getData());</span><br><span class="line">&#125;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Box&lt;t&gt; &#123;&lt;/t&gt;</span><br><span class="line"></span><br><span class="line">private T data;</span><br><span class="line"></span><br><span class="line">public Box() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Box(T data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T getData() &#123;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>name:corn<br>num:4</p>
<p>在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;name class:&quot; + name.getClass()); // com.qqyumidi.Box</span><br><span class="line">System.out.println(&quot;age class:&quot; + age.getClass()); // com.qqyumidi.Box</span><br><span class="line">System.out.println(name.getClass() == age.getClass()); // true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>name class:class com.fan.Box<br>num class:class com.fan.Box<br>true</p>
<p>由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。</p>
<p>究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
<h3 id="关于泛型通配符"><a href="#关于泛型通配符" class="headerlink" title="关于泛型通配符"></a>关于泛型通配符</h3><p>接着上面的结论，我们知道，Box<Number>和Box<Integer>实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于<code>Box&lt;Number&gt;</code>和<code>Box&lt;Integer&gt;</code>是否可以看成具有父子关系的泛型类型呢？</p>
<blockquote>
<p>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类Number的子类。</p>
</blockquote>
<h3 id="关于泛型的一些特性"><a href="#关于泛型的一些特性" class="headerlink" title="关于泛型的一些特性"></a>关于泛型的一些特性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;number&gt; name = new Box&lt;number&gt;(99);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);&lt;/integer&gt;&lt;/integer&gt;&lt;/number&gt;&lt;/number&gt;</span><br><span class="line"></span><br><span class="line">getData(name);</span><br><span class="line">getData(age); // 1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getData(Box&lt;number&gt; data)&#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;&lt;/number&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过提示信息，我们知道<code>Box&lt;Number&gt;</code>在逻辑上不能视为<code>Box&lt;Integer&gt;</code>的父类.</p>
<p>我们需要一个在逻辑上可以用来表示同时是<code>Box&lt;Integer&gt;</code>和<code>Box&lt;Number&gt;</code>的父类的一个引用类型，由此，类型通配符应运而生。</p>
<p>类型通配符一般是使用 <code>?</code>代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且<code>Box&lt;?&gt;</code>在逻辑上是<code>Box&lt;Integer&gt;</code>、<code>Box&lt;Number&gt;</code>…等所有<code>Box&lt;具体类型实参&gt;</code>的父类。由此，我们依然可以定义泛型方法，来完成此类需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);</span><br><span class="line">Box&lt;number&gt; number = new Box&lt;number&gt;(314);&lt;/number&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">getData(name);</span><br><span class="line">getData(age);</span><br><span class="line">getData(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getData(Box&lt;?&gt; data) &#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？</p>
<p>在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Box&lt;string&gt; name = new Box&lt;string&gt;(&quot;corn&quot;);</span><br><span class="line">Box&lt;integer&gt; age = new Box&lt;integer&gt;(712);</span><br><span class="line">Box&lt;number&gt; number = new Box&lt;number&gt;(314);&lt;/number&gt;&lt;/number&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">getData(name);</span><br><span class="line">getData(age);</span><br><span class="line">getData(number);</span><br><span class="line"></span><br><span class="line">//getUpperNumberData(name); // 1</span><br><span class="line">getUpperNumberData(age); // 2</span><br><span class="line">getUpperNumberData(number); // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getData(Box&lt;?&gt; data) &#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void getUpperNumberData(Box&lt;? extends Number&gt; data)&#123;</span><br><span class="line">System.out.println(&quot;data :&quot; + data.getData());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，显然，在代码&#x2F;&#x2F;1处调用将出现错误提示，而&#x2F;&#x2F;2 &#x2F;&#x2F;3处调用正常。</p>
<p>类型通配符上限通过形如Box&lt;? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt;? super Number&gt;形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>程序是计算机指令集合，它以文件形式存储在磁盘上</p>
<p>进程就是一个执行中的程序，每一个进程都有一个独立的内存空间和资源系统。</p>
<p>线程是CPU调度和分配的基本单位，一个进程可以由多个线程组成，而这多个线程共享同一个存储空间，这使得线程间的通信比较容易。</p>
<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>创建线程的方法有两种 ：</p>
<ul>
<li>通过实现<code>Runnable</code>接口的方式创建线程</li>
<li>通过集成<code>Threa</code>类来创建线程</li>
</ul>
<h4 id="通过实现Runnable接口的方式创建线程"><a href="#通过实现Runnable接口的方式创建线程" class="headerlink" title="通过实现Runnable接口的方式创建线程"></a>通过实现<code>Runnable</code>接口的方式创建线程</h4><p>在java中，线程是一种对象，而不是所有的对象都可以被称为线程，只有实现了<code>Runnable</code>接口的对象才可以被称为线程。</p>
<p><code>Runnable</code>接口的定义：</p>
<p>public interface new Runnable() {<br>public abstract void run() ;<br>}</p>
<p>只有实现了该接口的类才有资格被称为线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.threadtest;</span><br><span class="line"></span><br><span class="line">class ThreadTest implements Runnable &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest2 implements Runnable&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadTest1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ThreadTest test = new ThreadTest();</span><br><span class="line">ThreadTest2 test2 = new ThreadTest2();</span><br><span class="line">Thread thread = new Thread(test);</span><br><span class="line">Thread thread2 = new Thread(test2);</span><br><span class="line">thread.start();</span><br><span class="line">thread2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java技术中，线程通常是通过调度模块来执行的。所谓抢占式调度模式是指：许多线程处于可以运行状态，即等待状态，但实际只有一个线程在运行。该线程一直运行直到他终止或是另一个优先级更高的线程变成可运行状态。</p>
<h4 id="通过继承Thread类的方式创建线程"><a href="#通过继承Thread类的方式创建线程" class="headerlink" title="通过继承Thread类的方式创建线程"></a>通过继承<code>Thread</code>类的方式创建线程</h4><p>其实<code>Thread</code>本身也实现了<code>Runnable</code>接口，所以只要让一个类继承<code>Thread</code>类，并覆盖<code>run()</code>方法，也会创建进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.threadtest;</span><br><span class="line"></span><br><span class="line">class Threadtest_3 extends Thread &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 1&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest_4 extends Thread&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;thread 2&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Threadtest_3 threadtest_3 =new Threadtest_3();</span><br><span class="line">ThreadTest_4 threadTest_4 = new ThreadTest_4();</span><br><span class="line"></span><br><span class="line">Thread thread3 = new Thread(threadtest_3);</span><br><span class="line">Thread thread4 = new Thread(threadTest_4);</span><br><span class="line"></span><br><span class="line">thread3.start();</span><br><span class="line">thread4.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程包括5种状态：新建状态、就绪状态、运行状态、阻塞状态和死亡状态。</p>
<p>新建状态</p>
<p>线程对象通过<code>new</code>关键字已经建立，在内存中有一个活跃的对象，但是没有启动该线程，所以它仍不能做任何事情，此时线程处于新建状态，程序中没有运行线程中的代码，如果线程要运行需要处于就绪状态。</p>
<p>就绪状态</p>
<p>一个线程一旦调用了<code>start()</code>方法，该线程就处于就绪状态。此时线程等待CPU时间片，一旦获得CPU时间周期，一旦获得CPU周期，线程就可以执行。这种状态下的任何时刻，线程是否执行完全取决于系统的调度程序。</p>
<p>运行状态</p>
<p>一旦处于就绪状态的线程获得CPU执行周期，就处于运行状态，执行多线程代码部分的运算。线程一旦运行，只是在CPU周期内获得执行权利，而一旦CPU的时间片用完，操作系统会给其他的线程运行的机会，而剥夺当前线程的执行。在选择哪个线程可以执行时，操作系统的调度程序会考虑现成的优先级，该内容后续讲解。</p>
<p>阻塞状态</p>
<p>该状态下线程无法运行，必须满足一定条件条件后才可以执行。如果线程处于阻塞状态，JVM调度机不会为其分配CPU周期。而线程满足一定条件就被解除阻塞，线程处于就绪状态，此时就获得了被执行的机会。当发生以下情况的时候线程会进入阻塞状态：</p>
<ul>
<li>线程正在等待一个输入输出操作，该操作完成前不会返回其调用者。</li>
<li>线程调用了<code>wait()</code>方法或是<code>sleep()</code>方法。</li>
<li>线程需要满足某种条件之后可以继续执行。</li>
</ul>
<p>死亡状态</p>
<p>线程一旦退出<code>run()</code>方法就处于死亡状态。</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>线程的执行顺序是一种抢占方式，优先级高的比优先级低的要获得更多的执行时间，如果想让一个线程比其他线程有更多的运行时间，可以通过设置线程的优先级解决。</p>
<p>具体方法如下：</p>
<p>public final void setPriority(int newPriority);</p>
<p>其中，<code>newPriority</code>是一个1~10的正整数，数值越大，优先级别越高。系统定义了一些常用的数值如下：</p>
<ul>
<li>public final static int MIN_PRIORITY &#x3D; 1 ：表示最低优先级</li>
<li>public final static int MAX_PRIORITY &#x3D; 10 ：表示最高优先级</li>
<li>public final static int NORM_PRIORITY &#x3D; 5 ：表示默认优先级</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.threadtest;</span><br><span class="line"></span><br><span class="line">import org.omg.CORBA.PUBLIC_MEMBER;</span><br><span class="line"></span><br><span class="line">class Threadtest_3 extends Thread &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadTest_4 extends Thread&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">System.out.println(&quot;hello&quot;+ i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadTest2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Threadtest_3 threadtest_3 =new Threadtest_3();</span><br><span class="line">ThreadTest_4 threadTest_4 = new ThreadTest_4();</span><br><span class="line"></span><br><span class="line">Thread thread3 = new Thread(threadtest_3);</span><br><span class="line">Thread thread4 = new Thread(threadTest_4);</span><br><span class="line"></span><br><span class="line">thread3.setPriority(3);</span><br><span class="line">thread4.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">thread3.start();</span><br><span class="line">thread4.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的休眠与唤醒"><a href="#线程的休眠与唤醒" class="headerlink" title="线程的休眠与唤醒"></a>线程的休眠与唤醒</h3><p>线程的休眠 <code>sleep()</code></p>
<p>线程处于等待状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">///这是一个主运行类</span><br><span class="line">///创建一个线程对象，让其运行</span><br><span class="line">public class thread5</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute27 t=new compute27();</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类，在这个类中，通过休眠来输出不同结果</span><br><span class="line">class compute27 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;在工作中，不要打扰&quot;);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">sleep(1000000);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;哦，电话来了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程唤醒 <code>interrup()</code></p>
<p>当一个线程处于休眠状态，如果开始设置了休眠时间是1000ms，但是想在休眠了500ms的时候，让它继续执行，这时候就可以使用线程唤醒功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">public class thread6</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute28 t=new compute28();</span><br><span class="line">t.start();</span><br><span class="line">t.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类，在这个类中，通过休眠，让线程运行输出不同的结果</span><br><span class="line">class compute28 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;在工作中，不要打扰&quot;);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">sleep(1000000);</span><br><span class="line">&#125;</span><br><span class="line">catch(Exception e)&#123;System.out.println(&quot;哦，电话来了&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程让步-yield"><a href="#线程让步-yield" class="headerlink" title="线程让步 yield()"></a>线程让步 <code>yield()</code></h3><p>所谓线程让步，就是使当前正在运行的线程对象退出运行状态，让其他线程运行。</p>
<p>这个方法不能讲运行权让给指定的线程，只是允许这个线程把运行权让出来，至于给谁，就看谁能抢到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">///这是一个主运行类</span><br><span class="line">///在主运行方法中，通过创建两个线程对象，让其交替执行</span><br><span class="line">public class thread7</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute29 t=new compute29();</span><br><span class="line">compute30 t1=new compute30();</span><br><span class="line">t.start();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///通过循环语句来输出十个整型数据</span><br><span class="line">///通过让步程序让此线程停止运行</span><br><span class="line">class compute29 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///通过循环语句来输出说明语句</span><br><span class="line">class compute30 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;这个数字是:&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">//这是一个主运行类</span><br><span class="line">///在主运行方法中，通过创建两个线程对象，让其交替执行</span><br><span class="line">public class thread8</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute31 t=new compute31(&#x27;a&#x27;);</span><br><span class="line">compute31 t1=new compute31(&#x27;b&#x27;);</span><br><span class="line">t.start();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///在这线程类中，使用循环语句输出字符</span><br><span class="line">class compute31 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">compute31(char ch)</span><br><span class="line">&#123;</span><br><span class="line">this.ch=ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程循环输出，就会出现抢占现象。解决这个问题的办法是可以使用线程同步，解决同步的两个方法：</p>
<ul>
<li>同步块</li>
<li>同步化方法</li>
</ul>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><p>同步块是使具有某个对象监视点的线程，获得运行权限的一种方法，每个对象只能在拥有这个监视点的情况下，才能获得运行权限。</p>
<p>同步块的结构如下：</p>
<p>synchronized (bObject) {<br>程序段<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.avd;</span><br><span class="line">//这是一个主运行类</span><br><span class="line">///在主运行方法中，通过创建两个线程对象，让其交替执行</span><br><span class="line">public class thread8</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">compute31 t=new compute31(&#x27;a&#x27;);</span><br><span class="line">compute31 t1=new compute31(&#x27;b&#x27;);</span><br><span class="line">t.start();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///创建一个线程类</span><br><span class="line">///在这线程类中，使用循环语句输出字符</span><br><span class="line">class compute31 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">static Object bObject = new Object();</span><br><span class="line">compute31(char ch)</span><br><span class="line">&#123;</span><br><span class="line">this.ch=ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">synchronized (bObject) &#123;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;10;i++) &#123; System.out.print(ch); &#125; &#125; &#125; &#125; ``` ### 同步化方法 同步化方法就是对整个方法进行同步： 结构如下： synchronized void f() &#123; 代码 &#125; ```java //这是一个主运行类 ///在主运行方法中，通过创建三个线程对象，让其交替执行 public class thread11 &#123; public static void main(String[] args) &#123; compute34 t=new compute34(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); &#125; &#125; ///创建一个线程类 ///在这线程类中，使用循环语句输出字符 ///在run方法中，使用同步块来给线程加一把锁 class compute34 extends Thread &#123; int i=10; static Object obj=new Object(); public void print() &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); i--; &#125; public void run() &#123; while(i&amp;gt;0) &#123; synchronized(obj) &#123; print(); &#125; try &#123; sleep(1000); &#125; catch(Exception e)&#123;&#125; &#125; &#125; &#125; ``` ## 异常的处理和内存管理 ## Java 输入和输出 Java程序类库中包含大量的输入输出类，提供不同情况的不同功能。其中包括： - 关于文件操作的类 `File` - 关于以字节方式访问文件的类 `InputStream`和类`OutStream` - 关于以字符方式访问文件的类`Reader`和类`Writer` &amp;gt; 在编写程序的过程中，若是要使用输入输出类的方法和属性值，就需要引入`java.io`类</span><br><span class="line"></span><br><span class="line">## Java 的I/O操作</span><br><span class="line"></span><br><span class="line">Java中I/O操作主要是指使用Java进行输入，输出操作.</span><br><span class="line"></span><br><span class="line">Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。Java的I/O流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供以数据流的方式读写它的数据的方法。</span><br><span class="line"></span><br><span class="line">总结的基本概念如下：</span><br><span class="line"></span><br><span class="line">数据流：</span><br><span class="line"></span><br><span class="line">一组有序，有起点和终点的字节的数据序列。包括输入流和输出流。</span><br><span class="line"></span><br><span class="line">输入流：</span><br><span class="line"></span><br><span class="line">程序从输入流读取数据源。数据源包括外界(键盘、文件、网络…)，即是将数据源读入到程序的通信通道</span><br><span class="line"></span><br><span class="line">输出流：</span><br><span class="line"></span><br><span class="line">程序向输出流写入数据。将程序中的数据输出到外界（显示器、打印机、文件、网络…）的通信通道。</span><br><span class="line"></span><br><span class="line">采用数据流的目的就是使得输出输入独立于设备。</span><br><span class="line"></span><br><span class="line">数据流分类：</span><br><span class="line"></span><br><span class="line">流序列中的数据既可以是未经加工的原始二进制数据，也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：</span><br><span class="line">1) 字节流：数据流中最小的数据单元是字节</span><br><span class="line">2) 字符流：数据流中最小的数据单元是字符， Java中的字符是Unicode编码，一个字符占用两个字节。</span><br><span class="line"></span><br><span class="line">### 标准I/O</span><br><span class="line"></span><br><span class="line">### java.IO层次体系结构</span><br><span class="line"></span><br><span class="line">在整个Java.io包中最重要的就是5个类和一个接口。</span><br><span class="line"></span><br><span class="line">5个类指的是`File`、`OutputStream`、`InputStream`、`Writer`、`Reader`；</span><br><span class="line"></span><br><span class="line">1个接口指的是`Serializable`.</span><br><span class="line"></span><br><span class="line">掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了。</span><br><span class="line"></span><br><span class="line">主要的类如下：</span><br><span class="line"></span><br><span class="line">File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等。</span><br><span class="line">InputStream（二进制格式操作）：抽象类，基于字节的输入操作，是所有输入流的父类。定义了所有输入流都具有的共同特征。</span><br><span class="line">OutputStream（二进制格式操作）：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</span><br><span class="line"></span><br><span class="line">Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。</span><br><span class="line"></span><br><span class="line">Reader（文件格式操作）：抽象类，基于字符的输入操作。</span><br><span class="line">Writer（文件格式操作）：抽象类，基于字符的输出操作。</span><br><span class="line">RandomAccessFile（随机文件操作）：它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</span><br><span class="line"></span><br><span class="line">### 文件或目录信息的处理 `File`</span><br><span class="line"></span><br><span class="line">`File` 类提供了与文件或目录相关的信息</span><br><span class="line"></span><br><span class="line">文件处理方法：</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line">package com.filetest;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">public class FileTest1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">File file = new File(&quot;d:\\&quot;,&quot;file.txt&quot;);</span><br><span class="line">System.out.println(file.getName());</span><br><span class="line">System.out.println(file.getParent());</span><br><span class="line">System.out.println(file.getPath());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>file.txt<br>d:<br>d:\file.txt</p>
<p>文件和目录的操作：</p>
<p>在Java中，目录被当做一种特殊的文件使用。类<code>File</code>是唯一代表磁盘文件对象的类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package com.cjgong.chaozuo;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">///通过print方法来判断这个文件类对象的性质</span><br><span class="line">///通过print1方法来获取文件对象的信息</span><br><span class="line">///通过print2方法来获取文件对象的信息</span><br><span class="line">public class file1 &#123;</span><br><span class="line">public void print(File f) &#123;</span><br><span class="line">//通过print方法来判断这个文件类对象的性质</span><br><span class="line">if (f.isDirectory()) &#123;</span><br><span class="line">//判断f对象是否为目录</span><br><span class="line">System.out.println(&quot;这是一个目录！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;这不是一个目录！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (f.exists()) &#123;</span><br><span class="line">//判断f对象是否存在</span><br><span class="line">System.out.println(&quot;这个文件存在的！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;抱歉，这个文件不存在的！&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">f.createNewFile();</span><br><span class="line">//当文件不存在时，创建一个文件</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void print1(File f) &#123;</span><br><span class="line">//通过print1方法来获取文件目录对象的信息</span><br><span class="line">System.out.println(f.getName());</span><br><span class="line">System.out.println(f.getParent());</span><br><span class="line">System.out.println(f.getPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void print2(File f) &#123;</span><br><span class="line">//通过print2方法来获取文件对象的信息</span><br><span class="line">if (f.isFile()) &#123;</span><br><span class="line">System.out.println(f.lastModified());</span><br><span class="line">System.out.println(f.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">file1 f1 = new file1(); //创建一个f1对象</span><br><span class="line">File f = new File(&quot;d:\\filetest&quot;);</span><br><span class="line">//调用相应的方法</span><br><span class="line">f1.print(f);</span><br><span class="line">f1.print1(f);</span><br><span class="line">f1.print2(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>这不是一个目录！<br>抱歉，这个文件不存在的！<br>filetest<br>d:<br>d:\filetest<br>1452923459623<br>0</p>
<h3 id="使用文件字节输入流读取文件-FileInputStream"><a href="#使用文件字节输入流读取文件-FileInputStream" class="headerlink" title="使用文件字节输入流读取文件 FileInputStream"></a>使用文件字节输入流读取文件 <code>FileInputStream</code></h3><p><code>FileInputStream</code>类是是<code>InputStream</code>的子类，并且不是抽象类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">///创建一个文件类f</span><br><span class="line">///创建一个输入流对象fis，并且以f作为参数</span><br><span class="line">///使用循环语句将文本文件中的字符读出</span><br><span class="line">public class file3 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File f = new File(&quot;d:\\filetest\\file.txt&quot;);</span><br><span class="line">//创建一个文件类f</span><br><span class="line">FileInputStream fis = new FileInputStream(f);</span><br><span class="line">//创建对象f的文件输入流</span><br><span class="line">char ch;</span><br><span class="line">//声明一个字符串对象ch</span><br><span class="line">for (int i = 0; i &lt; f.length(); i++) &#123;</span><br><span class="line">//通过循环读取文件类f所对应的文件</span><br><span class="line">ch = (char) fis.read();</span><br><span class="line">System.out.print(ch);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用文件字节输出流输出文件-FileOutputStream"><a href="#使用文件字节输出流输出文件-FileOutputStream" class="headerlink" title="使用文件字节输出流输出文件 FileOutputStream"></a>使用文件字节输出流输出文件 <code>FileOutputStream</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">///创建一个文件类f</span><br><span class="line">///创建一个输入流对象fis，并且以f作为参数</span><br><span class="line">///将所有的字节都保存到一个字节数组b中。</span><br><span class="line">///使用循环语句将b中的字符读出</span><br><span class="line">public class file4 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File f = new File(&quot;d:\\filetest\\file.txt&quot;);</span><br><span class="line">//创建一个文件类f</span><br><span class="line">FileInputStream fis = new FileInputStream(f);</span><br><span class="line">//创建一个输入流对象fis，并且以f作为参数</span><br><span class="line">byte[] b = new byte[(int) f.length()];</span><br><span class="line">//创建一个字节数组对象b</span><br><span class="line">fis.read(b);</span><br><span class="line">//读取到的内容存储到字节数组对象b</span><br><span class="line">for (int i = 0; i &lt; f.length(); i++) &#123;</span><br><span class="line">//通过循环输出相应内容</span><br><span class="line">System.out.print((char) b[i]);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java中对数据的处理"><a href="#Java中对数据的处理" class="headerlink" title="Java中对数据的处理"></a>Java中对数据的处理</h2><h3 id="基本数据类型和对象数据类型的转换"><a href="#基本数据类型和对象数据类型的转换" class="headerlink" title="基本数据类型和对象数据类型的转换"></a>基本数据类型和对象数据类型的转换</h3><p>为什么要将基本类型转换成对象数据类型：</p>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(<code>Wrapper Class</code>)</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>由于所有的包装类具有比较相似的成员，这里以<code>Integer</code>类为例：</p>
<p><code>Integer</code>类的构造方法：</p>
<p>public integer(int value):将整型值value包装成持有此值的<code>Integer</code>类对象。<br>public integer(string s)：将由数字字符组成的串s包装成持有此值的<code>Integer</code>类对象，若s不是数字构成的话，则会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class file1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int x = 12; //创建一个整形类型变量x</span><br><span class="line">String str = &quot;13579&quot;; //创建一个字符串类型变量str</span><br><span class="line">//把变量x，str转换成对象类型t1和t2</span><br><span class="line">Integer t1 = new Integer(x);</span><br><span class="line">Integer t2 = new Integer(str);</span><br><span class="line">//通过tostring()把对象转换成字符串。</span><br><span class="line">System.out.println(t1);</span><br><span class="line">System.out.println(t2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何处理随机性数据-Random"><a href="#如何处理随机性数据-Random" class="headerlink" title="如何处理随机性数据 Random"></a>如何处理随机性数据 <code>Random</code></h3><h3 id="如何对数据进行排列、整理-Arrays"><a href="#如何对数据进行排列、整理-Arrays" class="headerlink" title="如何对数据进行排列、整理 Arrays"></a>如何对数据进行排列、整理 <code>Arrays</code></h3><h2 id="数据结构接口"><a href="#数据结构接口" class="headerlink" title="数据结构接口"></a>数据结构接口</h2><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><code>Collection</code>接口</h3><p><code>Collection</code>接口是数据集合接口，它位于数据结构API的最上部，构成<code>Collection</code>的单位被称为元素。可将<code>Collection</code>接口分为三个部分，分别是<code>Map</code>接口、<code>Set</code>接口和<code>List</code>接口。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2012 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">时空</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"stx8","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
